<?xml version="1.0" encoding="utf-8" ?>
<vulnerabilities xmlns="http://tempuri.org/XMLSchemaOptions.xsd">

<vuln_items>wasc_1</vuln_items>
<vuln_item_wasc_1>
	<alert>Yetersiz Kimlik Doğrulaması</alert>
	<desc>Yetersiz Kimlik Doğrulaması, bir web sitesinin saldırgana uygun kimlik doğrulaması yapmadan, hassas içeriğe veya işlevlere erişmesine izin verdiğinde oluşur. Web-tabanlı yönetim araçları, hassas işlevlere erişim sağlamaya izin veren web sitelerine güzel bir örnektir. Spesifik çevrimiçi kaynağa bağlı olarak, bu web uygulamaları kullanıcıların kimliklerini düzgün bir şekilde doğrulamadan doğrudan erişilebilir olmamalıdır.

Kimlik Doğrulama kurulumunun çevresinden dolaşmak için, bazı kaynaklar özel bir konumda "saklanmakta" ve bu konumların, ana web sayfasında veya diğer herkese açık yerlerde bağlantısı verilmemektedir. Fakat, bu yaklaşım "gizleyerek güvenlik"'ten başka bir şey değildir. Şunu anlamak önemli ki, bir kaynak saldırgan tarafından bilinmese de, bu kaynak hala ona özgü URL ile erişilebilir durumdadır. Bu spesifik URL, yaygın dosya ve dizin konumlarına (mesela /admin), hata mesajlarına, yönlendirme kayıtlarına veya yardım dosyaları gibi dökümanlara kaba kuvvet yoklamasıyla keşfedilebilir. Bu kaynaklar, ister içerik ister islevsellik temelli olsun, yeterli şekilde korunmalıdır.</desc>
	<solution>Faz: Mimari ve Tasarım
OWASP ESAPI Kimlik Kontrolü özelliği gibi, bir Kimlik Doğrulama çerçevesi veya kütüphanesi kullanınız.</solution>
	<reference>http://projects.webappsec.org/Insufficient-Authentication</reference>
	<reference>http://cwe.mitre.org/data/definitions/287.html</reference>
	<reference>http://cwe.mitre.org/data/definitions/284.html</reference>
</vuln_item_wasc_1>

<vuln_items>wasc_2</vuln_items>
<vuln_item_wasc_2>
	<alert>Yetersiz Yetkilendirme</alert>
	<desc>Yetersiz Yetkilendirme, bir uygulama bir kullanıcının güvenlik politikasıyla uyumlu bilgilere eriştiği veya işlemler gerçekleştirdiğine dair yeterli yetkilendirme kontrolleri sağlamadığında ortaya çıkar. Yetkilendirme prosedürleri bir kullanıcıyı, servisi veya uygulamayı, ona izin verilen şeyleri yapmasına zorlamalıdır. Bir kullanıcının bir web sitesinde kimliği doğrulandığında, bu o kullanıcının her içeriğe ve işleve erişim hakkı olduğu anlamına gelmez.

Pek çok uygulama, farklı kullanıcılara, farklı uygulama işlevlerini kullanma hakkı verir. Bir haber sitesi, kullanıcılara haberleri görüntüleme izni verir, haber yayınlama izni vermez. Bir muhasebe sisteminde, borçlu hesaplar müşterisiyle, alacaklı hesaplar müşterisinin izinleri farklıdır. Yetersiz İşlev Yetkilendirmesi, bir uygulamın kullanıcılarına, güvenlik politikasını ihlal eden uygulama işlevlerine erişimini engellemediğinde oluşur.

Bunun en bilinen örneği, 2005 yılı Harvard İşletme Okulu başvuru işleminin hacklenmesidir. Bir yetkilendirme hatası, kullanıcıların, web sitesinin o bölümüne erişim iznine sahip olmaması gerekirken, kendi bilgilerini görüntülemesine izin vermiştir.
 
Yetersiz Veri Yetkilendirmesi

Pek çok uygulama, URL'in altındaki veri bilgilerini sergilemektedir. Mesela, sistemdeki bir tıbbi kayda erişirken, URL şu şekilde olabilir:

 http://example.com/RecordView?id=12345

Eğer uygulama, kimliği doğrulanmış kullanıcının okuma hakkı olup olmadığını kontrol etmezse, kullanıcının görmemesi gerekn veriyi gösterebilir.

Yetersiz Veri yetkilendirmesi, Yetersiz İşlev Yetkilendirmesinden daha yaygındır, çünkü programcılar genellikle uygulama işlevleri açısından tam bilgiye sahiptir, fakat uygulamanın erişebileceği veri hakkında tam bir eşleştirmeye sahip değildir. Programcılar sıklıkla işlev yetkilendirme mekanizmaları hakkında sıkı bir kontrole sahiptir, fakat veri yetkilendirmesi için veritabanları gibi başka sistemlere güvenirler.</desc>
	<solution>Fazlar: Mimari ve Tasarım: Operasyon
Ayarları, yönetimi ve ayrıcalıkların ele alınmasını çok dikkatli bir şekilde yönetin. Yazılımdaki güven sınırlarını kesin bir şekilde yönetin.

Yürütülen Program: Mimarlık ve Tasarım Sistem dizaynına uygun bölümlendirmenin yapıldığından ve bölümlendirmenin ayrıcalık ayırma işlevselliğini arttırmaya ve daha da güçlendirmeye yaradığından emin olun. Mimarlar ve tasarımcılar, sistem ayrıcalıklarının kullanılması ve bırakılmasının uygun olduğuna karar verdiği durumlarda en düşük ayrıcalık prensiplerine güvenmeliler.</solution>
	<reference>http://projects.webappsec.org/Insufficient-Authentication</reference>
	<reference>http://cwe.mitre.org/data/definitions/284.html</reference>
	<reference>http://cwe.mitre.org/data/definitions/287.html</reference>
</vuln_item_wasc_2>

<vuln_items>wasc_3</vuln_items>
<vuln_item_wasc_3>
	<alert>Tamsayı taşması</alert>
	<desc>Bir tamsayı taşması, çarpma veya ekleme gibi bir aritmetik işlemin sonucu, onu saklayan integer tipinin boyutunu aştığı durumda gerçekleşir. Bir tamsayı taşması oluştuğunda, bir saatin 13.00'ı belirttiğinde 1.00'ı göstermesi gibi, belirtilen değer, maksimum değer ile sarmalanıp, minimum değerden başlayacak şekilde gösterilecektir.

Örnek olarak, 8 bit signed integer, çoğu bilgisayar mimarisinde maksimum 127, minimum -128 değerine sahiptir. Eğer bir programcı, bu tipte bir değişkende 127 değerini tutar ve bu değere 1 eklerse, sonuç 128 olmalıdır. Fakat, bu değer integer tipinin maksimum değerini aşacağı için, belirtilen değer sarmalanacak ve -128 olacaktır.</desc>
	<solution>Faz: Gereksinimler
Tüm protokollerin katı bir şekilde tanımlandığına emin olun, mesela sınır dışı davranışların basit bir şekilde tanımlandığı ve protokole sıkı bir şekilde uyumlandığı gibi.

Faz: Gereksinimler
Bu zayıflığın oluşmasına izin vermeyecek bir dil kullanın, ya da bu zayıflıktan kolay bir şekilde kaçınılabilecek yapılar oluşturun.
Mümkünse, otomatik sınır kontrolü yapan bir dil veya derleyici seçin.

Faz: Mimari ve Tasarım
Bu zafiyetin meydana gelmesine izin vermeyen veya bu zafiyetten kaçınmayı kolaylaştıracak yapılar sunan, güvenilir bir kütüphane veya framework kullanın.
Sayıları beklenmedik sonuçlara izin vermeden kullanabilen kütüphane veya frameworkler kullanın.
Örnek olarak, SafeInt(C++) veya IntegerLib(C or C++) gibi güvenli integer yönetimi kütüphaneleri projenize ekleyin.

Faz: Gerçekleme
Her bir sayısal girdide, sayının beklendik aralığın içinde olduğunu sağlayan girdi doğrulaması yapın. Girdinin beklenen aralıkta hem minimum hem de maksimum gereksinimleri karşıladığına emin olun.
Mümkün oldukça unsigned integer kullanın. Bu, tamsayı taşması için sağlama yapmayı kolaylaştırır. Eğer signed integer kullanmanız gerekliyse, aralık kontrolünün maksimum değerlerle birlikte minimum değerleri de kontrol ettiğine emin olun.

Faz: Gerçekleme
Programlama dilinizin temelini ve sayısal hesaplamalarla nasıl etkileştiğini anlayın (CWE-681). Bayt boyutu uyumsuzluklarını, hassaslığı, imzalı / imzasız ayrımları, kesimleri, türler arası dönüştürmeyi, "sayı değil" hesaplamalarını ve dilinizin çok büyük ve çok küçük sayıları temel gösterimde nasıl ele aldığını yakından kontrol edin.
Ayrıca, 32-bit, 64-bit ve sayısal gösterimi etkileyebilecek diğer potansiyel farklılıkları hesaba katmak için de dikkatli olun.

Faz: Gerçekleme
Derleyici uyarılarını yakından inceleyin ve signed / unsigned uyumsuzlukları gibi, potansiyel kritik güvenlik sorunlarını bertaraf edin. Zafiyet çok ender olarak sömürülebilir olsa da, küçük bir başarısızlık, bütün sistemi riske atabilir.</solution>
	<reference>http://projects.webappsec.org/Integer-Overflows</reference>
	<reference>http://cwe.mitre.org/data/definitions/190.html</reference>
</vuln_item_wasc_3>

<vuln_items>wasc_4</vuln_items>
<vuln_item_wasc_4>
	<alert>Yetersiz Taşıma Katmanı Koruması</alert>
	<desc>Yetersiz Taşıma Katmanı Koruması
Yetersiz Taşıma Katmanı Koruması, iletişimin güvenilir olmayan üçüncü taraflarca görülebilmesine izin vererek, web uygulamasının ele geçirilebilmesi için saldırı vektörü sağlar ve/veya hassas bilgilerin çalınmasına sebep olur. Web siteleri, genellikle taşıma katmanında şifreleme sağlamak için Güvenli Soket Katmanı / Taşıma Katmanı Güvenliği (SSL/TLS) kullanır. Buna rağmen, web sitesi SSL/TLS kullanacak ya da doğru bir şekilde kullanacak şekilde yapılandırılmadıysa, web sitesi trafik yakalama ve değiştirmeye korumasız hale gelebilir.
 
Taşıma Katmanı Şifrelemesi Eksikliği
Taşıma Katmanı şifrelenmediğinde, web sitesi ve istemci arasındaki tüm iletişim açık metin şeklinde yapılır ve bu, iletişimi yakalamaya, enjeksiyona ve yönlendirmeye açık hale getirir. (Aynı zamanda aradaki adam saldırısı olarak da bilinir). Saldırgan pasif olarak iletişimi dinleyerek, kullanıcı adı ve parola gibi hassas bilgilere erişebilir. Saldırgan aktif bir şekilde iletişime içerik enjekte ederek ya da iletişimden içerik çıkararak, zararlı yazılım enjekte edebilir ya da istemcinin güvenilir olmayan uzak içeriğe erişimine sebep olabilir. Saldırgan ayrıca iletişimi yönlendirerek websitesi ve istemcinin artık birbiriyle direk iletişim kurmamasını sağlayıp, farkında olmadan saldırganla iletişim kurmasına sebep olabilir.

Zayıf Şifreleme Desteği
Tarihte, yüksek dereceli şifreleme'nin Amerika Birleşik Devletleri dışına ihracı yasaklanmıştı. Bu yüzden, web siteleri sadece zayıf şifreleme kullanmasına izin verilen kullanıcılar için zayıf kriptografik seçenekleri destekleyecek şekilde yapılandırılmıştı. Zayıf şifreleme, kırılmaya açık olduğu için saldırıya karşı zafiyetlidir; tipik bir ev bilgisayarında iki haftadan kısa veya adanmış bir donanımda bir kaç saniyede kırılabilir.
Günümüzde, tüm modern tarayıcılar ve web siteleri çok daha güçlü şifreleme kullanmaktadır, fakat web siteleri hala modası geçmiş zayıf şifrelemeyi destekleyecek şekilde yapılandırılmışlardır. Bu sebeple, saldırgan kullanıcıyı bir websitesine bağlanırken daha zayıf bir şifreleme kullanmaya zorlayabilir, böylece saldırgan zayıf şifrelemeyi kırabilir. Bu sebeple, sunucu sadece güçlü şifreleme kabul edecek ve zayıf şifreleme kullanan müşteriye hizmet vermeyecek şekilde yapılandırılmalıdır. Buna ek olarak, bazı web siteleri, müşterisi güçlü sifreleme destekliyorken bile zayıf şifreleme seçecek şekilde yanlış yapılandırılmıştır. OWASP, SSL/TLS sorunlarını test etmek için bir rehber yayınladı ve bu rehber zayıf şifreleme desteği, yanlış yapılandırma, bazı kaynak ve araçları içermektedir.</desc>
	<solution>Faz: Gereksinimler
Hangi veri ve kaynakların şifreli bir şekilde korunacak kadar değerli olduğunu düzgün bir şekilde belirleyin. Bu veri/kaynağa herhangi bir iletişim veya depolama, iyi denetlenmiş bir şifreleme algoritması gerektirmelidir.

Faz: Mimari ve Tasarım
Tehdit modellemesi ve diğer teknikleri kullanarak, verinizin ayrı bir zafiyet veya zayıflık yoluyla ele geçirilebileceğini varsayarak, şifrelemenin nerede en etkili olacağına karar verin. Özel tutulması gereken verilerin, güvenli olmayan izinler (CWE-732) gibi zafiyetlerin kullanılmasına kazara maruz kalmadığına emin olun.

Faz: Mimari ve Tasarım
Şifrelemeyi sistem tasarımınıza düzgün bir şekilde entegre ederken aşağıdaki hususları içerdiğine ama sadece bunlara bağlı kalmadığına emin olun:
     Sistemdeki kullanıcıların özel bilgilerinin depolaması ve iletimindeki şifreleme
     Sistemin yetkisiz ifşaası veya kurcalanmasına karşı koruyacak şifreleme
Şifreleme için gerekleri ve bağlamı tanımlayın:
    Tek-yönlü (mesela, sadece kullanıcı veya alıcının anahtara sahip olması gerektiği). Bu, açık anahtar şifrelemesi veya şifreleme yapan kısmın (mesela yazılım) özel anahtara erişmesine gerek duymadığı diğer tekniklerle başarılabilir.
      İki yönlü (diğer bir deyişle, şifreleme bir kullanıcı adına otomatik olarak yapılabilir, ancak anahtar, düz metin kendisi tarafından otomatik olarak kurtarılabilir şekilde bulunmalıdır). Bu durum kişisel anahtarların, diğer kişiler yerine sadece kullanıcı tarafından (veya işletim sistemi tarafından) kurtarılabilir olduğu bir formatta saklanmasını gerekli kılar.

Faz: Mimari ve Tasarım
Kendi kriptografik algoritmanızı geliştirmeyin. Onlar, muhtemelen kriptograflar tarafından iyi anlaşılmış saldırılara maruz kalacaklar. Tersine mühendislik teknikleri olgun. Eğer algoritmanız açığa çıkar, saldırganlar nasıl çalıştığını çözerlerse, o zayıftır.

Faz: Mimari ve Tasarım
Bu alanda uzmanlarca güçlü kabul edilen, iyi onaylanmış algoritmaları ve bunların iyi test edilmiş gerçeklemelerini kullanın.
Mesela, ABD hükümet sistemleri FIPS 140-2 sertifikası gerektiriyor.
Tüm kriptografik mekanizmalarla, kaynak kodu analiz için açık bulunmalı.
Periyodik olarak, geçerliliğini yitirmiş kriptografi kullanılmadığı kontrol edilmeli. Bir zamanlar kırılması için milyarlarca hesaplama yılı gerektiği düşünülen eski algoritmalar, günümüzde bir kaç gün veya saatte kırılabilmektedir. Bunlardan MD4, MD5, SHA1, DES, ve diğer algoritmalar bir zamanlar güçlü kabul ediliyordu.

Faz: Mimari ve Tasarım
Sisteminizi sınırları tartışmasız bir şekilde çizilmiş, "güvenli" alanlar oluşturacak şekilde bölümlere ayırın. Hassas bilginin güven sınırları dışına gitmesine izin vermeyin ve güvenli alan dışındaki bir bölümle karşılaştığınızda her zaman dikkatli olun.

Faz: Gerçekleme; Mimari ve Tasarım
endüstri tarafından onaylanmış teknikler kullanırken, onları dikkatli kullanmalısınız. Yoğun kaynaklı adımları atlayarak kestirmeden gitmeyin (CWE-325). Bu adımlar, yaygın saldırıları önlemek için genellikle gereklidir.

Faz: Gerçekleme
İsimlendirme kurallarını ve güçlü tipleri, hassas bilgi kullanılırken daha kolay farkedebilmek için kullanın. Nesne, yapı ve diğer kompleks yapıları kullanırken, hassas ve hassas olmayan veriyi mümkün oldukça ayırın.
Bu, şifrelenmemiş veriyi kodda daha kolay farkedebilmenizi sağlar.</solution>
	<reference>http://projects.webappsec.org/Insufficient-Authentication</reference>
	<reference>http://cwe.mitre.org/data/definitions/287.html</reference>
</vuln_item_wasc_4>

<vuln_items>wasc_5</vuln_items>
<vuln_item_wasc_5>
	<alert>Uzaktan dosya dahili</alert>
	<desc>Uzak Dosya İçeriği (RFI), web uygulamalarında "dinamik dosya dahil etme" mekanizmalarını kullanmak için kullanılan bir saldırı tekniğidir. Web uygulamaları kullanıcı girdisini (URL, parametre değeri vs.) aldığında ve bunları komutla dosyaya aktarırken, web uygulaması zararlı kodları da eklemesi için kandırılabilir.

Neredeyse tüm internet uygulama çerçeveleri dosyaların eklenmesini desteklemektedir. Dosya dahil etme temel olarak, daha sonra ana uygulama modülleri tarafından referans gösterilecek ortak kodları ayrı dosyalar halinde paketlemek için kullanılır. Web uygulaması, dahil etme dosyasına referansta bulunduğunda, bu dosyadaki kod belirli prosedürleri çağırarak dolaylı veya dolaysız olarak çalıştırılabilir. Eğer yükleme modülü seçimi HTTP isteği öğelerine bağlıysa, web uygulaması RFI karşısında savunmasız olabilir.
Bir saldırganın RFI'yı kullanma durumları şunlardır:
    * Sunucuda zararlı yazılım çalıştırma: zararlı dosyalar içeren kodlar sunucu tarafından çalıştırılır. Dosya içerme "wrapper" kullanarak çalıştırılmamış ise, içerikteki kodlar sunucu kullanıcı bağlamında yürütülür. Bu bir tam sistem uyuşmazlığına neden olabilir.
    *İstemciler üzerinde kötü amaçlı kod kullanımı: saldırganın kullandığı zararlı kod istemciye gönderilen yanıtın içeriğini manipule edebilir. Saldırgan, müşteri tarafından yürütülecek cevap içerisinde zararlı kod gömebilir (örneğin müşterinin seans çerezini çalmak için Javascript gibi).

PHP, PHP programlamasında yaygın olarak kullanılan "dosya dahil etme" ve RFI saldırılarına olan eğilimi artırarak varsayılan sunucu konfigürasyonu nedeniyle özellikle RFI saldırıları karşısında savunmasızdır.</desc>
	<solution>Yürütülen Program: Mimarlık ve Tasarım
Dosya adları veya URL'ler gibi kabul edilebilir nesneler kümesi sınırlı veya bilinen olduğunda, sabit girdi değerlerinden (sayısal kimlikler gibi) bir kümeyle gerçek dosya adlarına veya URL'lere eşleme oluşturun ve diğer tüm girdileri reddedin.
Örneğin, ID 1 "inbox.txt"e, ID 2 ise "profile.txt"e eşlenebilir. ESAPI AccessReferenceMap/ErişimReferansHaritası gibi özellikler bunu sağlar.

Aşama: Mimarlık ve tasarım; İşlem
Kodunuzu "jail" ya da benzer, işlem ile işletim sistemi arasında kesin sınırlara zorlayan sandbox ortamında çalıştırın. Bu durum, belirli bir hedef dizin içerisinde hangi dosyalara erişileceğini veya yazılım tarafından hangi komutların uygulanacağını etkili şekilde kısıtlayabilir.
İşletim sistemi seviyesi örneklerine Unix chroot jail, AppArmor ve SeLinux da dahildir. Genel olarak, yönetilen kod bazı korumalar sağlayabilir. Örneğin, Java Güvenlik Yöneticisi içerisindeki java.io.FilePermission, dosya operasyonları üzerinde kısıtlamaları belirtmenize izin verir.
Bu pratik bir çözüm olmayabilir ve sadece işletim sistemi üzerindeki etkileri kısıtlar; uygulamaların kalanları savunmasız kalabilir.
CWE-243 ve diğer Jail alakalı zayıf noktalara karşı dikkatli olun.
PHP için yorumlayıcı, saldırgan uygulamalardan çıkmasını zorlaştıracak şekilde açık basedir veya güvenli mod gibi kısıtlamalar sunar. Aynı zamanda sertleştirilmiş PHP uzantısı olan ve bazı tehlikeli PHP özelliklerini devre dışı bırakmak için farklı seçenekler barındıran Suhosin'i de ele alın.

Aşama: Uygulama
Tüm girdilerin zararlı olduğunu kabul edelim. "Accept known good" (bilinen mal kabulü) giriş onaylama stratejisi kullanın. Spesifikasyonlara kesinlikle uyan kabul edilebilir girdilerden oluşan bir beyaz liste oluşturun. Şartlara tam olarak uymayan veya başka şeye dönüştüren girdileri reddedin. Sadece zararlı veya kusurlu girdilere güvenmeyin (örn, sadece kara listeye güvenmeyin). Yine de kara liste, olası saldırıları belirlemede veya hangi girdilerin kusurlu olduğunu ve reddedilmesi gerektiğini belirlemede faydalıdır.
Giriş doğrulamasını gerçekleştirirken, uzunluğu, girdi türünü, kabul edilebilir değerlerin tümünü, eksik veya fazla girdileri, söz dizimini, ilgili alanlardaki tutarlılık ve iş kurallarına uyum da dahil olmak üzere potansiyel olarak ilgili tüm özellikleri düşünün. İş kuralı mantığına örnek olarak "boat" yalnıza alfanumerik karakterler içerdiği için sözdizimsel olarak uygun olabilir, fakat yalnızca "mavi" ya da "kırmızı" gibi renkleri kabul ettiğiniz durumlarda geçerli değildir. Eğer uygulanabilirse, CWE-23 gibi zayıflıklardan kaçınmak için dosya isimlerinde "." gibi tek karakterlere izin verin ve CWE-36 kaçınmak için "/" gibi hedef dizin ayırıcılarından kaçının. CWE-434 kaçınmaya yardımcı olacak izin verilebilen dosya uzantıları beyaz listesi kullanın.

Fazlar: Mimari ve Tasarım; Operasyon
Mümkünse kütüphane, dahil etme ve yardımcı yazılımları web belgesi kökünün dışında tutun. Aksi durumlarda bunları ayrı bir hedef dizisinde saklayın ve saldırganların doğrudan istekte bulunmasını engellemek için web sunucusu erişim kontrolü yetenekleri kullanın. Genel bir uygulama, her çağıran programda tam bir sabit tanımlama ve daha sonra sabitin varlığını kitaplık / kapsam dosyasında kontrol etmektir; sabit yoksa, dosya direkt olarak istenir ve hemen çıkabilir.
Bu, saldırganın ana programda var olan fakat dosyalar içinde yer almayan koruma mekanizmasını aşma ihtimalini önemli ölçüde azaltır. Ayrıca saldırı yüzeyinizi de düşürecektir.

Fazlar: Mimari ve Tasarım; Uygulama
Güvenilmeyen girdilerin yazılımınıza girebileceği tüm olası alanları anlayın: Parametre ve argümanlar, çerezler, ağdan okunan her şey, ortam değişkenleri, ters DNS aramaları, arama sonuçları, istek başlıkları URL bileşenleri, e-postalar, dosyalar, veri tabanları ve uygulamaya veri sağlayan tüm harici sistemler. Unutmayın ki bunun gibi girdiler API çağrıları sayesinde dolaylı olarak elde edebilirler.
Birçok dosya dahil etme sorunu, programcının belirli girdilerin, özellikle de çerezlerin ve URL bileşenlerinin değiştirilemez olmasını düşünmesinden doğar.</solution>
	<reference>http://projects.webappsec.org/Remote-File-Inclusion</reference>
	<reference>http://cwe.mitre.org/data/definitions/98.html</reference>
</vuln_item_wasc_5>

<vuln_items>wasc_6</vuln_items>
<vuln_item_wasc_6>
	<alert>Dize Formatlama</alert>
	<desc>Dize Saldırılarını Formatlayın diğer hafıza alanlarına erişmek için dize formatlama kütüphane özelliklerini kullanarak uygulama akışını değiştirin. Belirli C/C++ fonksiyonları için (örn, fprintf, printf, sprintf, setproctitle, syslog, ...) kullanıcının sağladığı veri doğrudan formatlama dizesi girişi olarak kullanılırsa, savunmasızlıklar ortaya çıkar.

Eğer bir saldırgan printf çevirim karakterlerinden oluşan format dizisini aşmayı başarırsa, 
* Sunucuda rastgele kod yürütme
* Yığın değerlerini okuma
* Segment hataları / Yazılım çöküşlerine neden olabilirler. 

Format dizisi saldırıları diğer saldırı kategorisindedir : arabellek taşması ve tam sayı taşması. Her üçü de, bir saldırganın amacına katkıda bulunacak şekilde hafızayı veya yorumunu manipüle etme kabiliyetine dayanıyor.</desc>
	<solution>Aşama Gereksinimleri
Bu kusura sahip olmayan bir dil seçin.

Aşama: Uygulama
Tüm format dize işlevlerinin kullanıcı tarafından denetlenemeyen statik bir dize geçirildiğinden ve doğru sayıda argüman daima bu işleve gönderildiğinden emin olun. Mümkünse, biçim dizgelerinde %n operatörünü desteklemeyen işlevleri kullanın.
Yapı: Derleyicilerin ve bağlayıcıların uyarılarına dikkat edin çünkü uygun olmayan kullanım konusunda uyarabilirler.
</solution>
	<reference>http://projects.webappsec.org/Format-String</reference>
	<reference>http://cwe.mitre.org/data/definitions/134.html</reference>
</vuln_item_wasc_6>

<vuln_items>wasc_7</vuln_items>
<vuln_item_wasc_7>
	<alert>Arabellek Taşması</alert>
	<desc>Arabellek Taşması, bir bellek bloğuna veya arabelleğe yazılınca, arabellek tutmak için ayrıldığı zamandan daha fazla veri yazıldığında oluşan bir kusurdur.
 Bir arabellek taşmasından faydalanmak, saldırganın hedef işlemin adres alanının bölümlerini değiştirmesine imkan sağlar. Bu beceri, aşağıdakileri de içeren bir dizi amaçla kullanılabilir:
    * Sürecin yürütülmesini kontrol etme
    * Süreci çökertme
    * İç değişkenleri değiştirme
Saldırganın hedefi neredeyse her zaman hedef işlemin yürütülmesini kontrol etmektir. Bu, taşmayı kullanarak, doğrudan ya da dolaylı olarak hafızada düzenlenebilir bir işlev işaretçisi belirleyerek gerçekleştirilebilir. Böyle bir işaretçi, programın bir atlama veya çağrı talimatı yoluyla yönlendirilmesini sağlamak için program tarafından kullanılırsa, saldırgan tarafından verilen yönerge konumu kullanılır ve böylece saldırganın süreci kontrol etmesine izin verilir.

Çoğu durumda, fonksiyon işaretçisi, saldırganın makineye özel talimatlar yerleştirdiği konuma başvuracak şekilde değiştirilir. Bu talimatlara genellikle kabuk kodları denir; saldırganların çoğu zaman, çalışan işlemler bağlamında komut satırı ortamlarını veya kabuklarını ortaya çıkarmak istediklerine işaret eder.

Arabellek taşmaları, yaygın programlama yapılarıyla doğrudan bellek manipülasyonunu gerçekleştirme ve yaygın kullanımları nedeniyle C ve C ++ programlama dillerinde yazılan yazılımlarla ilişkilidir. Bununla birlikte, arabellek taşmaları doğrudan bellek işlemesine izin verilen herhangi bir programlama ortamında, uygulama kusurları, çalışma zamanı kitaplıkları veya dilin kendisinin özellikleri aracılığıyla olup olmadığı vurgulanmalıdır.
</desc>
	<solution>Faz: Gereksinimler
Bu zayıflığın oluşmasına izin vermeyecek bir dil kullanın, ya da bu zayıflıktan kolay bir şekilde kaçınılabilecek yapılar oluşturun.
Örneğin, Java ve Perl gibi kendi bellek yönetimini gerçekleştiren birçok dil arabellek taşmasına tabi değildir. Ada ve C # gibi diğer diller genellikle taşma koruması sağlar, ancak koruma programcı tarafından devre dışı bırakılabilir.
Dilin teorik olarak güvenli olmasına rağmen, bir dilin yerel kodu arayüzünün hala taşmalara maruz kalabileceğine dikkat edin.

Faz: Mimari ve Tasarım
Bu zafiyetin meydana gelmesine izin vermeyen veya bu zafiyetten kaçınmayı kolaylaştıracak yapılar sunan, güvenilir bir kütüphane veya framework kullanın.
Örnekler arasında Messier ve Viega'nın Safe C String Library (SafeStr) ve Microsoft'un Strsafe.h library bulunmaktadır. Bu kitaplıklar, taşmaya eğilimli dize işleme işlevlerinin daha güvenli sürümlerini sağlar. Çoğu arabellek taşması dizelerle ilgili olmadığından, bu tam bir çözüm değildir.

Aşama: Derleme ve Derleme
Yazılımınızı, arabellek taşmalarını azaltan veya ortadan kaldıran bir koruma mekanizması otomatik olarak sağlayan özellikler veya uzantılar kullanarak çalıştırın veya derleyin.
Örneğin, bazı derleyiciler ve uzantılar, derlenmiş kodun içine yerleştirilmiş otomatik arabellek taşması algılama mekanizmaları sağlar. Örnekler arasında Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY SOURCE GCC flag, StackGuard, ve ProPolice bulunur.

Aşama: Uygulama
Bir uygulamanın belleğini tahsis ederken ve yönetirken aşağıdaki kurallara uymayı düşünün:
       Arabellekinizin belirttiğiniz kadar büyük olup olmadığını iki kez kontrol edin.
      Kopyalamak için strncpy () gibi bir dizi bayt kabul eden işlevler kullanırken, hedef arabellek boyutu kaynak arabellek boyutuna eşitse dizgeyi NULL olarak sonlandırmayabileceğini unutmayın.
      Bu işlevi bir döngüde ararsa arabellek sınırlarını kontrol edin ve ayrılan alanı geçme tehlikesi altında olmadığınızdan emin olun.
      Gerekirse, kopyalama ve birleştirme işlevlerine geçirmeden önce tüm giriş dizelerini makul bir uzunlukta kesin.

Aşama: Operasyon
Adres Alanı Yerleşimi Rastgele seçimi gibi bir özellik kullanın.

Aşama: Operasyon

Veri Yürütme Koruması (NX) veya bunun eşdeğeri sunan bir CPU ve işletim sistemi kullanın.

Aşama: Uygulama

Sınırsız kopyalama işlevlerini, strnpy ile strcpy gibi uzunluk bağımsız değişkenlerini destekleyen benzer işlevlerle değiştirin. Mevcut değilse oluşturun.
</solution>
	<reference>http://projects.webappsec.org/Buffer-Overflow</reference>
	<reference>http://cwe.mitre.org/data/definitions/119.html</reference>
</vuln_item_wasc_7>

<vuln_items>wasc_8</vuln_items>
<vuln_item_wasc_8>
	<alert>Siteler Arası Komut Çalıştırma</alert>
	<desc>Siteler Arası Komut Dosyası Çalıştırma (XSS), saldırgan tarafından sağlanan kodu bir kullanıcının tarayıcı örneğine yansıtan bir saldırı tekniğidir. Bir tarayıcı örneği, standart bir web tarayıcı istemcisidir veya WinAmp içindeki tarayıcı, bir RSS okuyucu veya bir e-posta istemcisi gibi bir yazılım ürününe yerleştirilmiş bir tarayıcı nesnesi olabilir. Kodun kendisi genellikle HTML / JavaScript ile yazılmıştır, ancak VBScript, ActiveX, Java, Flash veya diğer herhangi bir tarayıcı destekli teknolojiyi de içerebilir.
Bir saldırgan kodu çalıştırmak için bir kullanıcının tarayıcısını aldığında, kod barındırma web sitesinin güvenlik bağlamında (veya bölge) çalışacaktır. Bu ayrıcalık seviyesiyle, kod, tarayıcı tarafından erişilebilen hassas verileri okuma, değiştirme ve iletme becerisine sahiptir. Siteler Arası Komutlu bir kullanıcı, hesabını ele geçirmesine (çerez hırsızlığı), tarayıcılarının başka bir konuma yönlendirilmesine veya ziyaret ettiği web sitesinde yayınlanan hileli içeriğin muhtemelen gösterilebilmesine neden olabilir. Siteler Arası Komut Dosyası saldırısı, bir kullanıcı ve web sitesi arasındaki güven ilişkisini esasen tehlikeye atmaktadır. Dosya sisteminden içerik yükleyen tarayıcı nesnesi örneklerini kullanan uygulamalar, sistemin güvenliğini sağlamak için yerel makine bölgesi altında kod yürütebilir.

Siteler arası komut dosyası çalıştırma saldırılarının üç türü vardır: kalıcı olmayan, kalıcı ve DOM tabanlı.
Daimi olmayan saldırılar ve DOM tabanlı saldırılar, bir kullanıcının ya kötü amaçlı kod ile bağlanmış özel hazırlanmış bir bağlantıyı ziyaret etmesini ya da korumasız siteye gönderildiğinde saldırıyı yükleyeceği bir web formu içeren kötü amaçlı bir web sayfasını ziyaret etmesini gerektirir. Kötü amaçlı bir formu kullanarak güvenlik açığı bulunan kaynak yalnızca HTTP POST istekleri kabul ettiğinde çoğu kez yer alacak. Böyle bir durumda, form otomatik olarak, mağdur farkında olmadan gönderilebilir (örneğin, JavaScript'i kullanarak). Kötü niyetli linke tıklayarak veya kötü amaçlı formu göndererek, XSS yükü geri yankılanır ve kullanıcının tarayıcısı tarafından yorumlanır ve yürütülür. Rastgele istekler (GET ve POST) göndermenin bir başka tekniği Adobe Flash gibi katılaştırılmış bir istemci kullanmaktır.
Kalıcı saldırılar, kötü niyetli kod belirli bir süre saklanan bir web sitesine gönderildiğinde ortaya çıkar. Bir saldırganın favori hedeflerine örnek olarak mesaj panosu mesajları, web posta mesajları ve web sohbet yazılımı dahildir. Masum olmayan kullanıcının herhangi bir ek site / bağlantıyla (örneğin, bir virüslü site veya e-posta ile gönderilen kötü amaçlı bir bağlantı) etkileşime girmesi gerekmez; yalnızca kodu içeren web sayfasını görüntülemek yeterlidir.</desc>
	<solution>Faz: Mimari ve Tasarım
Bu zafiyetin meydana gelmesine izin vermeyen veya bu zafiyetten kaçınmayı kolaylaştıracak yapılar sunan, güvenilir bir kütüphane veya framework kullanın.
Doğru kodlanmış çıktı üretmeyi kolaylaştıran kütüphaneler ve çerçeveler örnekleri arasında şunlar bulunmaktadır: Microsoft'un Anti-XSS kitaplığı, OWASP ESAPI Kodlama modülü ve Apache Wicket.

Aşamalar: Uygulama; Mimarlık ve Tasarım
Verilerinizin kullanılacağı içeriği ve beklenen kodlamayı öğrenin. Bu, farklı bileşenler arasında veri iletirken veya web sayfaları veya çok parçalı e-posta iletileri gibi aynı anda birden fazla kodlama içerebilecek çıktılar üretirken özellikle önem taşır. Gerekli kodlama stratejilerini belirlemek için beklenen tüm iletişim protokollerini ve veri sunumlarını incele.
For any data that will be output to another web page, especially any data that was received from external inputs, use the appropriate encoding on all non-alphanumeric characters.
Gerekli kodlama ve kaçış türleri hakkında daha fazla bilgi için XSS(Siteler Arası Betik Çalıştırma) Önleme Hile Sayfasına bakın.

Aşama: Mimarlık ve Tasarım
İstemci tarafında gerçekleştirilen güvenlik kontrolleri için ve CWE-602'den kaçınmak için bu kontrollerin sunucu tarafında çoğaltılmasını sağlayın. Saldırganlar, denetimler gerçekleştirildikten sonra değerleri değiştirerek veya istemci tarafı denetimlerini tamamen kaldırmak için istemciyi değiştirerek istemci tarafı denetimleri atlayabilir. Ardından, bu değiştirilen değerler sunucuya gönderilir.

Varsa, veri ile kod arasındaki ayrımı otomatik olarak uygulayan yapısal mekanizmalar kullanın. Bu mekanizmalar, üreticinin ürettiği her çıkış alanı için bu özellikleri elde etmek için geliştiriciye güvenmek yerine, otomatik olarak doğru tanıtımı, kodlamayı ve doğrulamayı sağlayabilir.

Aşama: Uygulama
Oluşturulan her türlü web sayfası için ISO-8859-1 veya UTF-8 gibi bir karakter kodlaması kullanmayı ve belirtmeyi unutmayın. Hiçbir kodlama belirtilmediğinde, web tarayıcısı hangi kodlamanın web sayfası tarafından fiilen kullanıldığını tahmin ederek farklı bir kodlama seçebilir. Bu, web tarayıcısının belirli dizileri özel olarak ele almasına ve istemcinin gizli XSS saldırılarına açmasına neden olabilir. CWE-116 için kodlama/kaçan için ilgili daha fazla Azaltıcı Etkenler bölümüne bakın.

Kullanıcının oturum tanımlama bilgisine karşı XSS saldırılarını hafifletmeye yardımcı olmak için oturum tanımlama bilgisini HttpOnly olarak ayarlayın. HttpOnly özelliğini (Internet Explorer ve Firefox'un daha yeni sürümleri gibi) destekleyen tarayıcılarda bu özellik, kullanıcının oturum tanımlama bilgisini, document.cookie kullanan kötü amaçlı kullanıcı tarafından komut dosyalarından erişilmesini engelleyebilir. HttpOnly tüm tarayıcılar tarafından desteklenmediği için bu tam bir çözüm değildir. Daha da önemlisi, XMLHTTP İsteği ve diğer güçlü tarayıcı teknolojileri, HttpOnly bayrağının ayarlandığı Set-Cookie başlığı da dahil olmak üzere HTTP üstbilgilerine okuma erişimi sağlar.

Tüm girdilerin zararlı olduğunu varsay. "Accept known good" (bilinen mal kabulü) giriş onaylama stratejisi kullanın. Spesifikasyonlara kesinlikle uyan kabul edilebilir girdilerden oluşan bir beyaz liste oluşturun. Spesifikasyonlara kesinlikle uymayan girdileri reddedin veya bunu yapan bir şey haline getirin. Sadece zararlı veya kusurlu girdilere güvenmeyin (örn, sadece kara listeye güvenmeyin). Bununla birlikte, kara listeler potansiyel saldırıları tespit etmek veya hangi girdilerin yanlış olduğunu belirlemek için faydalı olabilirler.

Giriş doğrulamasını gerçekleştirirken, uzunluğu, girdi türünü, kabul edilebilir değerlerin tümünü, eksik veya fazla girdileri, söz dizimini, ilgili alanlardaki tutarlılık ve iş kurallarına uyum da dahil olmak üzere potansiyel olarak ilgili tüm özellikleri düşünün. Bir iş kuralı mantığına örneği olarak "tekne", yalnızca alfasayısal karakterler içerdiği için sözdizimsel olarak geçerli olabilir, ancak "kırmızı" veya "mavi" gibi renklerin olması bekleniyorsa geçerli değildir.

Giriş doğrulamasının, uygulama içinde açıkça tanımlanmış arabirimler üzerinde gerçekleştirildiğinden emin olun. This will help protect the application even if a component is reused or moved elsewhere.
	</solution>
	<reference>http://projects.webappsec.org/Cross-Site-Scripting</reference>
	<reference>http://cwe.mitre.org/data/definitions/79.html</reference>
</vuln_item_wasc_8>

<vuln_items>wasc_9</vuln_items>
<vuln_item_wasc_9>
	<alert>Siteler Arası İstek Taklidi</alert>
	<desc>A cross-site request forgery is an attack that involves forcing a victim to send an HTTP request to a target destination without their knowledge or intent in order to perform an action as the victim. Altındaki sebep, tahmin edilebilir URL/form eylemlerini tekrarlanabilir bir şekilde kullanan uygulama fonksiyonlarıdır. Saldırının yapısı, CSRF'in bir web sitenin bir kullanıcıya olan güvenini kullanmasıdır. Buna karşılık, siteler arası komut dosyası (XSS), bir kullanıcının bir web sitesi için sahip olduğu güveni kullanır. XSS gibi CSRF saldırıları siteler arası bağlantı oluşturmaz, ancak bunlar olabilir. Siteler arası istek talebinde bulunma, CSRF, XSRF, tek tıklamayla saldırı, oturumda gezinme, şaşkın vekil ve deniz sörfü olarak da bilinir.

CSRF saldırıları, aşağıdakiler de dahil olmak üzere birçok durumda etkilidir:
     * Mağdur hedef sitede aktif bir oturuma sahiptir.
    Kurbanın kimliği HTTP doğrulama aracılığı ile hedef sitede doğrulanır.
    * Kurban, hedef site ile aynı yerel ağ üzerindedir.

CSRF öncelikle mağdurun imtiyazlarını kullanarak bir hedef siteye karşı bir eylem gerçekleştirmek için kullanılmıştır, ancak cevaba erişerek bilgi ifşa etmek için yeni teknikler keşfedilmiştir. Hedef site XSS'ye karşı savunmasız olduğunda bilgi ifşa riski önemli ölçüde artar, çünkü XSS, CSRF için bir platform olarak kullanılabilir ve saldırının aynı menşei politikasının sınırları içinde çalışmasına izin verir.</desc>
	<solution>Faz: Mimari ve Tasarım
Bu zafiyetin meydana gelmesine izin vermeyen veya bu zafiyetten kaçınmayı kolaylaştıracak yapılar sunan, güvenilir bir kütüphane veya framework kullanın.
Örneğin, OWASP CSRFGuard gibi anti-CSRF paketlerini kullanın.

Aşama: Uygulama
Çoğu CSRF savunması, saldırgan tarafından kontrol edilen komut dosyasını kullanarak atlanabilir olduğundan, uygulamanızın siteler arası komut dosyası oluşturma sorunlarından uzak olmasını çalışın.

Aşama: Mimarlık ve Tasarım
Her bir form için benzersiz bir nonce oluşturulur, nonce'ı forma yerleştirin ve formu aldıktan sonra onaylayın. Tek kullanımlık anahtarın tahmin edilebilir olmadığından emin olun (CWE-330).
Bunun, XSS'yi kullanarak atlanabileceğini unutmayın.

Özellikle tehlikeli işlemleri belirleyin. Kullanıcı tehlikeli bir işlem yaparsa, kullanıcının bu işlemi gerçekleştirmesini istediğinden emin olmak için ayrı bir onay isteği gönderin.
Bunu XSS kullanarak atlatabileceğinizi unutmayın.

ESAPI Oturum Yöneticisi kontrolünü kullan.
Bu kontrol CSRF için bir bileşen içerir.

Durum değişikliğini tetikleyen herhangi bir istek için GET yöntemini kullanmayın.

Aşama: Uygulama
İsteğin beklenen bir sayfadan kaynaklanıp kaynaklanmadığını görmek için HTTP Referer başlığını kontrol edin. This could break legitimate functionality, because users or proxies may have disabled sending the Referer for privacy reasons.</solution>
	<reference>http://projects.webappsec.org/Cross-Site-Request-Forgery</reference>
	<reference>http://cwe.mitre.org/data/definitions/352.html</reference>
</vuln_item_wasc_9>

<vuln_items>wasc_10</vuln_items>
<vuln_item_wasc_10>
	<alert>Hizmet reddedildi</alert>
	<desc>Denial of Service (DoS) is an attack technique with the intent of preventing a web site from serving normal user activity. DoS attacks, which are easily normally applied to the network layer, are also possible at the application layer. These malicious attacks can succeed by starving a system of critical resources, vulnerability exploit, or abuse of functionality.

Many times DoS attacks will attempt to consume all of a web site's available system resources such as: CPU, memory, disk space etc. Bu kritik kaynaklardan herhangi biri tam kullanıma ulaştığında, web sitesi normal olarak erişilemez olacaktır.

As today's web application environments include a web server, database server and an authentication server, DoS at the application layer may target each of these independent components. Unlike DoS at the network layer, where a large number of connection attempts are required, DoS at the application layer is a much simpler task to perform.</desc>
	<solution>Aşama: Mimarlık ve Tasarım
Sistem mimarisinden kısma mekanizma tasarlayın. En iyi koruma, yetkisiz bir kullanıcının harcanmasına neden olabilecek kaynakların miktarını sınırlamaktır. Güçlü bir kimlik doğrulama ve erişim denetimi modeli, bu tür saldırıların önünün açılmasını önlemeye yardımcı olur. Giriş uygulaması DoS saldırılarına karşı mümkün olduğunca korunmalıdır. Limiting the database access, perhaps by caching result sets, can help minimize the resources expended. To further limit the potential for a DoS attack, consider tracking the rate of requests received from users and blocking requests that exceed a defined rate threshold.

Mitigation of resource exhaustion attacks requires that the target system either:
      recognizes the attack and denies that user further access for a given amount of time, or
      uniformly throttles all requests in order to make it more difficult to consume resources more quickly than they can again be freed. 

The first of these solutions is an issue in itself though, since it may allow attackers to prevent the use of the system by a particular valid user. Saldırgan geçerli kullanıcıyı taklit ederse, kullanıcının söz konusu sunucudan erişmesini önleyebilir.

The second solution is simply difficult to effectively institute -- and even when properly done, it does not provide a full solution. It simply makes the attack require more resources on the part of the attacker.

Ensure that protocols have specific limits of scale placed on them.

Phase: Implementation
Ensure that all failures in resource allocation place the system into a safe posture.</solution>
	<reference>http://projects.webappsec.org/Denial-of-Service</reference>
	<reference>http://cwe.mitre.org/data/definitions/400.html</reference>
</vuln_item_wasc_10>

<vuln_items>wasc_11a</vuln_items>
<vuln_item_wasc_11a>
	<alert>Giriş Bilgilerini zorlama</alert>
	<desc>Bir kaba kuvvet saldırısı, bilinmeyen bir değerin çok sayıdaki olası değerleri deneyen otomatik bir işlem kullanılarak belirlenmesidir. The attack takes advantage of the fact that the entropy of the values is smaller than perceived. Örneğin, 8 karakterli alfasayısal şifre 2,8 trilyon olası değer içerebilirken, birçok kişi şifrelerini ortak sözcükler ve terimlerden oluşan çok daha küçük bir alt gruptan seçecektir.

Web uygulamalarındaki en yaygın kaba kuvvet saldırısı tipi, giriş bilgilerine karşı yapılan saldırıdır. Since users need to remember passwords, they often select easy to memorize words or phrases as passwords, making a brute force attack using a dictionary useful. Such an attack attempting to log-in to a system using a large list of words and phrases as potential passwords is often called a "word list attack" or a "dictionary attack". Girilen şifreler, "o" nun "0" ve "i" nin "1" ile değiştirilmesiyle üretilenler gibi, ayrıca aile üyelerinin adları, doğum tarihleri ve telefon numaraları da dahil olmak üzere kişisel bilgiler gibi şifrelere özgü sözcük varyasyonlarını içerebilir.
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Brute-Force</reference>
	<reference>TBA</reference>
</vuln_item_wasc_11a>

<vuln_items>wasc_11b</vuln_items>
<vuln_item_wasc_11b>
	<alert>Oturum tanımlayıcılarını zorlama</alert>
	<desc>Bir kaba kuvvet saldırısı, bilinmeyen bir değerin çok sayıdaki olası değerleri deneyen otomatik bir işlem kullanılarak belirlenmesidir. Saldırı, entropi değerlerinin algılanandan daha küçük olduğu gerçeğinden faydalanır. Örneğin, 8 karakterli alfasayısal şifre 2,8 trilyon olası değer içerebilirken, birçok kişi şifrelerini ortak sözcükler ve terimlerden oluşan çok daha küçük bir alt gruptan seçecektir.

Since HTTP is a stateless protocol, in order to maintain state web applications need to ensure that a session identifier is sent by the browser with each request. Oturum tanımlayıcısı en sık HTTP çerezinde veya URL'de depolanmaktadır. Kaba kuvvet saldırısı kullanarak, bir saldırgan başka bir kullanıcının oturum tanımlayıcısını tahmin edebilir. This can lead to the attacker impersonating the user, retrieving personal information and performing actions on behalf of the user.
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Brute-Force</reference>
	<reference>TBA</reference>
</vuln_item_wasc_11b>

<vuln_items>wasc_11c</vuln_items>
<vuln_item_wasc_11c>
	<alert>Kaba Kuvvet Dizinleri ve Dosyaları</alert>
	<desc>Bir kaba kuvvet saldırısı, bilinmeyen bir değerin çok sayıdaki olası değerleri deneyen otomatik bir işlem kullanılarak belirlenmesidir. Saldırı, entropi değerlerinin algılanandan daha küçük olduğu gerçeğinden faydalanır. Örneğin, 8 karakterli alfasayısal şifre 2,8 trilyon olası değer içerebilirken, birçok kişi şifrelerini ortak sözcükler ve terimlerden oluşan çok daha küçük bir alt gruptan seçecektir.

Dosyalar herhangi bir yerle bağlantılı değilse ve web sunucusu tarafından sağlanan dizinlerde bulunuyorsa, bu dosyalara erişmek, onların dosya adlarını bilmeyi gerektirir. In some cases those files have been left by mistake: for example a backup file automatically created when editing a file or leftovers from an older version of the web application. In other cases files are intentionally left unlinked as a "security by obscurity" mechanism allowing only people who know the file names to access them.

Bir kaba kuvvet saldırısı, bağlantısız dosyayı çok sayıda dosyaya erişmeye çalışarak bulmayı dener. The list of attempted file names might be taken from a list of known potential files or based on variants of the visible files on the web site. More information on brute forcing directories and files can be found in the associated vulnerability, predictable resource location.
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Brute-Force</reference>
	<reference>TBA</reference>
</vuln_item_wasc_11c>

<vuln_items>wasc_11d</vuln_items>
<vuln_item_wasc_11d>
	<alert>Brute Forcing Credit Card Information</alert>
	<desc>Bir kaba kuvvet saldırısı, bilinmeyen bir değerin çok sayıdaki olası değerleri deneyen otomatik bir işlem kullanılarak belirlenmesidir. The attack takes advantage of the fact that the entropy of the values is smaller than perceived. Örneğin, 8 karakterli alfasayısal şifre 2,8 trilyon olası değer içerebilirken, birçok kişi şifrelerini ortak sözcükler ve terimlerden oluşan çok daha küçük bir alt gruptan seçecektir.

Shopping online with stolen credit cards usually requires information in addition to the credit card number, most often the CVV/SCS and/or expiration date. A fraudster may hold a stolen credit card number without the additional information. For example the CVV/CSC is not imprinted on the card or stored on the magnetic stripe so it cannot be collected by mechanical or magnetic credit card swiping devices.

Eksik bilgileri doldurmak için, bilgisayar korsanı kayıp bilgileri mümkün olan tüm değerleri deneyerek şiddetli teknikler kullanarak tahmin edebilir.
    * Guessing CVV/CSC requires only 1000 or 10000 attempts as the number is only 3 or 4 digits, depending on the card type.
    * Guessing an expiration date requires only several dozen attempts.
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Brute-Force</reference>
	<reference>TBA</reference>
</vuln_item_wasc_11d>

<vuln_items>wasc_12</vuln_items>
<vuln_item_wasc_12>
	<alert>İçerik sızdırma</alert>
	<desc>Content Spoofing is an attack technique that allows an attacker to inject a malicious payload that is later misrepresented as legitimate content of a web application.
 
Text Only Content Spoofing
A common approach to dynamically build pages involves passing the body or portions thereof into the page via a query string value. Bu yaklaşım hata sayfalarında veya hikaye ya da haber gönderileri sağlayan sitelerde sıktır. The content specified in this parameter is later reflected into the page to provide the content for the page.
 
Markup Reflected Content Spoofing
Some web pages are served using dynamically built HTML content sources. For example, the source location of a frame <frame src="http://foo.example/file.html"/>) could be specified by a URL parameter value. (http://foo.example/page?frame_src=http://foo.example/file.html). An attacker may be able to replace the "frame_src" parameter value with "frame_src=http://attacker.example/spoof.html". Unlike redirectors, when the resulting web page is served the browser location bar visibly remains under the user expected domain (foo.example), but the foreign data (attacker.example) is shrouded by legitimate content.

Specially crafted links can be sent to a user via e-mail, instant messages, left on bulletin board postings, or forced upon users by a Cross-site Scripting attack. If an attacker gets a user to visit a web page designated by their malicious URL, the user will believe he is viewing authentic content from one location when he is not. Users will implicitly trust the spoofed content since the browser location bar displays http://foo.example, when in fact the underlying HTML frame is referencing http://attacker.example.

This attack exploits the trust relationship established between the user and the web site. The technique has been used to create fake web pages including login forms, defacements, false press releases, etc.
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Content-Spoofing</reference>
	<reference>TBA</reference>
</vuln_item_wasc_12>

<vuln_items>wasc_13</vuln_items>
<vuln_item_wasc_13>
	<alert>Bilgi sızıntısı</alert>
	<desc>Information Leakage is an application weakness where an application reveals sensitive data, such as technical details of the web application, environment, or user-specific data. Sensitive data may be used by an attacker to exploit the target web application, its hosting network, or its users. Bu nedenle, hassas veri sızıntısı mümkün olduğunca sınırlandırılmalı veya engellenmelidir. Information Leakage, in its most common form, is the result of one or more of the following conditions: A failure to scrub out HTML/Script comments containing sensitive information, improper application or server configurations, or differences in page responses for valid versus invalid data.

HTML/Komut açıklamalarını üretim ortamına itmeden önce temizleme hatası,, SQL sorgu yapısı ve dahili ağ bilgileri, hassas, bağlamsal, sunucu dizini yapısı gibi bilgilerin sızmasına neden olabilir. Often a developer will leave comments within the HTML and/or script code to help facilitate the debugging or integration process during the pre-production phase. Although there is no harm in allowing developers to include inline comments within the content they develop, these comments should all be removed prior to the content's public release.

Software version numbers and verbose error messages (such as ASP.NET version numbers) are examples of improper server configurations. This information is useful to an attacker by providing detailed insight as to the framework, languages, or pre-built functions being utilized by a web application. Most default server configurations provide software version numbers and verbose error messages for debugging and troubleshooting purposes. Configuration changes can be made to disable these features, preventing the display of this information.

Pages that provide different responses based on the validity of the data can also lead to Information Leakage; specifically when data deemed confidential is being revealed as a result of the web application's design. Hassas veri örnekleri, (ancak bunlarla sınırlı değildir.) hesap numaraları, kullanıcı tanımlayıcıları (Sürücü lisans numarası, Pasaport numarası, Sosyal Güvenlik Numaraları, vb.) ve kullanıcıya özgü bilgiler (şifreler, oturumlar, adresler) i içerir. Information Leakage in this context deals with exposure of key user data deemed confidential, or secret, that should not be exposed in plain view, even to the user. Credit card numbers and other heavily regulated information are prime examples of user data that needs to be further protected from exposure or leakage even with proper encryption and access controls already in place.</desc>
	<solution>Compartmentalize your system to have "safe" areas where trust boundaries can be unambiguously drawn. Hassas bilginin güven sınırları dışına gitmesine izin vermeyin ve güvenli alan dışındaki bir bölümle karşılaştığınızda her zaman dikkatli olun.</solution>
	<reference>http://projects.webappsec.org/Information-Leakage</reference>
	<reference>http://cwe.mitre.org/data/definitions/200.html</reference>
</vuln_item_wasc_13>

<vuln_items>wasc_14</vuln_items>
<vuln_item_wasc_14>
	<alert>Yanlış sunucu yapılandırması</alert>
	<desc>Server Misconfiguration attacks exploit configuration weaknesses found in web servers and application servers. Many servers come with unnecessary default and sample files, including applications, configuration files, scripts, and web pages. They may also have unnecessary services enabled, such as content management and remote administration functionality. Debugging functions may be enabled or administrative functions may be accessible to anonymous users. These features may provide a means for a hacker to bypass authentication methods and gain access to sensitive information, perhaps with elevated privileges.

Sunucular, herkesçe bilinen hesapları ve parolaları içerebilir. Failure to fully lock down or harden the server may leave improperly set file and directory permissions. Misconfigured SSL certificates and encryption settings, the use of default certificates, and improper authentication implementation with external systems may compromise the confidentiality of information.

Ayrıntılı ve bilgilendirici hata mesajları veri sızıntılarına neden olabilir ve ortaya çıkan bu bilgiler bir sonraki saldırının formüle edilmesi için kullanılabilir. Incorrect configurations in the server software may permit directory indexing and path traversal attacks.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Server-Misconfiguration</reference>
	<reference></reference>
</vuln_item_wasc_14>

<vuln_items>wasc_15</vuln_items>
<vuln_item_wasc_15>
	<alert>Uygulama yanlış yapılandırması</alert>
	<desc>Application Misconfiguration attacks exploit configuration weaknesses found in web applications. Many applications come with unnecessary and unsafe features, such as debug and QA features, enabled by default. These features may provide a means for a hacker to bypass authentication methods and gain access to sensitive information, perhaps with elevated privileges.

Likewise, default installations may include well-known usernames and passwords, hard-coded backdoor accounts, special access mechanisms, and incorrect permissions set for files accessible through web servers. Varsayılan örnekler, üretim ortamlarında erişilebilir olmalıdır. Application-based configuration files that are not properly locked down may reveal clear text connection strings to the database, and default settings in configuration files may not have been set with security in mind. All of these misconfigurations may lead to unauthorized access to sensitive information.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Application-Misconfiguration</reference>
	<reference></reference>
</vuln_item_wasc_15>

<vuln_items>wasc_16</vuln_items>
<vuln_item_wasc_16>
	<alert>Dizin dizini oluşturma</alert>
	<desc>Eğer Normal taban dosyası ise (index.html/home.html/default.htm/default.asp/default.aspx/index.php) otomatik dizin listesi/dizin oluşturma, tüm dosyaları istenen bir dizinde listeleyen bir web sunucusu işlevidir. When a user requests the main page of a web site, they normally type in a URL such as: http://www.example.com/directory1/ - using the domain name and excluding a specific file. The web server processes this request and searches the document root directory for the default file name and sends this page to the client. Bu sayfa mevcut değilse, web sunucusu dinamik olarak bir dizin listesi çıkarır ve çıktıyı istemciye gönderir. Essentially, this is equivalent to issuing an "ls" (Unix) or "dir" (Windows) command within this directory and showing the results in HTML form. Saldırı ve güvenlik açısından bakıldığında, istenmeyen dizin listelerinin belirli bir web isteğiyle birlikte kullanılan yazılım güvenlik açıkları (aşağıda örnek bölümünde tartışıldı) nedeniyle olabileceğini fark etmek önemlidir.</desc>
	<solution>Recommendations include restricting access to important directories or files by adopting a need to know requirement for both the document and server root, and turning off features such as Automatic Directory Listings that could expose private files and provide information that could be utilized by an attacker when formulating or conducting an attack.</solution>
	<reference>http://projects.webappsec.org/Directory-Indexing</reference>
	<reference>http://cwe.mitre.org/data/definitions/548.html</reference>
</vuln_item_wasc_16>

<vuln_items>wasc_17</vuln_items>
<vuln_item_wasc_17>
	<alert>Yanlış dosya sistem izinleri</alert>
	<desc>Yanlış dosya sistemi izinleri, bir web uygulamasının gizliliği, bütünlüğü ve kullanılabilirliği için bir tehdittir. Yanlış dosya sistemi izinleri dosyalar, klasörler ve simgesel bağlantılar üzerinde ayarlandığında sorun çıkar. Yanlış izinler ayarlandığında, bir saldırgan kısıtlanmış dosyalara veya dizinlere erişebilir ve içeriğini değiştirebilir veya silebilir. Örneğin, anonim bir kullanıcı hesabı bir dosyaya yazma iznine sahipse, bir saldırgan web uygulamasını etkileyen dosyanın içeriğini istenmeyen yollarla değiştirebilir. An attacker may also exploit improper symlinks to escalate their privileges and/or access unauthorized files; for example, a symlink that points to a directory outside of the web root.</desc>
	<solution>Very carefully manage the setting, management and handling of permissions. Explicitly manage trust zones in the software.</solution>
	<reference>http://projects.webappsec.org/Improper-Filesystem-Permissions</reference>
	<reference>http://cwe.mitre.org/data/definitions/280.html</reference>
</vuln_item_wasc_17>

<vuln_items>wasc_18</vuln_items>
<vuln_item_wasc_18>
	<alert>Credential and Session Prediction</alert>
	<desc>Credential/Session Prediction is a method of hijacking or impersonating a web site user. Deducing or guessing the unique value that identifies a particular session or user accomplishes the attack. Also known as Session Hijacking, the consequences could allow attackers the ability to issue web site requests with the compromised user's privileges.

Birçok web sitesi, iletişim ilk kurulduğunda bir kullanıcıyı kimliklendirmek ve takip etmek üzere tasarlanmıştır. Bunu yapmak için, kullanıcı genelde kullanıcı adı / şifre (kimlik bilgileri) kombinasyonu sağlayarak kimlik bilgilerini web sitesinde ispatlamalıdır. Bu özel bilgileri her işlemle ileri geri taşımaktansa, web siteleri kullanıcı oturumunu kimliklendirilmiş olarak tanımlamak için eşsiz bir "oturum kimliği" oluşturacaktır. Kimliklendirilmiş oturumun bir "kanıtı olarak", kullanıcı ile web sitesi arasındaki sonraki iletişim, oturum kimliği ile etiketlenir. If an attacker is able predict or guess the session ID of another user, fraudulent activity is possible.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Credential-and-Session-Prediction</reference>
	<reference></reference>
</vuln_item_wasc_18>

<vuln_items>wasc_19</vuln_items>
<vuln_item_wasc_19>
	<alert>SQL Enjeksiyonu</alert>
	<desc>SQL Enjeksiyonu, kullanıcının sağladığı girdilerden SQL ifadeleri oluşturan uygulamalardan faydalanmak için kullanılan bir saldırı tekniğidir. Başarılı olursa, saldırgan veritabanı üzerinde yürütülen SQL ifadelerinin mantığını değiştirebilir.

Structured Query Language (SQL) is a specialized programming language for sending queries to databases. The SQL programming language is both an ANSI and an ISO standard, though many database products supporting SQL do so with proprietary extensions to the standard language. Uygulamalar SQL ifadeleri oluşturmak için sıklıkla kullanıcı tarafından sağlanan verileri kullanır. Eğer bir uygulama, doğru bir şekilde SQL ifadeleri oluşturmakta başarısız olursa, bir saldırganın ifade yapısını değiştirmesi, plansız ve potansiyel olarak saldırgan komutları yürütmesi mümkündür. Bu tür komutlar yürütüldüğünde, açıklamayı yürüten uygulamanın belirlediği kullanıcı bağlamında bunu yaparlar. Bu özellik, saldırganların barındırma sistemi üzerindeki komutları yürütmesine ve o kullanıcı tarafından erişilebilen tüm veritabanı kaynaklarının kontrolünü ele geçirmesine imkan tanır.</desc>
	<solution>Faz: Mimari ve Tasarım
Bu zafiyetin meydana gelmesine izin vermeyen veya bu zafiyetten kaçınmayı kolaylaştıracak yapılar sunan, güvenilir bir kütüphane veya framework kullanın.
For example, consider using persistence layers such as Hibernate or Enterprise Java Beans, which can provide significant protection against SQL injection if used properly.

Varsa, veri ile kod arasındaki ayrımı otomatik olarak uygulayan yapısal mekanizmalar kullanın. Bu mekanizmalar, üreticinin ürettiği her çıkış alanı için bu özellikleri elde etmek için geliştiriciye güvenmek yerine, otomatik olarak doğru tanıtımı, kodlamayı ve doğrulamayı sağlayabilir.

Process SQL queries using prepared statements, parameterized queries, or stored procedures. Bu özellikler parametreleri veya değişkenleri kabul etmeli ve güçlü yazı yazmayı desteklemelidir. Do not dynamically construct and execute query strings within these features using "exec" or similar functionality, since you may re-introduce the possibility of SQL injection.

Run your code using the lowest privileges that are required to accomplish the necessary tasks. Eğer mümkünse, tek bir görev için kullanılan, kısıtlı yetkilere sahip izole hesaplar oluşturun. Bu şekilde, başarılı bir saldırı saldırgana anında yazılımın veya ortamının geri kalanına erişim vermeyecektir. Örneğin, veritabanı uygulamaları, özellikle günlük işlemlerde, veritabanı yöneticisi olarak çalıştırılmaya nadiren ihtiyaç duyar.

Specifically, follow the principle of least privilege when creating user accounts to a SQL database. The database users should only have the minimum privileges necessary to use their account. If the requirements of the system indicate that a user can read and modify their own data, then limit their privileges so they cannot read/write others' data. Use the strictest permissions possible on all database objects, such as execute-only for stored procedures.

Phase: Implementation
If you need to use dynamically-generated query strings or commands in spite of the risk, properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict whitelist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Argüman enjeksiyonuna dikkat edin (CWE-88).

Instead of building your own implementation, such features may be available in the database or programming language. Örneğin, Oracle DBMS ASSERT pakedi, parametrelerin kendilerini SQL enjeksiyonuna daha dirençli hale getiren özelliklerine sahip olup olmadığını kontrol edebilir veya sahip olmasını sağlayabilir. For MySQL, the mysql real escape string() API function is available in both C and PHP.

Tüm girdilerin zararlı olduğunu varsayalım. "Accept known good" (bilinen mal kabulü) giriş onaylama stratejisi kullanın. Spesifikasyonlara kesinlikle uyan kabul edilebilir girdilerden oluşan bir beyaz liste oluşturun. Şartlara tam olarak uymayan veya başka şeye dönüştüren girdileri reddedin. Sadece zararlı veya kusurlu girdilere güvenmeyin (örn, sadece kara listeye güvenmeyin). Yine de kara liste, olası saldırıları belirlemede veya hangi girdilerin kusurlu olduğunu ve reddedilmesi gerektiğini belirlemede faydalıdır.

Giriş doğrulamasını gerçekleştirirken, uzunluğu, girdi türünü, kabul edilebilir değerlerin tümünü, eksik veya fazla girdileri, söz dizimini, ilgili alanlardaki tutarlılık ve iş kurallarına uyum da dahil olmak üzere potansiyel olarak ilgili tüm özellikleri düşünün. İş kuralı mantığına bir örnek olarak, "tekne" sözdizimsel olarak geçerli olabilir, çünkü dize yalnızca alfasayısal karakterler içerir, ancak "kırmızı" veya "mavi" gibi renkler beklenmesi durumunda geçerli değildir.

SQL sorgu dizeleri oluştururken, sorgudaki parametrenin beklenen değerine dayalı olarak karakter kümesini sınırlayan güçlü beyaz listeleri kullanın. This will indirectly limit the scope of an attack, but this technique is less important than proper output encoding and escaping.

Note that proper output encoding, escaping, and quoting is the most effective solution for preventing SQL injection, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent SQL injection, especially if you are required to support free-form text fields that could contain arbitrary characters. Örneğin, "O'Reilly" ismi İngilizce'de sık bulunan bir soyadı olduğu için büyük ihtimalle doğrulama aşamasını geçecektir. However, it cannot be directly inserted into the database because it contains the "'" apostrophe character, which would need to be escaped or otherwise handled. In this case, stripping the apostrophe might reduce the risk of SQL injection, but it would produce incorrect behavior because the wrong name would be recorded.

When feasible, it may be safest to disallow meta-characters entirely, instead of escaping them. Bu derinlemesine bir savunma sağlayacaktır. After the data is entered into the database, later processes may neglect to escape meta-characters before use, and you may not have control over those processes.</solution>
	<reference>http://projects.webappsec.org/SQL-Injection</reference>
	<reference></reference>
</vuln_item_wasc_19>

<vuln_items>wasc_20</vuln_items>
<vuln_item_wasc_20>
	<alert>Improper Input Handling</alert>
	<desc>Improper input handling is one of the most common weaknesses identified across applications today. Poorly handled input is a leading cause behind critical vulnerabilities that exist in systems and applications.
	
Generally, the term input handing is used to describe functions like validation, sanitization, filtering, encoding and/or decoding of input data. Applications receive input from various sources including human users, software agents (browsers), and network/peripheral devices to name a few. In the case of web applications, input can be transferred in various formats (name value pairs, JSON, SOAP, etc...) and obtained via URL query strings, POST data, HTTP headers, Cookies, etc... Non-web application input can be obtained via application variables, environment variables, the registry, configuration files, etc... Regardless of the data format or source/location of the input, all input should be considered untrusted and potentially malicious. Applications which process untrusted input may become vulnerable to attacks such as Buffer Overflows, SQL Injection, OS Commanding, Denial of Service just to name a few.

One of the key aspects of input handling is validating that the input satisfies a certain criteria. For proper validation, it is important to identify the form and type of data that is acceptable and expected by the application. Defining an expected format and usage of each instance of untrusted input is required to accurately define restrictions. 

Validation can include checks for type safety and correct syntax. Dize girişi, tamsayılar ve ondalıklar gibi sayısal girdi türleri değerlerin kabul edilebilir üst ve alt sınırlarına göre doğrulanabilirken, uzunluk (min. Ve maks. Karakter sayısı) ve karakter seti doğrulaması için kontrol edilebilir. Çeşitli kaynaklardan gelen girdiler birleştirildiğinde doğrulama, yalnızca bireysel veri öğelerinde değil, birleştirme üzerinde gerçekleştirilmelidir. This practice helps avoid situations where input validation may succeed when performed on individual data items but fails when done on a combined set from all the sources.</desc>
	<solution>Phase: Architecture and Design

Use an input validation framework such as Struts or the OWASP ESAPI Validation API.

Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, databases, and any external systems that provide data to the application. Unutmayın ki bunun gibi girdiler API çağrıları sayesinde dolaylı olarak elde edebilirler.

For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side. Saldırganlar, denetimler gerçekleştirildikten sonra değerleri değiştirerek veya istemci tarafı denetimlerini tamamen kaldırmak için istemciyi değiştirerek istemci tarafı denetimleri atlayabilir. Ardından, bu değiştirilen değerler sunucuya gönderilir.

Even though client-side checks provide minimal benefits with respect to server-side security, they are still useful. Birinci, saldırı tespitini destekleyebilirler. If the server receives input that should have been rejected by the client, then it may be an indication of an attack. Second, client-side error-checking can provide helpful feedback to the user about the expectations for valid input. Third, there may be a reduction in server-side processing time for accidental input errors, although this is typically a small savings.

Do not rely exclusively on blacklist validation to detect malicious input or to encode output. There are too many ways to encode the same character, so you're likely to miss some variants.

When your application combines data from multiple sources, perform the validation after the sources have been combined. The individual data elements may pass the validation step but violate the intended restrictions after they have been combined.

Tüm girdilerin zararlı olduğunu varsay. "Accept known good" (bilinen mal kabulü) giriş onaylama stratejisi kullanın. Spesifikasyonlara kesinlikle uyan kabul edilebilir girdilerden oluşan bir beyaz liste oluşturun. Şartlara tam olarak uymayan veya başka şeye dönüştüren girdileri reddedin. Sadece zararlı veya kusurlu girdilere güvenmeyin (örn, sadece kara listeye güvenmeyin). Yine de kara liste, olası saldırıları belirlemede veya hangi girdilerin kusurlu olduğunu ve reddedilmesi gerektiğini belirlemede faydalıdır.

Giriş doğrulamasını gerçekleştirirken, uzunluğu, girdi türünü, kabul edilebilir değerlerin tümünü, eksik veya fazla girdileri, söz dizimini, ilgili alanlardaki tutarlılık ve iş kurallarına uyum da dahil olmak üzere potansiyel olarak ilgili tüm özellikleri düşünün. As an example of business rule logic, "boat" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if you are expecting colors such as "red" or "blue."

Phase: Implementation

Be especially careful to validate your input when you invoke code that crosses language boundaries, such as from an interpreted language to native code. This could create an unexpected interaction between the language boundaries. Ensure that you are not violating any of the expectations of the language with which you are interfacing. Örneğin, Java arabellek taşmalarına duyarlı olmasa da, yerel kod çağrısında büyük argüman sağlamak taşma olasılığını tetikleyebilir.

Directly convert your input type into the expected data type, such as using a conversion function that translates a string into a number. After converting to the expected data type, ensure that the input's values fall within the expected range of allowable values and that multi-field consistencies are maintained.

Girişler doğrulanmadan önce uygulamanın mevcut iç temsiline göre kodlanmalı ve standart hale getirilmelidir. Uygulamanızın aynı girişi yanlışlıkla iki defa çözmediğine emin olun. Such errors could be used to bypass whitelist schemes by introducing dangerous inputs after they have been checked. OWASP ESAPI Canonicalization kontrolü gibi kütüphaneleri kullanın.

Consider performing repeated canonicalization until your input does not change any more. This will avoid double-decoding and similar scenarios, but it might inadvertently modify inputs that are allowed to contain properly-encoded dangerous content.

When exchanging data between components, ensure that both components are using the same character encoding. Her bir arayüzde doğru şifreleme uygulandığından emin olun. Protokolün buna izin verdiğinde her zaman kullandığınız kodlamayı açıkça belirtin.</solution>
	<reference>http://projects.webappsec.org/Improper-Input-Handling</reference>
	<reference>http://cwe.mitre.org/data/definitions/89.html</reference>
</vuln_item_wasc_20>

<vuln_items>wasc_21</vuln_items>
<vuln_item_wasc_21>
	<alert>Yetersiz karşı otomasyon</alert>
	<desc>Insufficient Anti-automation occurs when a web application permits an attacker to automate a process that was originally designed to be performed only in a manual fashion, i.e. by a human web user.

Aşağıdaki özellikler otomatik saldırıların hedefidir:
    * Giriş formları - saldırganlar, kullanıcının kimlik bilgilerini tahmin etmeye çalışmak için kaba kuvvet giriş isteklerini otomatikleştirebilirler
    * Hizmet kayıt formları - saldırganlar otomatik olarak binlerce yeni hesap oluşturabilir
    * E-posta Formları - saldırganlar e-posta formlarını spam röleleri olarak kullanabilir veya bir kullanıcının posta kutusunu taşırlar
    * Hesap Bakımı - saldırganlar bir uygulamaya yönelik hizmet reddi saldırıları yapabilir, kullanıcı hesaplarını devre dışı bırakmak veya silmek için sayısız istekte bulunabilirler
    * Hesap bilgileri formları - saldırganlar bir internet uygulamasının kullanıcısı tarafından kişisel bilgi toplamak için kitlesel girişimlerde bulunabilir
    * Yorum formları / içerik gönderme formları - spam, hatta kötü amaçlı yazılım gibi içeriği otomatik olarak göndererek bloglara, internet forumlarına ve mesaj panolarına spam yapmak için kullanılabilir.
    * SQL veritabanı sorgularıyla ilgili formlar - bunlar uygulamaya karşı bir hizmet reddi saldırısı gerçekleştirmek için kullanılabilir. Saldırı, kısa sürede sayısız ağır SQL sorguları göndererek gerçek kullanıcıların hizmetten mahrum bırakılmasıyla gerçekleştirilir.
    * eShopping / eCommerce - eShopping and eCommerce applications that do not enforce human-only buyers, can be exploited in order to buy preferred items in large amounts, such as sporting events tickets. Bunlar daha sonra daha yüksek fiyatlarla satılmaktadır.
    * Online polls - polls and other types of online voting systems can be automatically subverted in favor of a certain choice.
    * Web tabanlı SMS mesajı gönderme - saldırganlar cep telefonu kullanıcılarına spam göndermek için SMS mesajı gönderme sistemlerinden yararlanabilirler
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Insufficient+Anti-automation</reference>
	<reference>http://cwe.mitre.org/data/definitions/116.html</reference>
</vuln_item_wasc_21>

<vuln_items>wasc_22</vuln_items>
<vuln_item_wasc_22>
	<alert>Uygun olmayan çıktı işlemi</alert>
	<desc>Output handling refers to how an application generates outgoing data.  If an application has improper output handling, the output data may be consumed leading to vulnerabilities and actions never intended by the application developer.  In many cases, this unintended interpretation is classified as one or more forms of critical application vulnerabilities.

Any location where data leaves an application boundary may be subject to improper output handling.  Uygulama sınırları, verilerin bir bağlamdan çıktığı ve başkasına girdiği yerde bulunur.  This includes applications passing data to other applications via web services, sockets, command line, environmental variables, etc...  It also includes passing data between tiers within an application architecture, such as a database, directory server, HTML/JavaScript interpreter (browser), or operating system.  More detail on where improper output handling can occur can be found in the section below titled "Common Data Output Locations”.

Improper output handling may take various forms within an application.  Bu formlar, protokol hataları, uygulama hataları ve veri tüketici ile ilgili hatalar olarak kategorize edilebilir.  Protocol errors include missing or improper output encoding or escaping and outputting of invalid data.  Application errors include logic errors such as outputting incorrect data or passing on malicious content unfiltered.  Uygulama, meşru içeriği gayri meşrudan ayırt etmezse, ya da veri tüketicisinde bilinen güvenlik açıkları etrafında çalışmazsa, hatalı çıkış işlemesinden kaynaklanan veri tüketici istismarına neden olabilir.

Doğru içerikte veri sunmayan bir uygulama, bir saldırganın veri tüketicisinden faydalanmasına imkan tanıyabilir.  This can lead to specific threats referenced within the WASC Threat Classification, including Content Spoofing, Cross-Site Scripting, HTTP Response Splitting, HTTP Response Smuggling, LDAP Injection, OS Commanding, Routing Detour, Soap Array Abuse, URL Redirector, XML Injection, XQuery Injection, XPath Injection, Mail Command Injection, Null Injection and SQL Injection.

Proper output handling prevents the unexpected or unintended interpretation of data by the consumer.  Bu amacı gerçekleştirebilmek için, geliştiriciler uygulamanın veri modelini, verinin uygulamanın diğer kısımları tarafından nasıl tüketileceğini ve kullanıcıya nihai olarak nasıl sunulacağını anlamalıdır.  Çıktının düzgün bir şekilde işlenmesini sağlamak için kullanılan teknikler arasında, bunlarla sınırlı olmamak üzere, verilerin filtrelenmesi ve sterilizasyonu da yer almaktadır (çıkış sanitasyonu ve filtrelemeyle ilgili daha ayrıntılı bilgiler, aşağıda uygun başlıklı bölümlerde bulunabilir).  However, inconsistent use of selected output handling techniques may actually increase the risk of improper output handling if output data is overlooked or left untreated.  To ensure "defense in depth" developers must assume that all data within an application is untrusted when choosing appropriate output handling strategies.

While proper output handling may take many different forms, an application cannot be secure unless it protects against unintended interpretations by the data consumer. This core requirement is essential for an application to securely handle output operations.</desc>
	<solution>Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.

For example, consider using the ESAPI Encoding control or a similar tool, library, or framework. These will help the programmer encode outputs in a manner less prone to error.

Alternately, use built-in functions, but consider using wrappers in case those functions are discovered to have a vulnerability.

Varsa, veri ile kod arasındaki ayrımı otomatik olarak uygulayan yapısal mekanizmalar kullanın. Bu mekanizmalar, üreticinin ürettiği her çıkış alanı için bu özellikleri elde etmek için geliştiriciye güvenmek yerine, otomatik olarak doğru tanıtımı, kodlamayı ve doğrulamayı sağlayabilir.

For example, stored procedures can enforce database query structure and reduce the likelihood of SQL injection.

Understand the context in which your data will be used and the encoding that will be expected. Bu, farklı bileşenler arasında veri iletirken veya web sayfaları veya çok parçalı e-posta iletileri gibi aynı anda birden fazla kodlama içerebilecek çıktılar üretirken özellikle önem taşır. Gerekli kodlama stratejilerini belirlemek için beklenen tüm iletişim protokollerini ve veri sunumlarını incele.

Bazı durumlarda, çıktı doğrulaması tam bir çözüm olmadığından giriş doğrulaması önemli bir strateji olabilir. Örneğin, farklı kodlamalar veya sunumlar kullanan birden çok tüketicinin işleyeceği aynı çıktıyı sağlayabilirsiniz. In other cases, you may be required to allow user-supplied input to contain control information, such as limited HTML tags that support formatting in a wiki or bulletin board. When this type of requirement must be met, use an extremely strict whitelist to limit which control sequences can be used. Verify that the resulting syntactic structure is what you expect. Normal kodlama yöntemlerini girdinin geri kalanı için kullanın.

Use input validation as a defense-in-depth measure to reduce the likelihood of output encoding errors (see CWE-20).

When exchanging data between components, ensure that both components are using the same character encoding. Her bir arayüzde doğru şifreleme uygulandığından emin olun. Protokolün buna izin verdiğinde her zaman kullandığınız kodlamayı açıkça belirtin.</solution>
	<reference>http://projects.webappsec.org/Improper-Output-Handling</reference>
	<reference></reference>
</vuln_item_wasc_22>

<vuln_items>wasc_23</vuln_items>
<vuln_item_wasc_23>
	<alert>XML Enjeksiyonu</alert>
	<desc>XML Injection is an attack technique used to manipulate or compromise the logic of an XML application or service. İstenmeyen XML içeriği ve/veya yapılarını bir XML iletisine enjekte edilmesi, uygulamanın mantığını değiştirebilir. Further, XML injection can cause the insertion of malicious content into the resulting message/document.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/XML-Injection</reference>
	<reference></reference>
</vuln_item_wasc_23>

<vuln_items>wasc_24</vuln_items>
<vuln_item_wasc_24>
	<alert>HTTP Request Splitting</alert>
	<desc>HTTP Request Splitting is an attack that enables forcing the browser to send arbitrary HTTP requests, inflicting XSS and poisoning the browser's cache. Saldırının özü, kurban (tarayıcı) saldırganın kötü niyetli HTML sayfasını yüklemeye zorlandığında, bir HTTP isteği yerine 2 HTTP isteği göndermek için tarayıcı işlevlerinden birini değiştirmesi, saldırganın yeteneğidir. Two such mechanisms have been exploited to date: the XmlHttpRequest object (XHR for short) and the HTTP digest authentication mechanism. Bu saldırının çalışması için tarayıcının ileri bir HTTP proxy kullanması gerekir (hepsi bu saldırıyı "desteklemez") veya saldırı aynı IP'de (tarayıcı perspektifinden) bulunan bir ana makineye karşı saldırganın makinesi ile gerçekleştirilmelidir.</desc>
	<solution>Avoid using CRLF as a special sequence.

Appropriately filter or quote CRLF sequences in user-controlled input.</solution>
	<reference>http://projects.webappsec.org/HTTP-Request-Splitting</reference>
	<reference>http://cwe.mitre.org/data/definitions/93.html</reference>
</vuln_item_wasc_24>

<vuln_items>wasc_25</vuln_items>
<vuln_item_wasc_25>
	<alert>HTTP Response Splitting</alert>
	<desc>In the HTTP Response Splitting attack, there are always 3 parties (at least) involved:
    * Web server, which has a security hole enabling HTTP Response Splitting
    * Target - an entity that interacts with the web server perhaps on behalf of the attacker. Typically this is a cache server forward/reverse proxy), or a browser (possibly with a browser cache).
    * Attacker - initiates the attack

The essence of HTTP Response Splitting is the attacker's ability to send a single HTTP request that forces the web server to form an output stream, which is then interpreted by the target as two HTTP responses instead of one response, in the normal case. The first response may be partially controlled by the attacker, but this is less important. What is material is that the attacker completely controls the form of the second response from the HTTP status line to the last byte of the HTTP response body. Once this is possible, the attacker realizes the attack by sending two requests through the target. The first one invokes two responses from the web server, and the second request would typically be to some "innocent" resource on the web server. However, the second request would be matched, by the target, to the second HTTP response, which is fully controlled by the attacker. The attacker, therefore, tricks the target into believing that a particular resource on the web server (designated by the second request) is the server's HTTP response (server content), while it is in fact some data, which is forged by the attacker through the web server - this is the second response.

HTTP Response Splitting attacks take place where the server script embeds user data in HTTP response headers. Bu, genellikle komut dosyası kullanıcı verilerini yönlendirme yanıtının yeniden yönlendirme URL'sine gömerken olur(HTTP status code 3xx), veya komut dosyası kullanıcı verilerini çerez değerine yerleştirdiğinde veya yanıt bir çerez ayarlarken isimlendirir.</desc>
	<solution>Construct HTTP headers very carefully, avoiding the use of non-validated input data.</solution>
	<reference>http://projects.webappsec.org/HTTP-Response-Splitting</reference>
	<reference>http://cwe.mitre.org/data/definitions/113.html</reference>
</vuln_item_wasc_25>

<vuln_items>wasc_26</vuln_items>
<vuln_item_wasc_26>
	<alert>HTTP Request Smuggling</alert>
	<desc>HTTP Request Smuggling is an attack technique that abuses the discrepancy in parsing of non RFC compliant HTTP requests between two HTTP devices (typically a front-end proxy or HTTP-enabled firewall and a back-end web server) to smuggle a request to the second device "through" the first device. This technique enables the attacker to send one set of requests to the second device while the first device sees a different set of requests. In turn, this facilitates several possible exploitations, such as partial cache poisoning, bypassing firewall protection and XSS.</desc>
	<solution>Use a web server that employs a strict HTTP parsing procedure, such as Apache (See paper in reference).

Yalnızca SSL iletişimi kullanın.

Her isteğin ardından istemci oturumunu sonlandırın.

Tüm sayfaları önbelleknemez hale getirin.</solution>
	<reference>http://projects.webappsec.org/HTTP-Request-Smuggling</reference>
	<reference>http://cwe.mitre.org/data/definitions/444.html</reference>
</vuln_item_wasc_26>

<vuln_items>wasc_27</vuln_items>
<vuln_item_wasc_27>
	<alert>HTTP Response Smuggling</alert>
	<desc>HTTP response smuggling is a technique to "smuggle" 2 HTTP responses from a server to a client, through an intermediary HTTP device that expects (or allows) a single response from the server.

One use for this technique is to enhance the basic HTTP response splitting technique in order to evade anti- HTTP response splitting measures. In this case, the intermediary is the anti-HTTP response splitting mechanism between the web server and the proxy server (or web browser). Başka bir kullanım durumu ise tarayıcı tarafından alınan yanıtların aldatmasını yapmaktır. In this case a malicious web site serves the browser a page that the browser will interpret as originating from a different (target) domain. HTTP response smuggling can be used to achieve this when the browser uses a proxy server to access both sites.

HTTP response smuggling makes use of HTTP request smuggling -like techniques to exploit the discrepancies between what an anti- HTTP Response Splitting mechanism (or a proxy server) would consider to be the HTTP response stream, and the response stream as parsed by a proxy server (or a browser). So, while an anti- HTTP response splitting mechanism may consider a particular response stream harmless (single HTTP response), a proxy/browser may still parse it as two HTTP responses, and hence be susceptible to all the outcomes of the original HTTP response splitting technique (in the first use case) or be susceptible to page spoofing (in the second case). For example, some anti- HTTP response splitting mechanisms in use by some application engines forbid the application from inserting a header containing CR+LF to the response. Yet an attacker can force the application to insert a header containing CRs, thereby circumventing the defense mechanism. Some proxy servers may still treat CR (only) as a header (and response) separator, and as such the combination of web server and proxy server will still be vulnerable to an attack that may poison the proxy's cache.
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/HTTP-Response-Smuggling</reference>
	<reference></reference>
</vuln_item_wasc_27>

<vuln_items>wasc_28</vuln_items>
<vuln_item_wasc_28>
	<alert>Boş Bayt Enjeksiyonu</alert>
	<desc>Null Byte Injection is an active exploitation technique used to bypass sanity checking filters in web infrastructure by adding URL-encoded null byte characters (i.e. %00, or 0x00 in hex) to the user-supplied data. Bu enjeksiyon işlemi, uygulamanın mantığını değiştirebilir ve kötü niyetli bir kişiye, sistem dosyalarına yetkisiz erişim izni verebilir.

Most web applications today are developed using higher-level languages such as, PHP, ASP, Perl, and Java. However, these web applications at some point require processing of high-level code at system level and this process is usually accomplished by using ‘C/C++’ functions. The diverse nature of these dependent technologies has resulted in an attack class called ‘Null Byte Injection’ or ‘Null Byte Poisoning’ attack. In C/C++, a null byte represents the string termination point or delimiter character which means to stop processing the string immediately. Sınırlayıcıyı takip eden bitler yok sayılacaktır. If the string loses its null character, the length of a string becomes unknown until memory pointer happens to meet next zero byte. Bu istenmeyen dağılım, sistem veya uygulama kapsamı içinde alışılmadık davranışlara neden olabilir ve güvenlik açıklarını ortaya çıkarabilir. In similar terms, several higher-level languages treat the ‘null byte’ as a placeholder for the string length as it has no special meaning in their context. Due to this difference in interpretation, null bytes can easily be injected to manipulate the application behavior.

URLs are limited to a set of US-ASCII characters ranging from 0x20 to 0x7E (hex) or 32 to 126 (decimal). However, the aforementioned range uses several characters that are not permitted because they have special meaning within HTTP protocol context. For this reason, the URL encoding scheme was introduced to include special characters within URL using the extended ASCII character representation. In terms of “null byte”, this is represented as %00 in hexadecimal. The scope of a null byte attack starts where web applications interact with active ‘C’ routines and external APIs from the underlying OS. Thus, allowing an attacker to manipulate web resources by reading or writing files based on the application's user privileges.</desc>
	<solution>Developers should anticipate that null characters or null bytes will be injected/removed/manipulated in the input vectors of their software system. Use an appropriate combination of black lists and white lists to ensure only valid, expected and appropriate input is processed by the system.

Tüm girdilerin zararlı olduğunu varsay. Use a standard input validation mechanism to validate all input for length, type, syntax, and business rules before accepting the data to be displayed or stored. "Bilineni iyi kabul et" onaylama stratejisini kullanın.

Use and specify a strong output encoding (such as ISO 8859-1 or UTF 8).

Do not rely exclusively on blacklist validation to detect malicious input or to encode output. There are too many variants to encode a character; you're likely to miss some variants.

Girişler doğrulanmadan önce uygulamanın mevcut iç temsiline göre kodlanmalı ve standart hale getirilmelidir. Make sure that your application does not decode the same input twice. Bu tür hatalar kontrol edildikten sonra tehlikeli girdiler getirerek temiz liste şemalarına yerleştirilir.</solution>
	<reference>http://projects.webappsec.org/Null-Byte-Injection</reference>
	<reference>http://cwe.mitre.org/data/definitions/158.html</reference>
</vuln_item_wasc_28>

<vuln_items>wasc_29</vuln_items>
<vuln_item_wasc_29>
	<alert>LDAP enjeksiyonu</alert>
	<desc>LDAP Injection is an attack technique used to exploit web sites that construct LDAP statements from user-supplied input.

Lightweight Directory Access Protocol (LDAP) is an open-standard protocol for both querying and manipulating X.500 directory services. The LDAP protocol runs over Internet transport protocols, such as TCP. Web applications may use user-supplied input to create custom LDAP statements for dynamic web page requests.

When a web application fails to properly sanitize user-supplied input, it is possible for an attacker to alter the construction of an LDAP statement. When an attacker is able to modify an LDAP statement, the process will run with the same permissions as the component that executed the command. (e.g. Database server, Web application server, Web server, etc.). This can cause serious security problems where the permissions grant the rights to query, modify or remove anything inside the LDAP tree. The same advanced exploitation techniques available in SQL Injection can also be similarly applied in LDAP Injection.</desc>
	<solution>Assume all input is malicious. Use an appropriate combination of black lists and white lists to neutralize LDAP syntax from user-controlled input.</solution>
	<reference>http://projects.webappsec.org/LDAP-Injection</reference>
	<reference>http://cwe.mitre.org/data/definitions/90.html</reference>
</vuln_item_wasc_29>

<vuln_items>wasc_30</vuln_items>
<vuln_item_wasc_30>
	<alert>Mail Command Injection</alert>
	<desc>Mail Command Injection is an attack technique used to exploit mail servers and webmail applications that construct IMAP/SMTP statements from user-supplied input that is not properly sanitized. Depending on the type of statement taken advantage by the attacker, we meet two types of injections: IMAP and SMTP Injection. An IMAP/SMTP Injection may make it possible to access a mail server which you previously had no access to before-hand. In some cases, these internal systems do not have the same level of infrastructure security hardening applied to them as most front-end web servers. Hence, attackers may find that the mail server yields better results in terms of exploitation. On the other hand, this technique allows to evade possible restrictions that could exist at application level (CAPTCHA, maximum number of requests, etc.).</desc>
	<solution>Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, request headers as well as content, URL components, e-mail, files, databases, and any external systems that provide data to the application. İyi tanımlanmış arayüzlerde girdi doğrulaması yapın.

Tüm girdilerin zararlı olduğunu varsay. Use an "accept known good" input validation strategy (i.e., use a whitelist). Şartlara tam olarak uymayan veya başka şeye dönüştüren girdileri reddedin. Use a blacklist to reject any unexpected inputs and detect potential attacks.

Do not rely exclusively on blacklist validation to detect malicious input or to encode output. There are too many ways to encode the same character, so you're likely to miss some variants.

Directly convert your input type into the expected data type, such as using a conversion function that translates a string into a number. After converting to the expected data type, ensure that the input's values fall within the expected range of allowable values and that multi-field consistencies are maintained.

Girişler doğrulanmadan önce uygulamanın mevcut iç temsiline göre kodlanmalı ve standart hale getirilmelidir. Make sure that your application does not inadvertently decode the same input twice . Such errors could be used to bypass whitelist schemes by introducing dangerous inputs after they have been checked. OWASP ESAPI Canonicalization kontrolü gibi kütüphaneleri kullanın.

Consider performing repeated canonicalization until your input does not change any more. This will avoid double-decoding and similar scenarios, but it might inadvertently modify inputs that are allowed to contain properly-encoded dangerous content.

When exchanging data between components, ensure that both components are using the same character encoding. Her bir arayüzde doğru şifreleme uygulandığından emin olun. Protokolün buna izin verdiğinde her zaman kullandığınız kodlamayı açıkça belirtin.

Uygulamanız birden fazla kaynaktan gelen verileri bir araya getirdiğinde, kaynak birleştirildikten sonra doğrulayın. The individual data elements may pass the validation step but violate the intended restrictions after they have been combined.</solution>
	<reference>http://projects.webappsec.org/Mail-Command-Injection</reference>
	<reference>http://cwe.mitre.org/data/definitions/88.html</reference>
</vuln_item_wasc_30>

<vuln_items>wasc_31</vuln_items>
<vuln_item_wasc_31>
	<alert>OS Commanding</alert>
	<desc>OS Commanding is an attack technique used for unauthorized execution of operating system commands.

OS Commanding is the direct result of mixing trusted code and untrusted data. This attack is possible when an application accepts untrusted input to build operating system commands in an insecure manner involving improper data sanitization, and/or improper calling of external programs. In OS Commanding, executed commands by an attacker will run with the same privileges of the component that executed the command, (e.g. database server, web application server, web server, wrapper, application). Komutlar, yürütülmekte olan bileşenin ayrıcalıkları altında yürütülürken bir saldırgan, ayrıca erişilemeyen parçalara erişebilir veya zarar verebilir(örneğin, işletim sistemi dizinleri ve dosyaları).</desc>
	<solution>If at all possible, use library calls rather than external processes to recreate the desired functionality.

Run your code in a "jail" or similar sandbox environment that enforces strict boundaries between the process and the operating system. Bu durum, belirli bir hedef dizin içerisinde hangi dosyalara erişileceğini veya yazılım tarafından hangi komutların uygulanacağını etkili şekilde kısıtlayabilir.

İşletim sistemi seviyesi örneklerine Unix chroot jail, AppArmor ve SeLinux da dahildir. Genel olarak yönetilen kod bazı korumalar sağlayabilir. Örneğin, Java Güvenlik Yöneticisi içerisindeki java.io.FilePermission, dosya operasyonları üzerinde kısıtlamaları belirtmenize izin verir.
Bu pratik bir çözüm olmayabilir ve sadece işletim sistemi üzerindeki etkileri kısıtlar; uygulamaların kalanları savunmasız kalabilir.

For any data that will be used to generate a command to be executed, keep as much of that data out of external control as possible. For example, in web applications, this may require storing the command locally in the session's state instead of sending it out to the client in a hidden form field.

Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.

For example, consider using the ESAPI Encoding control or a similar tool, library, or framework. These will help the programmer encode outputs in a manner less prone to error.

If you need to use dynamically-generated query strings or commands in spite of the risk, properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict whitelist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Argüman enjeksiyonuna dikkat edin.

If the program to be executed allows arguments to be specified within an input file or from standard input, then consider using that mode to pass arguments instead of the command line.

Varsa, veri ile kod arasındaki ayrımı otomatik olarak uygulayan yapısal mekanizmalar kullanın. Bu mekanizmalar, üreticinin ürettiği her çıkış alanı için bu özellikleri elde etmek için geliştiriciye güvenmek yerine, otomatik olarak doğru tanıtımı, kodlamayı ve doğrulamayı sağlayabilir.

Some languages offer multiple functions that can be used to invoke commands. Where possible, identify any function that invokes a command shell using a single string, and replace it with a function that requires individual arguments. Bu işlevler genellikle argümanların uygun bir şekilde alıntılanmasını ve filtrelenmesini gerçekleştirir. For example, in C, the system() function accepts a string that contains the entire command to be executed, whereas execl(), execve(), and others require an array of strings, one for each argument. In Windows, CreateProcess() only accepts one command at a time. In Perl, if system() is provided with an array of arguments, then it will quote each of the arguments.

Tüm girdilerin zararlı olduğunu varsay. "Accept known good" (bilinen mal kabulü) giriş onaylama stratejisi kullanın. Spesifikasyonlara kesinlikle uyan kabul edilebilir girdilerden oluşan bir beyaz liste oluşturun. Şartlara tam olarak uymayan veya başka şeye dönüştüren girdileri reddedin. Sadece zararlı veya kusurlu girdilere güvenmeyin (örn, sadece kara listeye güvenmeyin). Yine de kara liste, olası saldırıları belirlemede veya hangi girdilerin kusurlu olduğunu ve reddedilmesi gerektiğini belirlemede faydalıdır.

Giriş doğrulamasını gerçekleştirirken, uzunluğu, girdi türünü, kabul edilebilir değerlerin tümünü, eksik veya fazla girdileri, söz dizimini, ilgili alanlardaki tutarlılık ve iş kurallarına uyum da dahil olmak üzere potansiyel olarak ilgili tüm özellikleri düşünün. İş kuralı mantığına bir örnek olarak, "tekne" sözdizimsel olarak geçerli olabilir, çünkü dize yalnızca alfasayısal karakterler içerir, ancak "kırmızı" veya "mavi" gibi renkler beklenmesi durumunda geçerli değildir.

OS komut dizelerini oluştururken, sorguda parametrenin beklenen değerine dayalı olarak karakter kümesini sınırlayan güçlü beyaz listeleri kullanın. This will indirectly limit the scope of an attack, but this technique is less important than proper output encoding and escaping.

Note that proper output encoding, escaping, and quoting is the most effective solution for preventing OS command injection, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent OS command injection, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, when invoking a mail program, you might need to allow the subject field to contain otherwise-dangerous inputs like ";" and ">" characters, which would need to be escaped or otherwise handled. In this case, stripping the character might reduce the risk of OS command injection, but it would produce incorrect behavior because the subject field would not be recorded as the user intended. This might seem to be a minor inconvenience, but it could be more important when the program relies on well-structured subject lines in order to pass messages to other components.

Doğrulamanızda bir hata yaparsanız bile (100 giriş alanında birinin unutulması gibi), uygun kodlamanın enjeksiyon tabanlı saldırılardan korunmak içindir. Tek başına yapılmadığı sürece, saldırı yüzeyinizi önemli ölçüde azaltabileceğinden, bazı saldırıları tespit etmenize izin verdiğinden ve uygun kodlamanın çözemediği diğer güvenlik avantajlarını sağladığından giriş doğrulaması hala yararlı bir tekniktir.</solution>
	<reference>http://projects.webappsec.org/OS-Commanding</reference>
	<reference>http://cwe.mitre.org/data/definitions/78.html</reference>
</vuln_item_wasc_31>

<vuln_items>wasc_32</vuln_items>
<vuln_item_wasc_32>
	<alert>Yönlendirme gidişatı</alert>
	<desc>The WS-Routing Protocol (WS-Routing) is a protocol for exchanging SOAP messages from an initial message sender to an ultimate receiver, typically via a set of intermediaries. The WS-Routing protocol is implemented as a SOAP extension, and is embedded in the SOAP Header. WS-Routing is often used to provide a way to direct XML traffic through complex environments and transactions by allowing interim way stations in the XML path to assign routing instructions to an XML document.

Routing Detours are a type of "Man in the Middle" attack where Intermediaries can be injected or "hijacked" to route sensitive messages to an outside location. Routing information (either in the HTTP header or in WS-Routing header) can be modified en route and traces of the routing can be removed from the header and message such that the receiving application none the wiser that a routing detour has occurred. The header and the insertion of header objects is often less protected than the message; this is due to the fact that the header is used as a catch all for metadata about the transaction such as authentication, routing, formatting, schema, canonicalization, namespaces, etc. Also, many processes may be involved in adding to/processing the header of an XML document. In many implementations the routing info can come from an external web service (using WS-Referral for example) that provides the specific routing for the transaction.

WS-Addressing is a newer standard published by the W3C to provide routing functionality to SOAP messages. One of the key differences between WS-Routing and WS-Addressing is that WS-Addressing only provides the next location in the route. While little research has been done into the susceptibility of WS-Addressing to Routing Detour Attack, at least one paper (see reference #6 below) suggests that WS-Addressing is vulnerable to Routing Detour as well.</desc>
	<solution>Herhangi bir iletişim kanalının her iki ucunu daima tam olarak doğrulayın.

Arabuluculuk ilkesine uyun.

Bir sertifika, iletişim kuran tarafın kimliğini doğrulama için kimlik şifreleme anahtarına bağlanır. Genellikle, sertifika, öznenin kimliğinin, ortak anahtarının ve yayıncının özel anahtarı kullanılarak yayınlanma veya sona erme süresi gibi bilgilerin şifrelenmiş biçimini alır. The certificate can be validated by deciphering the certificate with the issuer's public key. See also X.509 certificate signature chains and the PGP certification structure.</solution>
	<reference>http://projects.webappsec.org/Routing-Detour</reference>
	<reference>http://cwe.mitre.org/data/definitions/300.html</reference>
</vuln_item_wasc_32>

<vuln_items>wasc_33</vuln_items>
<vuln_item_wasc_33>
	<alert>Path Traversal</alert>
	<desc>The Path Traversal attack technique allows an attacker access to files, directories, and commands that potentially reside outside the web document root directory. An attacker may manipulate a URL in such a way that the web site will execute or reveal the contents of arbitrary files anywhere on the web server. Any device that exposes an HTTP-based interface is potentially vulnerable to Path Traversal.

Most web sites restrict user access to a specific portion of the file-system, typically called the "web document root" or "CGI root" directory. These directories contain the files intended for user access and the executable necessary to drive web application functionality. To access files or execute commands anywhere on the file-system, Path Traversal attacks will utilize the ability of special-characters sequences.

The most basic Path Traversal attack uses the "../" special-character sequence to alter the resource location requested in the URL. Although most popular web servers will prevent this technique from escaping the web document root, alternate encodings of the "../" sequence may help bypass the security filters. These method variations include valid and invalid Unicode-encoding ("..%u2216" or "..%c0%af") of the forward slash character, backslash characters ("..\") on Windows-based servers, URL encoded characters "%2e%2e%2f"), and double URL encoding ("..%255c") of the backslash character.

Even if the web server properly restricts Path Traversal attempts in the URL path, a web application itself may still be vulnerable due to improper handling of user-supplied input. Bu, şablon mekanizmaları kullanan veya dosyalardan statik metin yükleyen web uygulamalarının ortak bir problemidir. In variations of the attack, the original URL parameter value is substituted with the file name of one of the web application's dynamic scripts. Consequently, the results can reveal source code because the file is interpreted as text instead of an executable script. These techniques often employ additional special characters such as the dot (".") to reveal the listing of the current working directory, or "%00" NULL characters in order to bypass rudimentary file extension checks.</desc>
	<solution>Tüm girdilerin zararlı olduğunu varsay. "Accept known good" (bilinen mal kabulü) giriş onaylama stratejisi kullanın. Spesifikasyonlara kesinlikle uyan kabul edilebilir girdilerden oluşan bir beyaz liste oluşturun. Şartlara tam olarak uymayan veya başka şeye dönüştüren girdileri reddedin. Sadece zararlı veya kusurlu girdilere güvenmeyin (örn, sadece kara listeye güvenmeyin). Yine de kara liste, olası saldırıları belirlemede veya hangi girdilerin kusurlu olduğunu ve reddedilmesi gerektiğini belirlemede faydalıdır.

Giriş doğrulamasını gerçekleştirirken, uzunluğu, girdi türünü, kabul edilebilir değerlerin tümünü, eksik veya fazla girdileri, söz dizimini, ilgili alanlardaki tutarlılık ve iş kurallarına uyum da dahil olmak üzere potansiyel olarak ilgili tüm özellikleri düşünün. As an example of business rule logic, "boat" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if you are expecting colors such as "red" or "blue."

For filenames, use stringent whitelists that limit the character set to be used. If feasible, only allow a single "." character in the filename to avoid weaknesses, and exclude directory separators such as "/". İzin verilen dosya uzantılarını temiz listede kullanın.

Warning: if you attempt to cleanse your data, then do so that the end result is not in the form that can be dangerous. A sanitizing mechanism can remove characters such as '.' and ';' which may be required for some exploits. An attacker can try to fool the sanitizing mechanism into "cleaning" data into a dangerous form. Suppose the attacker injects a '.' inside a filename (e.g. "sensi.tiveFile") and the sanitizing mechanism removes the character resulting in the valid filename, "sensitiveFile". If the input data are now assumed to be safe, then the file may be compromised. 

Girişler doğrulanmadan önce uygulamanın mevcut iç temsiline göre kodlanmalı ve standart hale getirilmelidir. Make sure that your application does not decode the same input twice. Such errors could be used to bypass whitelist schemes by introducing dangerous inputs after they have been checked.

Use a built-in path canonicalization function (such as realpath() in C) that produces the canonical version of the pathname, which effectively removes ".." sequences and symbolic links.

Run your code using the lowest privileges that are required to accomplish the necessary tasks. Eğer mümkünse, tek bir görev için kullanılan, kısıtlı yetkilere sahip izole hesaplar oluşturun. Bu şekilde, başarılı bir saldırı saldırgana anında yazılımın veya ortamının geri kalanına erişim vermeyecektir. Örneğin, veritabanı uygulamaları, özellikle günlük işlemlerde, veritabanı yöneticisi olarak çalıştırılmaya nadiren ihtiyaç duyar.

When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.

Run your code in a "jail" or similar sandbox environment that enforces strict boundaries between the process and the operating system. Bu durum, belirli bir hedef dizin içerisinde hangi dosyalara erişileceğini veya yazılım tarafından hangi komutların uygulanacağını etkili şekilde kısıtlayabilir.

İşletim sistemi seviyesi örneklerine Unix chroot jail, AppArmor ve SeLinux da dahildir. Genel olarak, yönetilen kod bazı korumalar sağlayabilir. Örneğin, Java Güvenlik Yöneticisi içerisindeki java.io.FilePermission, dosya operasyonları üzerinde kısıtlamaları belirtmenize izin verir.

Bu pratik bir çözüm olmayabilir ve sadece işletim sistemi üzerindeki etkileri kısıtlar; uygulamaların kalanları savunmasız kalabilir.
</solution>
	<reference>http://projects.webappsec.org/Path-Traversal</reference>
	<reference>http://cwe.mitre.org/data/definitions/22.html</reference>
</vuln_item_wasc_33>

<vuln_items>wasc_34</vuln_items>
<vuln_item_wasc_34>
	<alert>Tahmin Edilebilir Kaynak Konumları</alert>
	<desc>Predictable Resource Location is an attack technique used to uncover hidden web site content and functionality. By making educated guesses via brute forcing an attacker can guess file and directory names not intended for public viewing. Brute forcing filenames is easy because files/paths often have common naming convention and reside in standard locations. Bunlara geçici dosyalar, yedekleme dosyaları, günlükler, yönetim sitesi bölümleri, yapılandırma dosyaları, demo uygulamaları ve örnek dosyalar dahildir. These files may disclose sensitive information about the website, web application internals, database information, passwords, machine names, file paths to other sensitive areas, etc...

This will not only assist with identifying site surface which may lead to additional site vulnerabilities, but also may disclose valuable information to an attacker about the environment or its users. Predictable Resource Location is also known as Forced Browsing, Forceful Browsing, File Enumeration, and Directory Enumeration.</desc>
	<solution>Apply appropriate access control authorizations for each access to all restricted URLs, scripts or files.

Consider using MVC based frameworks such as Struts.</solution>
	<reference>http://projects.webappsec.org/Predictable-Resource-Location</reference>
	<reference>http://cwe.mitre.org/data/definitions/425.html</reference>
</vuln_item_wasc_34>

<vuln_items>wasc_35</vuln_items>
<vuln_item_wasc_35>
	<alert>SOAP Array Abuse</alert>
	<desc>XML SOAP dizileri, kötü niyetli kullanım için genel bir hedeftir. SOAP arrays are defined as having a type of "SOAP-ENC:Array" or a type derived there from. SOAP arrays have one or more dimensions (rank) whose members are distinguished by ordinal position. An array value is represented as a series of elements reflecting the array, with members appearing in ascending ordinal sequence. Çok boyutlu diziler için sağ tarafın boyutu daha hızlı değişir. Her bir üye element, bağımsız üye gibi adlandırılır. Bir dizini bekleyen bir web servisi, SOAP sunucusunu makinenin belleğinde büyük bir dizin oluşturmak için zorlayarak bir XML DoS saldırısının hedefi olabilir, böylece bellek ön ayırması nedeniyle makineye bir DoS durumu verir.</desc>
	<solution> Perform adequate input validation against any value that influences the amount of memory that is allocated. Define an appropriate strategy for handling requests that exceed the limit, and consider supporting a configuration option so that the administrator can extend the amount of memory to be used if necessary.

Belleğe sistem tarafından sağlanan kaynakları kullanarak programı çalıştırın. This might still cause the program to crash or exit, but the impact to the rest of the system will be minimized.</solution>
	<reference>http://projects.webappsec.org/SOAP-Array-Abuse</reference>
	<reference>http://cwe.mitre.org/data/definitions/789.html</reference>
</vuln_item_wasc_35>

<vuln_items>wasc_36</vuln_items>
<vuln_item_wasc_36>
	<alert>SSI Enjeksiyonu</alert>
	<desc>SSI Injection (Server-side Include) is a server-side exploit technique that allows an attacker to send code into a web application, which will later be executed locally by the web server. SSI Injection exploits a web application's failure to sanitize user-supplied data before they are inserted into a server-side interpreted HTML file.

Before serving an HTML web page, a web server may parse and execute Server-side Include statements before providing it to the client. In some cases (e.g. message boards, guest books, or content management systems), a web application will insert user-supplied data into the source of a web page.

If an attacker submits a Server-side Include statement, he may have the ability to execute arbitrary operating system commands, or include a restricted file's contents the next time the page is served. This is performed at the permission level of the web server user.</desc>
	<solution>Gerekli olmayan sayfalarda SSl çalıştırılmasını devre dışı bırakın. For pages requiring SSI ensure that you perform the following checks
- Only enable the SSI directives that are needed for this page and disable all others.
- HTML entity encode user supplied data before passing it to a page with SSI execution permissions.
- Use SUExec to have the page execute as the owner of the file instead of the web server user.</solution>
	<reference>http://projects.webappsec.org/SSI-Injection</reference>
	<reference></reference>
</vuln_item_wasc_36>

<vuln_items>wasc_37</vuln_items>
<vuln_item_wasc_37>
	<alert>Oturum Sabitleme</alert>
	<desc>Session Fixation is an attack technique that forces a user's session ID to an explicit value. Depending on the functionality of the target web site, a number of techniques can be utilized to "fix" the session ID value. These techniques range from Cross-site Scripting exploits to peppering the web site with previously made HTTP requests. After a user's session ID has been fixed, the attacker will wait for that user to login. Once the user does so, the attacker uses the predefined session ID value to assume the same online identity.

Generally speaking there are two types of session management systems when it comes to ID values. The first type is "permissive" systems that allow web browsers to specify any ID. The second type is "strict" systems that only accept server-side-generated values. With permissive systems, arbitrary session IDs are maintained without contact with the web site. Strict systems require the attacker to maintain the "trap-session", with periodic web site contact, preventing inactivity timeouts.

Without active protection against Session Fixation, the attack can be mounted against any web site that uses sessions to identify authenticated users. Web sites using sessions IDs are normally cookie-based, but URLs and hidden form fields are used as well. Ne yazık ki çerez temelli oturumlar, saldırması en kolay olanlardır. Şu anda tanımlanmış olan saldırı yöntemlerinin çoğu, çerezlerin sabitlenmesine yöneliktir.

In contrast to stealing a users' session IDs after they have logged into a web site, Session Fixation provides a much wider window of opportunity. Saldırının aktif kısmı oturum açılmadan önce gerçekleşir.</desc>
	<solution>Invalidate any existing session identifiers prior to authorizing a new user session

For platforms such as ASP that do not generate new values for sessionid cookies, utilize a secondary cookie. In this approach, set a secondary cookie on the user's browser to a random value and set a session variable to the same value. If the session variable and the cookie value ever don't match, invalidate the session, and force the user to log on again.</solution>
	<reference>http://projects.webappsec.org/Session-Fixation</reference>
	<reference>http://cwe.mitre.org/data/definitions/384.html</reference>
</vuln_item_wasc_37>

<vuln_items>wasc_38</vuln_items>
<vuln_item_wasc_38>
	<alert>URL Redirector Abuse</alert>
	<desc>URL redirectors represent common functionality employed by web sites to forward an incoming request to an alternate resource. This can be done for a variety of reasons and is often done to allow resources to be moved within the directory structure and to avoid breaking functionality for users that request the resource at its previous location. URL redirectors may also be used to implement load balancing, leveraging abbreviated URLs or recording outgoing links. It is this last implementation which is often used in phishing attacks as described in the example below. URL yönlendiricileri, doğrudan bir güvenlik açığını temsil etmez, ancak mağdurları, gerçek hedefin dışındaki bir siteye gideceklerine inandıran sosyal mühendislik yapmaya çalışan saldırganlar tarafından istismar edilebilirler.</desc>
	<solution>Tüm girdilerin zararlı olduğunu varsay. "Accept known good" (bilinen mal kabulü) giriş onaylama stratejisi kullanın. Spesifikasyonlara kesinlikle uyan kabul edilebilir girdilerden oluşan bir beyaz liste oluşturun. Şartlara tam olarak uymayan veya başka şeye dönüştüren girdileri reddedin. Sadece zararlı veya kusurlu girdilere güvenmeyin (örn, sadece kara listeye güvenmeyin). Yine de kara liste, olası saldırıları belirlemede veya hangi girdilerin kusurlu olduğunu ve reddedilmesi gerektiğini belirlemede faydalıdır.

Giriş doğrulamasını gerçekleştirirken, uzunluğu, girdi türünü, kabul edilebilir değerlerin tümünü, eksik veya fazla girdileri, söz dizimini, ilgili alanlardaki tutarlılık ve iş kurallarına uyum da dahil olmak üzere potansiyel olarak ilgili tüm özellikleri düşünün. As an example of business rule logic, "boat" may be syntactically valid because it only contains alphanumeric characters, but it is not valid if you are expecting colors such as "red" or "blue."

Use a whitelist of approved URLs or domains to be used for redirection.

Use an intermediate disclaimer page that provides the user with a clear warning that they are leaving your site. Implement a long timeout before the redirect occurs, or force the user to click on the link. Be careful to avoid XSS problems when generating the disclaimer page.

When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.

For example, ID 1 could map to "/login.asp" and ID 2 could map to "http://www.example.com/". ESAPI AccessReferenceMap gibi özellikler bu kabiliyeti sağlar.

Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, databases, and any external systems that provide data to the application. Bu girdilerin API çağrıları yoluyla dolaylı olarak elde edilebileceğini unutmayın.

Many open redirect problems occur because the programmer assumed that certain inputs could not be modified, such as cookies and hidden form fields.</solution>
	<reference>http://projects.webappsec.org/URL-Redirector-Abuse</reference>
	<reference>http://cwe.mitre.org/data/definitions/601.html</reference>
</vuln_item_wasc_38>

<vuln_items>wasc_39</vuln_items>
<vuln_item_wasc_39>
	<alert>XPath Enjeksiyonu</alert>
	<desc>XPath Injection is an attack technique used to exploit applications that construct XPath (XML Path Language) queries from user-supplied input to query or navigate XML documents. It can be used directly by an application to query an XML document, as part of a larger operation such as applying an XSLT transformation to an XML document, or applying an XQuery to an XML document. The syntax of XPath bears some resemblance to an SQL query, and indeed, it is possible to form SQL-like queries on an XML document using XPath.

Eğer bir uygulama işleyiş süresi XPath sorgusu yapısı kullanıyorsa, sorguya güvensiz kullanıcı girdisi gömerek, saldırganın, yeni oluşturulan sorguyu programın amacından ayrıştırmasıyla sorguya veri enjekte etmesi olasıdır.</desc>
	<solution>Parametreleştirilmiş XPath sorgularını kullanın (örn. XQuery kullanımı). This will help ensure separation between data plane and control plane.

Kullanıcı girdisini doğru bir şekilde doğrulayın. Reject data where appropriate, filter where appropriate and escape where appropriate. Make sure input that will be used in XPath queries is safe in that context.</solution>
	<reference>http://projects.webappsec.org/XPath-Injection</reference>
	<reference>http://cwe.mitre.org/data/definitions/643.html</reference>
</vuln_item_wasc_39>

<vuln_items>wasc_40</vuln_items>
<vuln_item_wasc_40>
	<alert>İşlem doğrulaması yetersiz</alert>
	<desc>Yetersiz Süreç Doğrulama, web uygulaması saldırganın amaçlanan akışı ve uygulama işletme mantığını aşmasını engellemekte başarısız olursa meydana gelir. Gerçek dünyada göründüğünde, yetersiz süreç doğrulaması, yetersiz erişim kontrolü ve para kaybıyla sonuçlanmıştır.

Doğrulama gerektiren iki tür ana süreç vardır: akış kontrolü ve işletme akışı.

"Akış kontrolü", tüm adımların kullanıcı tarafından belirli bir sırada gerçekleşmesini gerektiren çoklu adım süreçlerini ifade eder. When an attacker performs the step incorrectly or out of order, the access controls may be bypassed and an application integrity error may occur. Çoklu adım süreçlerine havale, şifre kurtarma, satın alma çıkışları ve hesaba girme örnek olarak verilebilir.

"İşletme mantığı", işletme gereksinimleri tarafından yönetilen süreç uygulamaları kapsamını ifade eder. İşletme mantığı zayıflığının kötüye kullanılması işletme bilgisi gerektirir. Eğer kötüye kullanım için bilgi gerekmiyorsa, o zaman büyük ihtimalle işletme mantık akışı değildir. Bundan dolayı, tarama ve kod değerlendirmeleri gibi güvenlik önlemleri bu zayıflık sınıfını bulamaz. Bir test yaklaşımı, Test Kılavuzunda OWASP tarafından sunulmuştur.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Insufficient-Process-Validation</reference>
	<reference></reference>
</vuln_item_wasc_40>

<vuln_items>wasc_41</vuln_items>
<vuln_item_wasc_41>
	<alert>XML Özellik Büyültmesi</alert>
	<desc>XML Özellik Büyültmesi, XML ayrıştırıcılarına karşı hizmet saldırılarının reddedilmesidir. Saldırganlar, aşırı CPU yüküne neden olan savunmasız XML ayrıştırıcılarının oldukça verimsiz olarak işlenmesine neden olacak şekilde zararlı XML sağlarlar. Saldırının özü, aynı XML düğümüne bir çok niteliği dahil etmektir. Savunmasız XML ayrıştırıcıları, özellikleri verimsiz olarak yönetir (örn. yeni özelliklerin dahil edilmesinin O(n) çalışma süresine sahip olan veri içeriği gibi) ve sonuç ise doğrusal olmayan (bu örnekte kuadratik O(n2)) CPU tüketimi ile hizmet durumunu reddetmeye yol açar.</desc>
	<solution>Sistem mimarisinde kısma mekanizmaları ayarlayın. En iyi koruma, yetkisiz bir kullanıcının harcanmasına neden olabilecek kaynakların miktarını sınırlamaktır. Güçlü bir kimlik doğrulama ve erişim denetimi modeli, bu tür saldırıların önünün açılmasını önlemeye yardımcı olur. Giriş uygulaması DoS saldırılarına karşı mümkün olduğunca korunmalıdır. Sonuç setlerini yakalayarak veri tabanı erişimini kısıtlamak, kaynak harcamasını en aza indirmeye yardımcı olabilir. DoS saldırısı olasılığını daha da sınırlandırmak için kullanıcılardan alınan istek oranlarını izlemeyi ve belirlenen oran eşik değerini aşan istekleri engellemeyi düşünün.

Kaynak tüketimi saldırılarının azaltılması, sistemin aşağıdakileri uygulamasını gerektirir:
* saldırıyı tespit ederek ve belirli bir süre için başka bir ek erişimi reddederek,
* ya da tüm talepleri tekdüze olarak sınırlandırarak, böylece kaynaklar tekrar serbest bırakıldıkları için daha hızlı tüketilmez. 

Bu çözümlerden ilki kendisi içerisine sorundur çünkü saldırganın belirli geçerli bir kullanıcı tarafından sistemi kullanması engellenir. Saldırgan geçerli kullanıcıyı taklit ederse, kullanıcının söz konusu sunucudan erişmesini önleyebilir.

İkinci çözümü etkili bir şekilde uygulamak zordur ve düzgün olarak yapılsa bile tam çözüm sağlamaz. Bu şekilde, saldırının saldırgan tarafından daha fazla kaynak istemesini gerektirir.

Protokollerin belirli ölçek limitleri olduğundan emin olun.

Tüm kaynak dağıtımlarında meydana gelen hataların sistemi güvenli bir konumda tuttuğundan emin olun.</solution>
	<reference>http://projects.webappsec.org/XML-Attribute-Blowup</reference>
	<reference>http://cwe.mitre.org/data/definitions/400.html</reference>
</vuln_item_wasc_41>

<vuln_items>wasc_42</vuln_items>
<vuln_item_wasc_42>
	<alert>İşlevselliğin kötüye kullanımı</alert>
	<desc>Abuse of Functionality is an attack technique that uses a web site's own features and functionality to attack itself or others. İşlevselliğin Kötüye Kullanımı, istenmeyen bir sonucu gerçekleştirmek için amaçlanan uygulama işlevinin kötüye kullanımı olarak tanımlanır. Bu saldırıların kaynakları tüketmek, kontrollere erişmek veya bilgi sızdırmak gibi farklı sonuçları vardır. Kötüye kullanım olasılığı ve seviyesi internet siteleri ve uygulamalara göre değişir. İşlevsellik saldırılarının kötüye kullanımı genellikle diğer saldırı türlerinin birleşimi ve/veya diğer saldırı vektörlerinin kullanılması şeklinde gerçekleşir.</desc>
	<solution>API'leri her zaman belirtilen şekilde kullanmalısınız.</solution>
	<reference>http://projects.webappsec.org/Abuse-of-Functionality</reference>
	<reference>http://cwe.mitre.org/data/definitions/227.html</reference>
</vuln_item_wasc_42>

<vuln_items>wasc_43</vuln_items>
<vuln_item_wasc_43>
	<alert>XML Dış Varlıklar</alert>
	<desc>Belgeleri işleme sırasında dinamik olarak oluşturmak için teknik XML özelliğinden yararlanın. XML mesajı ya veriyi doğrudan sağlar ya da verinin olduğu URI'yı işaret eder. Saldırı yönetiminde harici varlıklar, varlık değerini zararlı veriyle değiştirebilir, başvuruları değiştirebilirveya sunucu/XML uygulamasının erişimi olan verilerin güvenliğini tehlikeye atabilir.
	Saldırganlar aynı zamanda zararlı kodu veya içeriği indirmek için web hizmeti sunucusu olan Harici Varlıkları da kullanabilirler.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/XML-External-Entities</reference>
	<reference></reference>
</vuln_item_wasc_43>

<vuln_items>wasc_44</vuln_items>
<vuln_item_wasc_44>
	<alert>XML Varlık Genişletme</alert>
	<desc>XML Varlık genişletme saldırısı, varlık adı verilen ve belge boyunca kullanılabilen özel makroların oluşturulmasına izin veren XML DTD'lerinin yeteneklerini sömürür. Bir belgenin üst kısmında bir dizi özel varlığı yinelemeli olarak tanımlayarak, bir saldırgan, varlıkları bu öz yinelemeli tanımlarda hemen hemen süresiz olarak yinelemeye zorlayarak varlıkları tamamen çözmeye çalışan ayrıştırıcıları zorlar.

Mevcut sunucu kaynaklarını tamamen kullanan tekrarlı varlık genişlemesini (veya diğer tekrarlı işlemlerini) zorlamak için zararlı XML mesajı kullanılır.</desc>
	<solution>Mümkünse, tekrar eden DTD varlıklarının genişlemesini kısıtlayan DTD'lerin veya XML ayrıştırıcısının kullanılmasını önleyin.

XML dosyalarını ilişkili DTD'lerle arıştırmadan önce, tekrar eden varlık ifadelerini arayın ve patlama potansiyeli olan içerikleri ayrıştırmaya devam etmeyin.</solution>
	<reference>http://projects.webappsec.org/XML-Entity-Expansion</reference>
	<reference>http://cwe.mitre.org/data/definitions/776.html</reference>
</vuln_item_wasc_44>

<vuln_items>wasc_45</vuln_items>
<vuln_item_wasc_45>
	<alert>Parmak izi</alert>
	<desc>The most common methodology for attackers is to first footprint the target's web presence and enumerate as much information as possible. With this information, the attacker may develop an accurate attack scenario, which will effectively exploit a vulnerability in the software type/version being utilized by the target host.

Çok katmanlı parmak izi, bir öncekine olan TCP/IP Parmak İzine (Nmap gibi bir tarayıcıyla yapılır) benzerdir. Sadece bu, Taşıma Tabakası yerine OSI modeline Uygulama Tabakasına odaklanır. Bu parmak izinin arkasındaki teori, hedefin platformunun, web uygulama yazılımı teknolojisinin, arka uç veritabanı sürümünün, yapılandırmanın ve hatta muhtemelen mimari / topoloji ağının doğru bir profilini oluşturmaktır.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Fingerprinting</reference>
	<reference></reference>
</vuln_item_wasc_45>

<vuln_items>wasc_46</vuln_items>
<vuln_item_wasc_46>
	<alert>XQuery Enjeksiyonu</alert>
	<desc>XQuery Enjeksiyonu, XML XQuery dil karşısında klasik SQL enjeksiyonunun bir çeşididir. XQuery Enjeksiyonu, XQuery komutlarından geçirilen uygun olmayan bir şekilde doğrulanmış verileri kullanır. Bu daha sonra XQuery rutinlerinin erişimi olan yerlere saldırgan adına komutları yürütecektir. XQuery enjeksiyonu, kurbanın ortamında, yerel sağlayıcının enjeksiyon komutlarında veya uzak dosya ve veri kaynağı arama uygulamalarında öğelerin sayılması için kullanılabilir. SQL enjeksiyon saldırıları gibi, saldırgan, uygulama giriş noktası ve hedef kaynak erişim tabakası arasında tünel oluşturur.</desc>
	<solution>Parametrize edilmiş aramalar kullanın. Bu şekilde veri düzlemi ve kontrol düzlemi arasındaki ayrımı korumaya yardımcı olabilirsiniz.

Kullanıcı girdisini doğru bir şekilde doğrulayın. Uygun olan yerlerde verileri reddedin, uygun olan yerlerde filtreleyin ve uygun olan olan yerlerde kaçın. XQL aramalarında kullanılacak girdilerin bu bağlamda güvenli olduğundan emin olun.</solution>
	<reference>http://projects.webappsec.org/XQuery-Injection</reference>
	<reference>http://cwe.mitre.org/data/definitions/652.html</reference>
</vuln_item_wasc_46>

<vuln_items>wasc_47</vuln_items>
<vuln_item_wasc_47>
	<alert>Yetersiz Seans Süre Dolumu</alert>
	<desc>Yetersiz Seans Süre Dolumu, web uygulamasının, saldırganın eski seans kimliğini veya yetkilendirme ID'sini kullanmasına izin vermesiyle meydana gelir. Yetersiz Seans Süre Dolumu, bir internet sitesinin kullanıcı seans belirteçlerinin çalınması veya yeniden kullanılması saldıranın şansını arttırır.

HTTP, durumsuz bir protokol olduğu için İnternet siteleri genellikle istekler arasında kullanıcıları benzersiz bir şekilde tanımlamak için çerezleri kullanırlar. Sonuç olarak tüm seans IDleri gizliliği, birden fazla kullanıcının aynı hesaba erişmesini engellemek için sağlanmalıdır. Çalınan seans ID'si, başka bir kullanıcının hesabını görüntülemek veya sahte işlem yapmak için kullanılabilir.

Seans süre olumu iki zaman aşımı türünden meydana gelir: inaktif ve mutlak. Mutlak zaman aşımı, seansın yeniden yetkilendirme olmadan geçerli olabileceği toplam süreyi tanımlar ve inaktif zaman aşımı ise seansın geçersiz kılınmasından önce izin verilen boş bekleme süresidir. Uygun seans dolumunun olmaması, belirli saldırıların başarı olasılığını arttırır. Uzun zaman kullanma süresi, saldırganların geçerli seans ID'sini başarılı olarak tahmin etmesini kolaylaştırır. Sona erme süresi ne kadar uzun olursa, eş zamanlı olarak herhangi bir zamanda açık oturumlar olacaktır. Oturumlar havuzu ne kadar büyükse, saldırganın rastgele tahmin edebileceği olasılık daha da yüksek olur. Kısa seans zaman aşımı, tokenin hemen kullanılmasına yardımcı olmasa da kısa zaman aşımı, tokenlerin geçerliyken yakalanmasını daha zor hale getirir.

Bir Web uygulaması, daha önceden tanımlanan boş bekleme süresi geçtikten sonra bir seansı geçersiz kılmalı ve çıkış yaparak kullanıcıya kendi seansının geçersiz olduğunu sağlamalıdır. Bu şekilde seans ID ömrünün mümkün olduğunca kısa tutulmasına yardımcı olunur ve birden fazla kişinin bilgisayara sınırsız fiziksel erişimi olan, paylaşılan ortamlarda bu uygulama gereklidir. Çıkış yap fonksiyonu kullanıcıya daima görünür olmalı, bir kullanıcının oturumunu açıkça geçersiz kılmalı ve oturum simgesinin tekrar kullanımına imkan tanımamalıdır.</desc>
	<solution>Seansların/kimliklerin son kullanım tarihlerinin belirlenmesi.</solution>
	<reference>http://projects.webappsec.org/Insufficient-Session-Expiration</reference>
	<reference>http://cwe.mitre.org/data/definitions/613.html</reference>
</vuln_item_wasc_47>

<vuln_items>wasc_48</vuln_items>
<vuln_item_wasc_48>
	<alert>Güvensiz Dizinleme</alert>
	<desc>Güvensiz dizinleme, web sitesinin veri gizliliği için bir tehdittir. Açık olarak erişilebilir olmaması gereken dosyalara erişimi olan internet sitesi içeriği endekslemesinin dosya ve içerik gibi bilgileri sızdırma potansiyeli vardır. Dizinleme işlemi sırasında, bu tür bilgiler, belirlenen bir saldırgan tarafından, genellikle arama motoruna yapılan bir dizi sorgu aracılığıyla daha sonra tekrar alınabilen (hiç de önemsiz olmasa da) dizin oluşturma işlemi tarafından toplanır ve saklanır. Saldırgan, arama moturunun güvenlik modelini bozmaz. Bu sebeple, bu saldırı çok inceliklidir ve algılanması ve tespit edilmesi çok zordur - saldırganın sorgularını mantıklı kullanıcı sorgularından ayırmak kolay değildir.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Insecure-Indexing</reference>
	<reference></reference>
</vuln_item_wasc_48>

<vuln_items>wasc_49</vuln_items>
<vuln_item_wasc_49>
	<alert>Yetersiz Parola Kurtarma</alert>
	<desc>Yetersiz Parola Kurtarma, bir web sitesi, saldırgana başka bir kullanıcının parolasını yasa dışı bir şekilde elde etmesine, değiştirmesine veya kurtarmasına izin verdiğinde gerçekleşir. Geleneksel web site kimlik doğrulama metodları, kullanıcının bir parola veya geçiş anahtarı belirlemesi ve onu hatırlamasına dayanır. Kullanıcı parolayı bilen tek kişi olmalıdır ve onu tam olarak hatırlamalıdır. Zaman geçtikçe kullanıcının parolasını hatırlama yeteneği kaybolur. Kullanıcı parola belirlemesini isteyen ortalama 20 siteyi ziyaret ettiğinde durum daha da karmaşıklaşıyor.  (RSA Anketi: http://news.bbc.co.uk/1/hi/technology/3639679.stm) Bunun için parola kurtarma, çevrimiçi kullanıcılara hizmetin önemli bir parçasıdır.

Otomatik parola kurtarma işlemlerine örnek olarak kullanıcıların üyelik aşamasının bir parçası olarak tanımlanan "gizli soru"ya cevap vermeleri gerekmektedir. Bu soru, önceden belirlenmiş sorular listesinden seçilebilir veya kullanıcıdan belirlemesi istenebilir. Kullanılmakta olan bir başka mekanizma ise kullanıcıya kayıt sırasında, parolasını hatırlamasında yardımcı olacak "ipucu" sunmaktır. Diğer mekanizmalar ise kullanıcılardan sosyal güvenlik numarası, ev adresi, posta numarası vb. gibi bazı kişisel bilgiler sağlamasını gerektirir kimliğini kanıtlaması için. Kullanıcı kimliğini kanıtladıktan sonra kurtarma sistemi, yeni bir parola görüntüleyecek veya e-posta gönderecektir.

Saldırgan kullanılan kurtarma mekanizmasını aşabilirse, internet sitesinin Yetersiz Şifre Kurtarma işlevi olduğu varsayılır. Bu -durum kurtarma için- kullanıcı kimliğini doğrulamak için gerekli bilgilerin ya kolay tahmin edilebilir ya da değiştirilebilir olmasından kaynaklanmaktadır. Şifre kurtarma sistemleri kaba kuvvet saldırıları, sistem zayıflıkları veya kolayca tahmin edilen gizli soruların kullanımıyla tehlikeye girebilir.</desc>
	<solution>Şifre kurtarma mekanizmasına kullanıcı tarafından sağlanan tüm girdilerin detaylı bir şekilde filtrelendiğinden ve doğruluğundan emin olun

Standart zayıf güvenlik soruları kullanmayın ve birden fazla güvenlik sorusu kullanın.

Make sure that there is throttling on the number of incorrect answers to a security question. Belirli sayıda (az sayıda) hatalı tahminden sonra şifre alma özelliğini devre dışı bırakın.

Şifreyi sıfırlamadan ve yeni şifreyi kayıtlı e-posta adresine göndermeden önce kullanıcıya güvenlik sorusunu sormayı gerekli kılın.

Kullanıcının şifre kurtarma mekanizmasına yeni şifrenin gönderileceği e-posta adresini asla kontrol etmesine izin vermeyin.

Orijinal parolayı göstermek yerine yeni bir geçici parola atayın.</solution>
	<reference>http://projects.webappsec.org/Insufficient-Password-Recovery</reference>
	<reference>http://cwe.mitre.org/data/definitions/640.html</reference>
</vuln_item_wasc_49>

</vulnerabilities>