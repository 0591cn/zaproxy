<?xml version="1.0" encoding="utf-8"?>
<vulnerabilities xmlns="http://tempuri.org/XMLSchemaOptions.xsd">

<vuln_items>wasc_1</vuln_items>
<vuln_item_wasc_1>
	<alert>Недостатня авторизація</alert>
	<desc>Недостатня автентифікація виникає, коли вебсайт дозволяє зловмиснику отримати доступ до конфіденційного вмісту або функціональних можливостей без необхідності належної автентифікації. Вебінструменти адміністрування є гарним прикладом вебсайтів, які надають доступ до конфіденційних функцій. Залежно від конкретного онлайн-ресурсу, ці вебпрограми не повинні бути напряму доступні без вимоги користувача належним чином підтвердити свою особу.

Щоб обійти налаштування автентифікації, деякі ресурси захищено шляхом "приховування" конкретного розташування та не пов'язування розташування з основним вебсайтом чи іншими у громадських місцях. Однак цей підхід є нічим іншим, як "Безпека через невідомість". Важливо зрозуміти, що навіть якщо ресурс невідомий зловмиснику, він все одно залишається доступним безпосередньо через певну URL-адресу. Конкретну URL-адресу можна виявити через метод прямого добору для пошуку звичайних файлів і каталогів (наприклад, /admin), повідомлень про помилку, журнали джерел переходу або документації, таких як файли довідки. Ці ресурси, незалежно від того, керуються вони вмістом чи функціональністю, мають бути належним чином захищені.</desc>
	<solution>Фаза: архітектура та дизайн
Використовуйте систему автентифікації або бібліотеку, таку як функція автентифікації OWASP ESAPI.</solution>
	<reference>http://projects.webappsec.org/Insufficient-Authentication</reference>
	<reference>http://cwe.mitre.org/data/definitions/287.html</reference>
	<reference>http://cwe.mitre.org/data/definitions/284.html</reference>
</vuln_item_wasc_1>

<vuln_items>wasc_2</vuln_items>
<vuln_item_wasc_2>
	<alert>Недостатня авторизація</alert>
	<desc>Недостатня авторизація виникає, коли програма не виконує адекватних перевірок авторизації, щоб переконатися, що користувач виконує функцію або отримує доступ до даних у спосіб, який узгоджується з політикою безпеки. Процедури авторизації мають забезпечувати виконання того, що дозволено робити користувачеві, службі чи програмі. Коли користувач автентифікований на вебсайті, це не обов’язково означає, що він повинен мати повний доступ до всього вмісту та функцій.

Недостатня авторизація функції

Багато програм надають різним користувачам різні функціональні можливості.
 Сайт новин дозволить користувачам переглядати новини, але не публікувати їх. Бухгалтерська система матиме різні дозволи для службовця з питань кредиторської заборгованості та працівника з питань дебіторської заборгованості. Недостатня авторизація функцій виникає, коли програма не перешкоджає користувачам отримати доступ до функціональних можливостей програми, порушуючи політику безпеки.

Яскравим прикладом стало зламування процесу подачі заявок у Гарвардську школу бізнесу у 2005 році. Помилка авторизації дозволила користувачам переглядати власні дані, хоча вони не повинні були мати доступ до цієї частини вебсайту.
 
Недостатня авторизація даних

Багато програм розкривають базові ідентифікатори даних в URL-адресі. Наприклад, під час доступу до медичної карти в системі можна мати таку URL-адресу:

http://example.com/RecordView?id=12345

Якщо програма не перевіряє, чи автентифікований користувач має права на читання, вона може показувати користувачеві дані, які користувач не повинен бачити.

Недостатня авторизація даних є більш поширеною, ніж недостатня авторизація функцій, оскільки програмісти зазвичай мають повні знання про функціональні можливості програми, але не завжди мають повний показ всіх даних, до яких програма матиме доступ. Програмісти часто мають жорсткий контроль над механізмами авторизації функцій, але покладаються на інші системи, такі як бази даних для виконання авторизації даних.</desc>
	<solution>Фази: Архітектура та Дизайн; Операція
Дуже ретельно керуйте налаштуванням, керуванням і обробкою привілеїв. Явно керуйте зонами довіри в програмному забезпеченні.

Фаза: Архітектура та Дизайн
Переконайтеся, що відповідна класифікація вбудована в проєктування системи, і що класифікація служить для забезпечення та подальшого посилення привілеїв розділення функції. Архітектори та дизайнери повинні покладатися на принцип найменших привілеїв, щоб вирішити, коли доцільно використовувати та відмовитися від системних привілеїв.</solution>
	<reference>http://projects.webappsec.org/Insufficient-Authorization</reference>
	<reference>http://cwe.mitre.org/data/definitions/284.html</reference>
	<reference>http://cwe.mitre.org/data/definitions/285.html</reference>
</vuln_item_wasc_2>

<vuln_items>wasc_3</vuln_items>
<vuln_item_wasc_3>
	<alert>Переповнення цілих чисел</alert>
	<desc>Переповнення цілого числа- це умова, що виникає, коли результат арифметичної операції, наприклад множення або додавання, перевищує максимальний розмір типу цілого числа, який використовується для його зберігання. Коли відбувається переповнення цілого числа, здається, що інтерпретоване значення "обернуло" максимальне значення та розпочалося знову з мінімального значення, подібно до годинника, який показує 13:00, вказуючи на 1:00.

Наприклад, 8-розрядне число зі знаком на більшості поширених комп'ютерних побудов має максимальне значення 127 і мінімальне значення -128. Якщо програміст зберігає значення 127 у такій змінній і додає до нього 1, результат має бути 128. Однак це значення перевищує максимальне для цього типу цілого числа, тому інтерпретоване значення буде  "розгорнуто" і стане -128.</desc>
	<solution>Фаза: Вимоги
Переконайтеся, що всі протоколи чітко визначені, щоб усю поведінку поза межами можна було легко ідентифікувати, і вимагають суворої відповідності протоколу.

Фаза: Вимоги
Використовуйте мову, яка не допускає виникнення цих слабких сторін, або надає конструкції, які полегшують уникнення цих слабких сторін.
Якщо можливо, виберіть мову або компілятор, який виконує автоматичну перевірку меж.

Фаза: Архітектура і Дизайн
Використовуйте перевірену бібліотеку чи структуру, які запобігають виникненню цієї слабкості або надають конструкції, які полегшують уникнення цієї слабкості.
Використовуйте бібліотеки або структури, які полегшують обробку чисел без неочікуваних наслідків.
Приклади включають безпечні пакети обробки цілих чисел, такі як Safelnt (C++) або IntegerLib (C або C++).

Фаза: Впровадження
Виконайте перевірку будь-якого числового введення, переконавшись, що воно знаходиться в очікуваному діапазоні. Переконайтеся, що вхідні дані відповідають як мінімальним, так і максимальним вимогам для очікуваного діапазону.
Використовуйте цілі числа без знаку, де це можливо. Це спрощує виконання перевірки працездатності для переповнень цілих чисел. Якщо необхідно використовувати цілі числа зі знаком, переконайтеся, що ваша перевірка діапазону містить як мінімальні, так і максимальні значення.

Фаза: Впровадження
Зрозумійте базове представлення вашої мови програмування та те, як воно взаємодіє з числовими розрахунками (CWE-681). Зверніть особливу увагу на розбіжності в розмірі байтів, точність, відмінності зі знаком/ без знаку, зріз, перетворення та приведення між типами, обчислення "не числа" та те, як ваша мова обробляє числа, які є занадто великими для свого основного представлення.
Також уважно враховуйте 32-бітні, 64-бітні та інші потенційні відмінності, які можуть вплинути на числове представлення.

Фаза: Впровадження
Уважно вивчіть попередження компілятора та усуньте потенційно критичні проблеми безпеки, такі як невідповідність знака/без знаку. Навіть якщо слабкість рідко вдається використати, один збій може призвести до зламу всієї системи.</solution>
	<reference>http://projects.webappsec.org/Integer-Overflows</reference>
	<reference>http://cwe.mitre.org/data/definitions/190.html</reference>
</vuln_item_wasc_3>

<vuln_items>wasc_4</vuln_items>
<vuln_item_wasc_4>
	<alert>Недостатній захист транспортного рівня</alert>
	<desc>Недостатній захист транспортного рівня
Недостатній рівень захисту транспортного рівня дозволяє комунікації бути відкритим для ненадійних третіх сторін, створюючи вектор атаки для компрометації вебпрограми та/або викрадення конфіденційної інформації. Вебсайти зазвичай використовують Secure Sockets Layer / Transport Layer Security (SSL/TLS) для забезпечення шифрування на транспортному рівні. Однак, якщо вебсайт не налаштовано на використання SSL/TLS і не налаштовано на належне використання SSL/TLS, вебсайт може бути вразливим до перехоплення та модифікації трафіку.
 
Відсутність шифрування транспортного рівня
Коли транспортний рівень не зашифрований, усі повідомлення між вебсайтом і клієнтом надсилаються у відкритому вигляді, що залишає його відкритим для перехоплення, введення та перенаправлення (також відомого як атака "людина посередині"/MITM). Зловмисник може пасивно перехопити зв’язок, отримавши доступ до будь-яких конфіденційних даних, які передаються, наприклад імен користувачів і паролів. Зловмисник також може активно вводити/вилучати вміст зі зв’язку, дозволяючи зловмиснику підробляти та пропускати інформацію, впроваджувати шкідливі сценарії або змусити клієнта отримати доступ до віддаленого ненадійного вмісту. Зловмисник також може перенаправити зв’язок таким чином, що вебсайт і клієнт більше не спілкуються один з одним, а натомість несвідомо спілкуються зі зловмисником у контексті іншої довіреної сторони.

Слабка підтримка шифру
Історично експорт високоякісної криптографії за межі Сполучених Штатів був обмежений. Через це вебсайти були налаштовані на підтримку слабких криптографічних параметрів для тих клієнтів, які були обмежені використанням лише слабких шифрів. Слабкі шифри вразливі до атак через відносну легкість їх зламу; менш ніж два тижні на звичайному домашньому комп’ютері та кілька секунд із використанням спеціального обладнання.
Сьогодні всі сучасні браузери та вебсайти використовують набагато надійніше шифрування, але деякі вебсайти все ще налаштовані на підтримку застарілих слабких шифрів. Через це зловмисник може змусити клієнта повернутися до слабшого шифру під час підключення до вебсайту, дозволяючи зловмиснику зламати слабке шифрування. З цієї причини сервер має бути налаштований на прийняття лише надійних шифрів і не надавання послуг будь-якому клієнту, який запитує використання слабшого шифру. Крім того, деякі вебсайти неправильно налаштовані на вибір слабшого шифру, навіть якщо клієнт підтримує набагато сильніший. OWASP пропонує посібник з тестування на наявність проблем з SSL/TLS, зокрема слабку підтримку шифрів і неправильну конфігурацію, а також інші ресурси та інструменти.</desc>
	<solution>Фаза: Вимоги
Чітко визначте, які дані чи ресурси є достатньо цінними, щоб їх можна було захистити за допомогою шифрування. Вимагайте, щоб будь-яка передача або зберігання цих даних або ресурсів використовувала добре перевірені алгоритми шифрування.

Фаза: Архітектура та дизайн
Використовуючи моделювання загроз або інші методи, припустіть, що ваші дані можуть бути скомпрометовані через окрему вразливість або слабкість, і визначте, де шифрування буде найбільш ефективним. Переконайтеся, що дані, які, на вашу думку, мають бути приватними, не були випадково розкриті через такі вразливості, як ненадійні дозволи (CWE-732).

Фаза: Архітектура та Дизайн
Переконайтеся, що шифрування інтегровано належним чином в макет системи, включаючи, але не обов'язково обмежуючись:
      Шифрування необхідне для зберігання або передачі особистих даних користувачів системи
      Шифрування необхідне для захисту самої системи від неавторизованого розголошення або втручання 
Визначте окремі потреби та контексти для шифрування:
      Односторонній (тобто лише користувач або одержувач повинен мати ключ). Цього можна досягти за допомогою криптографії з відкритим ключем або інших методів, в яких стороні, що шифрує (тобто програмному забезпеченню), не потрібно мати доступ до закритого ключа.
      Двостороннє (тобто шифрування може автоматично виконуватися від імені користувача, але ключ повинен бути доступним, щоб користувач міг автоматично відновити відкритий текст). Це вимагає зберігання приватного ключа у форматі, який може бути відновлений лише користувачем (або, можливо, операційною системою) у спосіб, який не може бути відновлений іншими.

Фаза: Архітектура та дизайн
Не розробляйте власні криптографічні алгоритми. Вони, швидше за все, будуть піддаватися атакам, які добре зрозумілі криптографам. Методи зворотного проєктування є зрілими. Якщо ваш алгоритм може бути скомпрометований, якщо зловмисники дізнаються, як він працює, тоді він особливо слабкий.

Фаза: Архітектура та дизайн
Виберіть добре перевірений алгоритм, який наразі вважається сильним серед експертів у цій галузі, і виберіть добре протестовані реалізації.
Наприклад, урядові системи США вимагають сертифікації за стандартом FIPS 140-2.
Як і у випадку з усіма криптографічними механізмами, вихідний код повинен бути доступний для аналізу.
Періодично перевіряйте, чи не використовуєте ви застарілу криптографію. Деякі старіші алгоритми, які колись вважалися такими, що потребують мільярд років обчислювального часу, тепер можуть бути зламані за кілька днів або годин. Сюди входять MD4, MD5, SHA1, DES та інші алгоритми, які колись вважалися надійними.

Фаза: Архітектура та дизайн
Розділіть вашу систему на "безпечні" області, де можна чітко окреслити межі довіри. Не дозволяйте конфіденційним даним виходити за межі довіри та завжди будьте обережні під час взаємодії з простором за межами безпечної зони.

Фази: Впровадження, архітектура та дизайн
Коли ви використовуєте схвалені в індустрії методи, ви повинні використовувати їх правильно. Не економте час, пропускаючи ресурсомісткі етапи (CWE-325). Ці кроки часто необхідні для запобігання поширеним атакам.

Фаза: Впровадження
Використовуйте угоди про імена та сильні типи, щоб легше виявляти, коли використовуються конфіденційні дані. Створюючи структури, об’єкти чи інші складні сутності, якомога більше розділяйте конфіденційні та неконфіденційні дані.
Це полегшує виявлення місць у коді, де використовуються незашифровані дані.</solution>
	<reference>http://projects.webappsec.org/Insufficient-Transport-Layer-Protection</reference>
	<reference>http://cwe.mitre.org/data/definitions/311.html</reference>
</vuln_item_wasc_4>

<vuln_items>wasc_5</vuln_items>
<vuln_item_wasc_5>
	<alert>Віддалене включення файлів</alert>
	<desc>Remote File Include (RFI) — це техніка атаки, яка застосовується для використання механізмів «динамічного охоплення файлів» у вебдодатках. Коли вебпрограми приймають введені користувачем дані (URL-адреса, значення параметра тощо) і передають їх у команди охоплення файлів, вебпрограму можуть обманом включити віддалені файли зі шкідливим кодом.

Майже всі структури вебдодатків підтримують охоплення файлів. Охоплення файлів в основному використовується для упакування загального коду в окремі файли, на які пізніше посилаються головні модулі програми. Коли вебдодаток посилається на файл охоплення, код у цьому файлі може бути виконано неявно або явно шляхом виклику певних процедур. Якщо вибір модуля для завантаження базується на елементах запиту HTTP, вебпрограма може бути вразливою до RFI.
Зловмисник може використовувати RFI для:
    * Запуск шкідливого коду на сервері: будь-який код у включених шкідливих файлах запускатиметься сервером. Якщо включення файлу не виконується за допомогою якоїсь оболонки, код в охоплених файлах виконується в контексті користувача сервера. Це може призвести до повного збою системи.
    * Запуск шкідливого коду на клієнтах: шкідливий код зловмисника може маніпулювати вмістом відповіді, надісланої клієнту. Зловмисник може вбудувати шкідливий код у відповідь, яка буде запущена клієнтом (наприклад, JavaScript для викрадення сесійних файлів cookie клієнта).

PHP особливо вразливий до RFI-атак через широке використання «файлових охоплень» у програмуванні PHP і через стандартні конфігурації сервера, які підвищують сприйнятливість до RFI-атак.</desc>
	<solution>Фаза: Архітектура та Дизайн
Якщо набір прийнятних об’єктів, наприклад імен файлів або URL-адрес, обмежений або відомий, створіть зіставлення з набору фіксованих вхідних значень (наприклад, числових ідентифікаторів) на фактичні імена файлів або URL-адреси та відхиліть усі інші вхідні дані.
Наприклад, ідентифікатор 1 може зіставлятися з "inbox.txt", а ідентифікатор 2 – з "profile.txt". Такі функції, як ESAPI AccessReferenceMap, надають цю можливість.

Фаза: Архітектура та Дизайн; Виконання
Запустіть свій код у "в'язниці" або подібному середовищі ізольованого програмного середовища, яке забезпечує суворі межі між обробкою та операційною системою. Це може фактично обмежити, до яких файлів можна отримати доступ у певному каталозі або до того, які команди може виконувати ваше програмне забезпечення.
Приклади на рівні ОС включають Unix chroot jail, AppArmor і SELinux. Загалом, керований код може забезпечити певний захист. Наприклад, java.io.FilePermission в Java SecurityManager дозволяє вказати обмеження на операції з файлами.
Це може бути неможливим рішенням, і воно обмежує вплив лише на операційну систему; решта вашої програми все ще може бути скомпрометована.
Будьте обережні, щоб уникнути CWE-243 та інших слабких місць, пов’язаних із в’язницями.
Для PHP транслятор пропонує такі обмеження, як відкритий базовий каталог або безпечний режим, що може ускладнити зловмиснику вихід із програми. Також розгляньте Suhosin, посилене розширення PHP, яке містить різні параметри, які вимикають деякі з найнебезпечніших функцій PHP.

Фаза: Впровадження
Припустимо, що всі введені дані є шкідливими. Використовуйте стратегію перевірки вхідних даних «прийняти наперед хороші», тобто використовуйте дозволений список прийнятних вхідних даних, які чітко відповідають специфікаціям. Відхиліть будь-які вхідні дані, які не повністю відповідають специфікаціям, або перетворіть їх на щось, що відповідає. Не покладайтеся виключно на пошук зловмисних або некоректних даних (тобто не покладайтеся на список заборонених). Однак списки заборони можуть бути корисними для виявлення потенційних атак або визначення того, які вхідні дані є настільки неправильними, що їх слід відхилити.
Виконуючи перевірку вхідних даних, враховуйте всі потенційно важливі властивості, включаючи довжину, тип вхідних даних, повний діапазон прийнятних значень, відсутні або додаткові вхідні дані, синтаксис, узгодженість пов’язаних полів і відповідність бізнес-правилам. Як приклад логіки бізнес-правил, «човен» може бути синтаксично допустимим, оскільки містить лише буквено-цифрові символи, але він недійсний, якщо ви очікуєте такі кольори, як «червоний» або «синій».
Для імен файлів використовуйте суворі дозволені списки, які обмежують набір символів, який буде використовуватися. Якщо це можливо, дозвольте лише один "." символ у назві файлу, щоб уникнути недоліків, таких як CWE-23, і виключити роздільники каталогів, такі як "/", щоб уникнути CWE-36. Використовуйте дозволений список дозволених розширень файлів, що допоможе уникнути CWE-434.

Фаза: Архітектура та дизайн; Виконання
Якщо це можливо, зберігайте бібліотечні, охоплені та службові файли поза коренем вебдокумента. В іншому випадку зберігайте їх в окремому каталозі та використовуйте можливості керування доступом вебсервера, щоб запобігти зловмисникам безпосередньо запитувати їх. Однією з поширених практик є визначення фіксованої константи в кожній програмі виклику, а потім перевірка існування константи в бібліотеці/файлі включення; якщо константа не існує, це означає, що файл був запрошений безпосередньо, і його можна негайно завершити.
Це значно зменшує ймовірність того, що зловмисник зможе обійти будь-які механізми захисту, які є в базовій програмі, але не у файлах включення. Це також зменшить вашу поверхню атаки.

Фаза: Архітектура та Дизайн; Впровадження
Зрозумійте всі потенційні області, куди ненадійні дані можуть потрапити у ваше програмне забезпечення: параметри чи аргументи, файли cookie, усе, що зчитується з мережі, змінні середовища, зворотні пошуки DNS, результати запитів, заголовки запитів, компоненти URL-адрес, електронна пошта, файли, бази даних і будь-які зовнішні системи, які надають дані програмі. Пам’ятайте, що такі вхідні дані можна отримати опосередковано через виклики API.
Багато проблем із включенням файлів виникають через те, що програміст припустив, що певні вхідні дані не можна змінити, особливо для файлів cookie та компонентів URL-адреси.</solution>
	<reference>http://projects.webappsec.org/Remote-File-Inclusion</reference>
	<reference>http://cwe.mitre.org/data/definitions/98.html</reference>
</vuln_item_wasc_5>

<vuln_items>wasc_6</vuln_items>
<vuln_item_wasc_6>
	<alert>Рядок форматування</alert>
	<desc>Атаки рядків форматування змінюють потік програми, використовуючи функції бібліотеки форматування рядків для доступу до іншого простору пам’яті. Вразливі місця виникають, коли надані користувачем дані використовуються безпосередньо як рядок форматування для певних функцій C/C++ (наприклад, fprintf, printf, sprintf, setproctitle, syslog тощо).

Якщо зловмисник передає рядок форматування, що складається з символів перетворення printf (наприклад, "%f", "%p", "%n" тощо) як значення параметра до вебпрограми, він може:
    * Виконувати довільний код на сервері
    * Читати значення зі стека
    * Спричиняти помилки сегментації / збої програмного забезпечення

Атаки рядку форматування пов’язані з іншими атаками в класифікації загроз: переповнення буфера та переповнення цілого числа. Усі три засновані на своїй здатності маніпулювати пам’яттю або її інтерпретацією таким чином, щоб сприяти досягненню мети зловмисника.</desc>
	<solution>Фаза: Вимоги
Виберіть мову, яка не має цього дефекту.

Фаза: Впровадження
Переконайтеся, що всім функціям рядка форматування передається статичний рядок, який не може контролювати користувач, і що відповідна кількість аргументів також завжди надсилається цій функції. Якщо можливо, використовуйте функції, які не підтримують оператор %n у рядках форматування.
Збірка: Зверніть увагу на попередження компіляторів і компонувальників, оскільки вони можуть попередити вас про неправильне використання.
</solution>
	<reference>http://projects.webappsec.org/Format-String</reference>
	<reference>http://cwe.mitre.org/data/definitions/134.html</reference>
</vuln_item_wasc_6>

<vuln_items>wasc_7</vuln_items>
<vuln_item_wasc_7>
	<alert>Переповнення буферу</alert>
	<desc>Переповнення буфера — це недолік, який виникає, коли в блок пам’яті або буфер записується більше даних, ніж призначено для зберігання. Використання переповнення буфера дозволяє зловмиснику змінювати частини адресного простору цільового процесу. Цю здатність можна використовувати для багатьох цілей, зокрема:
    * Контролювати виконання процесу
    * Щоб збити процес
    * Змінити внутрішні змінні

Метою зловмисника майже завжди є контроль за виконанням цільового процесу. Це досягається шляхом визначення покажчика функції в пам'яті, який можна змінити, прямо чи опосередковано, за допомогою переповнення. Коли такий вказівник використовується програмою для керування виконанням програми через інструкцію переходу або виклику, буде використано розташування інструкції, надане зловмисником, таким чином дозволяючи зловмисникові контролювати процес.

У багатьох випадках покажчик функції змінюється, щоб посилатися на місце, де зловмисник розмістив зібрані інструкції для конкретної машини. Ці інструкції зазвичай називають шелл-кодом, оскільки зловмисники часто хочуть створити середовище командного рядка або оболонку в контексті запущеного процесу.

Переповнення буфера найчастіше пов’язане з програмним забезпеченням, написаним на мовах програмування C і C++ через їх широке використання та здатність виконувати прямі маніпуляції з пам’яттю за допомогою звичайних конструкцій програмування. Однак слід підкреслити, що переповнення буфера може існувати в будь-якому середовищі програмування, де дозволено пряме маніпулювання пам’яттю через недоліки в компіляторі, бібліотеках виконання або особливостях самої мови.
</desc>
	<solution>Фаза: Вимоги
Використовуйте мову, яка не допускає виникнення цих слабких сторін, або надає конструкції, які полегшують уникнення цих слабких сторін.
Наприклад, багато мов, які здійснюють власне керування пам’яттю, такі як Java і Perl, не підлягають переповненню буфера. Інші мови, такі як Ada та C#, зазвичай забезпечують захист від переповнення, але захист може бути відключений програмістом.
Майте на увазі, що інтерфейс мови до рідного коду все ще може зазнавати переповнень, навіть якщо сама мова теоретично безпечна.

Фаза: Архітектура і Дизайн
Використовуйте перевірену бібліотеку чи структуру, які запобігають виникненню цієї слабкості або надають конструкції, які полегшують уникнення цієї слабкості.
Приклади включають бібліотеку Safe C String Library (SafeStr) від Messier і Viega та бібліотеку Strsafe.h від Microsoft. Ці бібліотеки забезпечують безпечніші версії функцій обробки рядків, схильних до переповнення. Це не повне рішення, оскільки багато переповнень буфера не пов’язані з рядками.

Фаза: Збірка та Компіляція
Запустіть або скомпілюйте програмне забезпечення за допомогою функцій або розширень, які автоматично забезпечують механізм захисту, який пом’якшує або усуває переповнення буфера.
Наприклад, певні компілятори та розширення забезпечують механізми автоматичного виявлення переповнення буфера, вбудовані в скомпільований код. Приклади включають прапор Microsoft Visual Studio /GS, прапор GCC FORTIFY SOURCE Fedora/Red Hat, StackGuard і ProPolice.

Фаза: Впровадження
Розгляньте дотримання наступних правил під час розподілу та керування пам’яттю програми:
      Двічі переконайтеся, що ваш буфер такий великий, як ви вказали.
      Використовуючи функції, які приймають певну кількість байтів для копіювання, наприклад strncpy(), майте на увазі, що якщо розмір буфера призначення дорівнює розміру буфера джерела, він може не завершувати рядок NULL.
      Перевірте межі буфера, якщо ця функція викликається в циклі, і переконайтеся, що вам не загрожує запис за межі виділеного простору.
      Якщо необхідно, обріжте всі вхідні рядки до прийнятної довжини перед тим, як передати їх функціям копіювання та злиття.

Фаза: Виконання
Використовуйте таку функцію, як рандомізація адресного простору (ASLR).

Фаза: Виконання

Використовуйте ЦП і операційну систему, які пропонують Data Execution Protection (NX) або її еквівалент.

Замініть функції необмеженого копіювання на аналогічні функції, які підтримують аргументи довжини, наприклад strcpy на strncpy. Створіть їх, якщо вони недоступні.
</solution>
	<reference>http://projects.webappsec.org/Buffer-Overflow</reference>
	<reference>http://cwe.mitre.org/data/definitions/119.html</reference>
</vuln_item_wasc_7>

<vuln_items>wasc_8</vuln_items>
<vuln_item_wasc_8>
	<alert>Міжсайтовий сценарій</alert>
	<desc>Міжсайтовий сценарій (XSS) — це техніка атаки, яка включає відтворення наданого зловмисником коду в екземпляр вебпереглядача користувача. Екземпляр браузера може бути стандартним клієнтом веббраузера або об’єктом браузера, вбудованим у програмний продукт, такий як браузер у WinAmp, програма для читання RSS або клієнт електронної пошти. Сам код зазвичай пишеться на HTML/JavaScript, але також може поширюватися на VBScript, ActiveX, Java, Flash або будь-яку іншу технологію, що підтримується браузером.
Коли зловмисник змушує браузер користувача виконувати його/її код, код запускатиметься в контексті безпеки (або зоні) вебсайту хостингу. З цим рівнем привілеїв код має можливість читати, змінювати та передавати будь-які конфіденційні дані, доступні браузеру. Користувач із міжсайтовим сценарієм може отримати його/її обліковий запис (викрадення файлів cookie), його вебпереглядач буде перенаправлено в інше місце або, можливо, буде показано шахрайський вміст вебсайту, який вони відвідують. Міжсайтові скриптові атаки по суті підривають довірчі стосунки між користувачем і вебсайтом. Програми, що використовують екземпляри об’єктів браузера, які завантажують вміст із файлової системи, можуть виконувати код у зоні локального комп’ютера, що дозволяє компрометувати систему.

Існує три типи міжсайтових скриптових атак: непостійні, постійні та на основі DOM.
Непостійні атаки та атаки на основі DOM вимагають від користувача або переходу за спеціально створеним посиланням, доповненим шкідливим кодом, або відвідування шкідливої вебсторінки, що містить вебформу, розміщення якої на вразливому сайті спричиняє атаку. Використання шкідливої форми часто відбувається, коли вразливий ресурс приймає лише HTTP POST запити. У такому випадку форма може бути надіслана автоматично, без відома жертви, наприклад, за допомогою JavaScript. Після натискання зловмисного посилання або надсилання зловмисної форми корисне навантаження XSS буде показано назад і буде інтерпретовано браузером користувача та виконано. Інший спосіб надсилання майже довільних запитів (GET і POST) - це використання вбудованого клієнта, наприклад, Adobe Flash.
Постійні атаки відбуваються, коли шкідливий код надсилається на вебсайт, де він зберігається протягом певного часу. Прикладами улюблених цілей зловмисників часто є повідомлення на дошках оголошень, повідомлення вебпошти та програмне забезпечення для вебчатів. Користувачеві, який нічого не підозрює, не потрібно взаємодіяти з будь-яким додатковим сайтом або посиланням, наприклад, сайтом зловмисника або шкідливим посиланням, надісланим електронною поштою, достатньо просто переглянути вебсторінку, що містить код.</desc>
	<solution>Фаза: Архітектура і Дизайн
Використовуйте перевірену бібліотеку чи структуру, які запобігають виникненню цієї слабкості або надають конструкції, які полегшують уникнення цієї слабкості.
Приклади бібліотек і фреймворків, які спрощують створення правильно закодованого виводу, включають бібліотеку Microsoft Anti-XSS, модуль кодування OWASP ESAPI та Apache Wicket.

Фаза: Впровадження; Архітектура та Дизайн
Зрозумійте контекст, у якому використовуватимуться ваші дані, і очікуване кодування. Це особливо важливо під час передачі даних між різними компонентами або під час створення вихідних даних, які можуть містити кілька кодувань одночасно, наприклад вебсторінок або поштових повідомлень, що складаються з кількох частин. Вивчіть усі очікувані протоколи зв’язку та представлення даних, щоб визначити необхідні стратегії кодування.
Для будь-яких даних, які будуть виведені на іншу вебсторінку, особливо будь-яких даних, отриманих із зовнішніх джерел, використовуйте відповідне кодування для всіх символів, які не є алфавітно-цифровими.
Зверніться до шпаргалки щодо запобігання XSS, щоб дізнатися більше про типи кодування та екранування, які потрібні.

Фаза: Архітектура та Дизайн
Для будь-яких перевірок безпеки, які виконуються на стороні клієнта, переконайтеся, що ці перевірки дублюються на стороні сервера, щоб уникнути CWE-602. Зловмисники можуть обійти перевірки на стороні клієнта, змінивши значення після виконання перевірок або змінивши клієнта, щоб повністю видалити перевірки на стороні клієнта. Потім ці змінені значення будуть надіслані на сервер.

Якщо доступно, використовуйте структуровані механізми, які автоматично забезпечують поділ між даними та кодом. Ці механізми можуть автоматично забезпечити відповідне цитування, кодування та перевірку, замість того, щоб покладатися на те, що розробник надасть цю можливість у кожній точці, де генерується результат.

Фаза: Впровадження
Для кожної створеної вебсторінки використовуйте та вкажіть кодування символів, наприклад ISO-8859-1 або UTF-8. Якщо кодування не вказано, веббраузер може вибрати інше кодування, вгадавши, яке кодування насправді використовується вебсторінкою. Це може призвести до того, що веббраузер розглядатиме певні послідовності як особливі, відкриваючи клієнта для непомітних атак XSS. Перегляньте CWE-116, щоб дізнатися більше про попередження, пов’язані з кодуванням/екрануванням.

Щоб пом’якшити атаки XSS на сеансовий файл cookie користувача, установіть для файлу cookie сеансу значення HttpOnly. У браузерах, які підтримують функцію HttpOnly (наприклад, новіші версії Internet Explorer і Firefox), цей атрибут може запобігти доступу до файлів cookie сеансу користувача для зловмисних сценаріїв на стороні клієнта, які використовують document.cookie. Це не повне рішення, оскільки HttpOnly підтримується не всіма браузерами. Що ще важливіше, XMLHTTPRequest та інші потужні технології браузера забезпечують доступ для читання заголовків HTTP, включаючи заголовок Set-Cookie, у якому встановлено прапорець HttpOnly.

Припустимо, що всі вхідні дані зловмисні. Використовуйте стратегію перевірки вхідних даних «прийняти наперед хороші», тобто використовуйте дозволений список прийнятних вхідних даних, які чітко відповідають специфікаціям. Відхиліть будь-які вхідні дані, які не повністю відповідають специфікаціям, або перетворіть їх на щось, що відповідає. Не покладайтеся виключно на пошук зловмисних або некоректних даних (тобто не покладайтеся на список заборонених). Однак списки заборони можуть бути корисними для виявлення потенційних атак або визначення того, які вхідні дані є настільки неправильними, що їх слід відхилити.

Виконуючи перевірку вхідних даних, враховуйте всі потенційно важливі властивості, включаючи довжину, тип вхідних даних, повний діапазон прийнятних значень, відсутні або додаткові вхідні дані, синтаксис, узгодженість пов’язаних полів і відповідність бізнес-правилам. Як приклад логіки бізнес-правил, «човен» може бути синтаксично допустимим, оскільки містить лише буквено-цифрові символи, але він недійсний, якщо ви очікуєте такі кольори, як «червоний» або «синій».

Переконайтеся, що ви виконуєте перевірку введених даних у чітко визначених інтерфейсах програми. Це допоможе захистити програму, навіть якщо компонент повторно використано або переміщено в інше місце.
	</solution>
	<reference>http://projects.webappsec.org/Cross-Site-Scripting</reference>
	<reference>http://cwe.mitre.org/data/definitions/79.html</reference>
</vuln_item_wasc_8>

<vuln_items>wasc_9</vuln_items>
<vuln_item_wasc_9>
	<alert>Підробка запиту зі сторони сервера</alert>
	<desc>Підробка запиту зі сторони сервера– це атака, яка передбачає примушення жертви надіслати HTTP-запит до цільового призначення без її відома чи наміру, щоб виконати дію від імені жертви. Основна причина полягає в тому, що функція програми використовує передбачувані дії URL/форми повторюваним способом. Зміст атаки полягає в тому, що CSRF використовує довіру користувача до вебсайту. Навпаки, сценарій зі сторони сервера (XSS) використовує довіру користувача до вебсайту. Як і XSS, атаки CSRF не обов’язково є міжсайтовими, але вони можуть бути такими. Cross-site request forgery is also known as CSRF, XSRF, one-click attack, session riding, confused deputy, and sea surf.

Атаки CSRF ефективні в ряді ситуацій, зокрема:
    * Жертва має активний сеанс на цільовому сайті.
    * Жертва аутентифікується за допомогою HTTP-автентифікації на цільовому сайті.
    * Жертва знаходиться в тій же локальній мережі, що й цільовий сайт.

CSRF в основному використовувався для виконання дії проти цільового сайту з використанням привілеїв жертви, але нещодавно були виявлені методи розкриття інформації шляхом отримання доступу до відповіді. Ризик розголошення інформації різко зростає, коли цільовий сайт уразливий до XSS, оскільки XSS можна використовувати як платформу для CSRF, дозволяючи атаці діяти в межах політики того самого джерела.</desc>
	<solution>Фаза: Архітектура і Дизайн
Використовуйте перевірену бібліотеку чи структуру, які запобігають виникненню цієї слабкості або надають конструкції, які полегшують уникнення цієї слабкості.
Наприклад, використовуйте пакети захисту від CSRF, такі як OWASP CSRFGuard.

Фаза: Впровадження
Переконайтеся, що у вашій програмі немає проблем зі сценаріями зі сторони сервера, оскільки більшість засобів захисту CSRF можна обійти за допомогою сценарію, керованого зловмисником.

Фаза: Архітектура та Дизайн
Створіть унікальний одноразовий ідентифікатор для кожної форми, помістіть одноразовий ідентифікатор у форму та перевірте його після отримання форми. Переконайтеся, що одноразовий ідентифікатор не є передбачуваним (CWE-330).
Зауважте, що це можна обійти за допомогою XSS.

Визначити особливо небезпечні операції. Коли користувач виконує небезпечну операцію, надішліть окремий запит на підтвердження, щоб переконатися, що користувач мав намір виконати цю операцію.
Зауважте, що це можна обійти за допомогою XSS.

Використовуйте елемент управління сеансами ESAPI.
Цей елемент керування включає компонент для CSRF.

Не використовуйте метод GET для запитів, які ініціюють зміну стану.

Фаза: Впровадження
Перевірте заголовок HTTP Referer, щоб перевірити, чи запит походить з очікуваної сторінки. Це може порушити законні функції, оскільки користувачі або проксі-сервери можуть вимкнути надсилання Referer з міркувань конфіденційності.</solution>
	<reference>http://projects.webappsec.org/Cross-Site-Request-Forgery</reference>
	<reference>http://cwe.mitre.org/data/definitions/352.html</reference>
</vuln_item_wasc_9>

<vuln_items>wasc_10</vuln_items>
<vuln_item_wasc_10>
	<alert>Відмова в обслуговуванні</alert>
	<desc>Відмова в обслуговуванні (DoS) - це техніка атаки з метою перешкодити вебсайту обслуговувати нормальну діяльність користувачів. DoS-атаки, які зазвичай легко застосовуються на мережевому рівні, також можливі на рівні застосунків. Ці зловмисні атаки можуть бути успішними завдяки позбавленню системи критичних ресурсів, використанню вразливостей або зловживанню функціоналом.

Часто DoS-атаки намагаються поглинути всі доступні системні ресурси вебсайту, такі як: ЦП, пам'ять, дисковий простір тощо. Коли будь-який з цих критично важливих ресурсів досягає повного використання, вебсайт, як правило, стає недоступним.

Оскільки сучасні середовища вебзастосунків включають вебсервер, сервер баз даних і сервер аутентифікації, DoS-атаки на рівні застосунків можуть бути спрямовані на кожен з цих незалежних компонентів. На відміну від DoS на мережевому рівні, де потрібна велика кількість спроб з'єднання, DoS на рівні застосунків є набагато простішим завданням.</desc>
	<solution>Фаза: Архітектура та дизайн

Розробіть механізми дроселювання в архітектуру системи. Найкращий захист - обмежити кількість ресурсів, які може витратити несанкціонований користувач. Надійна модель автентифікації та контролю доступу допоможе в першу чергу запобігти таким атакам. Застосунок для входу повинен бути максимально захищений від DoS-атак. Обмеження доступу до бази даних, можливо, шляхом кешування наборів результатів, може допомогти мінімізувати витрачені ресурси. Щоб ще більше обмежити потенціал DoS-атаки, розгляньте можливість відстеження швидкості запитів, отриманих від користувачів, і блокування запитів, які перевищують певний поріг швидкості.

Пом'якшення наслідків атак на вичерпання ресурсів вимагає, щоб цільова система або
      розпізнала атаку і заборонила користувачеві подальший доступ на певний проміжок часу, або
      рівномірно гальмувала всі запити, щоб ускладнити споживання ресурсів швидше, ніж вони можуть бути знову звільнені. 

Перше з цих рішень є проблемою саме по собі, оскільки воно може дозволити зловмисникам запобігти використанню системи певним дійсним користувачем. Якщо зловмисник видає себе за дійсного користувача, він може заборонити користувачеві доступ до відповідного сервера.

Друге рішення просто важко ефективно впровадити - і навіть якщо це зроблено належним чином, воно не забезпечує повного розв'язання проблеми. Це просто робить атаку більш ресурсомісткою для зловмисника.

Переконайтеся, що протоколи мають конкретні обмеження щодо масштабу.

Фаза: Впровадження
Переконайтеся, що всі збої в розподілі ресурсів переводять систему в безпечний стан.</solution>
	<reference>http://projects.webappsec.org/Denial-of-Service</reference>
	<reference>http://cwe.mitre.org/data/definitions/400.html</reference>
</vuln_item_wasc_10>

<vuln_items>wasc_11a</vuln_items>
<vuln_item_wasc_11a>
	<alert>Brute Forcing Log-in Credentials</alert>
	<desc>Атака прямим добором - це метод визначення невідомого значення за допомогою автоматизованого процесу перебору великої кількості можливих значень. Атака використовує той факт, що ентропія значень менша, ніж сприймається. Наприклад, хоча 8-символьний буквено-цифровий пароль може мати 2,8 трильйона можливих значень, багато людей вибирають свої паролі з набагато меншої підмножини, що складається з поширених слів і термінів.

Найпоширенішим типом атаки прямого добору у вебзастосунках є атака на облікові дані для входу в систему. Оскільки користувачам потрібно запам'ятовувати паролі, вони часто вибирають для паролів слова або фрази, які легко запам'ятовуються, що робить атаку повного перебору корисною з використанням словника. Таку атаку зі спробою входу в систему з використанням великого списку слів і фраз як потенційних паролів, часто називають "атакою за списком слів" або "атакою за словником". Спроби паролів можуть також включати варіації слів, які часто зустрічаються в паролях, наприклад, створені шляхом заміни "o" на "0" та "i" на "1", а також особисту інформацію, зокрема імена членів сім'ї, дати народження та номери телефонів.
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Brute-Force</reference>
	<reference>TBA</reference>
</vuln_item_wasc_11a>

<vuln_items>wasc_11b</vuln_items>
<vuln_item_wasc_11b>
	<alert>Ідентифікатори сеансів перебору</alert>
	<desc>Атака прямим добором - це метод визначення невідомого значення за допомогою автоматизованого процесу перебору великої кількості можливих значень. Атака використовує той факт, що ентропія значень менша, ніж сприймається. Наприклад, хоча 8-символьний буквено-цифровий пароль може мати 2,8 трильйона можливих значень, багато людей вибирають свої паролі з набагато меншої підмножини, що складається з поширених слів і термінів.

Since HTTP is a stateless protocol, in order to maintain state web applications need to ensure that a session identifier is sent by the browser with each request. Ідентифікатор сеансу найчастіше зберігається в HTTP-файлі cookie або URL-адресі. Використовуючи атаку прямого добору, зловмисник може вгадати ідентифікатор сеансу іншого користувача. Це може призвести до того, що зловмисник видаватиме себе за користувача, отримуватиме особисту інформацію та виконуватиме дії від імені користувача.
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Brute-Force</reference>
	<reference>TBA</reference>
</vuln_item_wasc_11b>

<vuln_items>wasc_11c</vuln_items>
<vuln_item_wasc_11c>
	<alert>Brute Forcing Directories and Files</alert>
	<desc>Атака прямим добором - це метод визначення невідомого значення за допомогою автоматизованого процесу перебору великої кількості можливих значень. Атака використовує той факт, що ентропія значень менша, ніж сприймається. Наприклад, хоча 8-символьний буквено-цифровий пароль може мати 2,8 трильйона можливих значень, багато людей вибирають свої паролі з набагато меншої підмножини, що складається з поширених слів і термінів.

Коли файли знаходяться в каталогах, які обслуговуються вебсервером, але ніде не пов'язані між собою, для доступу до них потрібно знати ім'я файлу. У деяких випадках ці файли були залишені помилково: наприклад, файл резервної копії, автоматично створений при редагуванні файлу, або залишки старішої версії вебзастосунку. In other cases files are intentionally left unlinked as a "security by obscurity" mechanism allowing only people who know the file names to access them.

Атака повного перебору намагається знайти незв'язаний файл, намагаючись отримати доступ до великої кількості файлів. Список можливих імен файлів може бути взятий зі списку відомих потенційних файлів або на основі варіантів видимих файлів на вебсайті. More information on brute forcing directories and files can be found in the associated vulnerability, predictable resource location.
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Brute-Force</reference>
	<reference>TBA</reference>
</vuln_item_wasc_11c>

<vuln_items>wasc_11d</vuln_items>
<vuln_item_wasc_11d>
	<alert>Brute Forcing Credit Card Information</alert>
	<desc>Атака прямим добором - це метод визначення невідомого значення за допомогою автоматизованого процесу перебору великої кількості можливих значень. Атака використовує той факт, що ентропія значень менша, ніж сприймається. Наприклад, хоча 8-символьний буквено-цифровий пароль може мати 2,8 трильйона можливих значень, багато людей вибирають свої паролі з набагато меншої підмножини, що складається з поширених слів і термінів.

Shopping online with stolen credit cards usually requires information in addition to the credit card number, most often the CVV/SCS and/or expiration date. Шахрай може володіти номером викраденої кредитної картки без додаткової інформації. Наприклад, CVV або CSC не друкується на картці та не зберігається на магнітній смузі, тому він не може бути зчитаний механічними або магнітними пристроями для зчитування кредитних карток.

Для того, щоб заповнити відсутню інформацію, хакер може вгадати відсутню інформацію за допомогою методу «грубої сили», перебираючи всі можливі значення.
    * Вгадування CVV або CSC потребує лише 1000 або 10000 спроб, оскільки номер складається лише з 3 або 4 цифр, залежно від типу картки.
    * Щоб вгадати термін придатності, потрібно лише кілька десятків спроб.
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Brute-Force</reference>
	<reference>TBA</reference>
</vuln_item_wasc_11d>

<vuln_items>wasc_12</vuln_items>
<vuln_item_wasc_12>
	<alert>Підміна вмісту</alert>
	<desc>Підміна вмісту - це метод атаки, який дозволяє зловмиснику впровадити шкідливе корисне навантаження, яке потім видається за легальний вміст вебзастосунку.
 
Підміна лише текстового вмісту
Поширеним підходом до динамічного створення сторінок є передача тіла сторінки або його частин через значення рядка запиту. Такий підхід поширений на сторінках з помилками або на сайтах, що надають статті чи новини. The content specified in this parameter is later reflected into the page to provide the content for the page.
 
Markup Reflected Content Spoofing
Some web pages are served using dynamically built HTML content sources. For example, the source location of a frame <frame src="http://foo.example/file.html"/>) could be specified by a URL parameter value. (http://foo.example/page?frame_src=http://foo.example/file.html). Зловмисник може замінити значення параметра "frame_src" на "frame_src=http://attacker.example/spoof.html". Unlike redirectors, when the resulting web page is served the browser location bar visibly remains under the user expected domain (foo.example), but the foreign data (attacker.example) is shrouded by legitimate content.

Specially crafted links can be sent to a user via e-mail, instant messages, left on bulletin board postings, or forced upon users by a Cross-site Scripting attack. Якщо зловмисник змусить користувача відвідати вебсторінку, позначену його шкідливою URL-адресою, користувач вважатиме, що він переглядає автентичний контент з одного місця, хоча це не так. Користувачі неявно довірятимуть підробленому контенту, оскільки в рядку місцезнаходження браузера відображається http://foo.example, тоді як насправді HTML-фрейм, що лежить в основі, посилається на http://attacker.example.

Ця атака використовує довірчі стосунки, встановлені між користувачем і вебсайтом. Цей метод використовувався для створення фальшивих вебсторінок, включаючи форми для входу в систему, спотворення, фальшиві пресрелізи тощо.
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Content-Spoofing</reference>
	<reference>TBA</reference>
</vuln_item_wasc_12>

<vuln_items>wasc_13</vuln_items>
<vuln_item_wasc_13>
	<alert>Витік інформації</alert>
	<desc>Витік інформації - це вразливість програми, коли програма розкриває конфіденційні дані, такі як технічні деталі вебзастосунку, середовище або дані користувача. Конфіденційні дані можуть бути використані зловмисником для експлуатації цільового вебзастосунку, його хостингової мережі або користувачів. Therefore, leakage of sensitive data should be limited or prevented whenever possible. Information Leakage, in its most common form, is the result of one or more of the following conditions: A failure to scrub out HTML/Script comments containing sensitive information, improper application or server configurations, or differences in page responses for valid versus invalid data.

Failure to scrub HTML/Script comments prior to a push to the production environment can result in the leak of sensitive, contextual, information such as server directory structure, SQL query structure, and internal network information. Often a developer will leave comments within the HTML and/or script code to help facilitate the debugging or integration process during the pre-production phase. Хоча немає ніякої шкоди в тому, щоб дозволити розробникам включати вбудовані коментарі до контенту, який вони розробляють, всі ці коментарі слід видаляти перед публічним випуском контенту.

Номери версій програмного забезпечення та докладні повідомлення про помилки (наприклад, номери версій ASP.NET) є прикладами неправильних конфігурацій сервера. Ця інформація корисна для зловмисника, оскільки надає детальне уявлення про фреймворк, мови або вбудовані функції, що використовуються вебзастосунком. Більшість конфігурацій серверів за замовчуванням надають номери версій програмного забезпечення та докладні повідомлення про помилки для налагодження та усунення несправностей. Можна внести зміни до конфігурації, щоб вимкнути ці функції, запобігаючи відображенню цієї інформації.

Сторінки, які надають різні відповіді залежно від достовірності даних, також можуть призвести до витоку інформації; зокрема, коли дані, які вважаються конфіденційними, стають доступними в результаті дизайну вебзастосунку. Examples of sensitive data includes (but is not limited to): account numbers, user identifiers (Drivers license number, Passport number, Social Security Numbers, etc.) and user-specific information (passwords, sessions, addresses). Витік інформації в цьому контексті стосується витоку ключових даних користувача, які вважаються конфіденційними або секретними, і які не повинні бути доступними для огляду навіть самому користувачеві. Номери кредитних карток та інша суворо регульована інформація є яскравими прикладами даних користувачів, які потребують додаткового захисту від витоку, навіть за наявності належного шифрування та контролю доступу.</desc>
	<solution>Розділіть вашу систему на "безпечні" зони, де можна чітко окреслити межі довіри. Не дозволяйте конфіденційним даним виходити за межі довіри та завжди будьте обережні під час взаємодії з простором за межами безпечної зони.</solution>
	<reference>http://projects.webappsec.org/Information-Leakage</reference>
	<reference>http://cwe.mitre.org/data/definitions/200.html</reference>
</vuln_item_wasc_13>

<vuln_items>wasc_14</vuln_items>
<vuln_item_wasc_14>
	<alert>Неправильна конфігурація сервера</alert>
	<desc>Атаки на неправильну конфігурацію сервера використовують слабкі місця в конфігурації вебсерверів та серверів застосунків. Many servers come with unnecessary default and sample files, including applications, configuration files, scripts, and web pages. У них також можуть бути ввімкнені непотрібні служби, такі як керування контентом і функції віддаленого адміністрування. Налагоджувальні функції можуть бути увімкнені або адміністративні функції можуть бути доступні анонімним користувачам. Ці функції можуть надати хакеру можливість обійти методи автентифікації та отримати доступ до конфіденційної інформації, можливо, з підвищеними привілеями.

Сервери можуть містити відомі облікові записи та паролі за замовчуванням. Якщо не вдасться повністю заблокувати або посилити захист сервера, можуть залишитися неправильно встановлені дозволи на файли та каталоги. Misconfigured SSL certificates and encryption settings, the use of default certificates, and improper authentication implementation with external systems may compromise the confidentiality of information.

Докладні та інформативні повідомлення про помилки можуть призвести до витоку даних, а виявлена інформація може бути використана для формулювання наступного рівня атаки. Incorrect configurations in the server software may permit directory indexing and path traversal attacks.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Server-Misconfiguration</reference>
	<reference/>
</vuln_item_wasc_14>

<vuln_items>wasc_15</vuln_items>
<vuln_item_wasc_15>
	<alert>Неправильна конфігурація застосунку</alert>
	<desc>Application Misconfiguration attacks exploit configuration weaknesses found in web applications. Many applications come with unnecessary and unsafe features, such as debug and QA features, enabled by default. Ці функції можуть надати хакеру можливість обійти методи автентифікації та отримати доступ до конфіденційної інформації, можливо, з підвищеними привілеями.

Likewise, default installations may include well-known usernames and passwords, hard-coded backdoor accounts, special access mechanisms, and incorrect permissions set for files accessible through web servers. Default samples may be accessible in production environments. Конфігураційні файли застосунків, які не заблоковані належним чином, можуть містити чіткі текстові рядки з'єднання з базою даних, а налаштування за замовчуванням у конфігураційних файлах можуть бути встановлені без врахування вимог безпеки. Всі ці неправильні конфігурації можуть призвести до несанкціонованого доступу до конфіденційної інформації.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Application-Misconfiguration</reference>
	<reference/>
</vuln_item_wasc_15>

<vuln_items>wasc_16</vuln_items>
<vuln_item_wasc_16>
	<alert>Індексування каталогів</alert>
	<desc>Автоматичний список або індексація каталогів - це функція вебсервера, яка перераховує всі файли в запитуваному каталозі, якщо звичайний базовий файл (index.html/home.html/default.htm/default.asp/default.aspx/index.php) відсутній. Коли користувач запитує головну сторінку вебсайту, він зазвичай вводить URL-адресу, таку як http://www.example.com/directory1/, використовуючи доменне ім'я і не вказуючи конкретний файл. Вебсервер обробляє цей запит, шукає в кореневому каталозі документа ім'я файлу за замовчуванням і надсилає цю сторінку клієнту. Якщо ця сторінка відсутня, вебсервер динамічно видасть список каталогів і надішле його клієнту. Essentially, this is equivalent to issuing an "ls" (Unix) or "dir" (Windows) command within this directory and showing the results in HTML form. З точки зору атак і контрзаходів, важливо розуміти, що небажані списки каталогів можуть бути створені через уразливості програмного забезпечення (розглянуті в розділі прикладів нижче) в поєднанні з певним вебзапитом.</desc>
	<solution>Рекомендації включають обмеження доступу до важливих каталогів або файлів шляхом прийняття вимоги про необхідність знати як для документа, так і для кореня сервера, а також вимкнення таких функцій, як автоматичні списки каталогів, які можуть розкрити приватні файли та надати інформацію, що може бути використана зловмисником при підготовці або проведенні атаки.</solution>
	<reference>http://projects.webappsec.org/Directory-Indexing</reference>
	<reference>http://cwe.mitre.org/data/definitions/548.html</reference>
</vuln_item_wasc_16>

<vuln_items>wasc_17</vuln_items>
<vuln_item_wasc_17>
	<alert>Improper Filesystem Permissions</alert>
	<desc>Improper filesystem permissions are a threat to the confidentiality, integrity and availability of a web application. The problem arises when incorrect filesystem permissions are set on files, folders, and symbolic links. When improper permissions are set, an attacker may be able to access restricted files or directories and modify or delete their contents. Наприклад, якщо анонімний обліковий запис користувача має дозвіл на запис до файлу, то зловмисник може змінити вміст файлу, впливаючи на вебзастосунок у небажаний спосіб. An attacker may also exploit improper symlinks to escalate their privileges and/or access unauthorized files; for example, a symlink that points to a directory outside of the web root.</desc>
	<solution>Very carefully manage the setting, management and handling of permissions. Явно керуйте зонами довіри в програмному забезпеченні.</solution>
	<reference>http://projects.webappsec.org/Improper-Filesystem-Permissions</reference>
	<reference>http://cwe.mitre.org/data/definitions/280.html</reference>
</vuln_item_wasc_17>

<vuln_items>wasc_18</vuln_items>
<vuln_item_wasc_18>
	<alert>Credential and Session Prediction</alert>
	<desc>Credential/Session Prediction is a method of hijacking or impersonating a web site user. Deducing or guessing the unique value that identifies a particular session or user accomplishes the attack. Also known as Session Hijacking, the consequences could allow attackers the ability to issue web site requests with the compromised user's privileges.

Many web sites are designed to authenticate and track a user when communication is first established. To do this, users must prove their identity to the web site, typically by supplying a username/password (credentials) combination. Rather than passing these confidential credentials back and forth with each transaction, web sites will generate a unique "session ID" to identify the user session as authenticated. Subsequent communication between the user and the web site is tagged with the session ID as "proof" of the authenticated session. Якщо зловмисник може передбачити або вгадати ідентифікатор сеансу іншого користувача, можлива шахрайська діяльність.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Credential-and-Session-Prediction</reference>
	<reference/>
</vuln_item_wasc_18>

<vuln_items>wasc_19</vuln_items>
<vuln_item_wasc_19>
	<alert>SQL впровадження</alert>
	<desc>SQL-ін'єкція - це метод атаки, який використовується для експлуатації додатків, що створюють SQL-запити на основі введених користувачем даних. When successful, the attacker is able to change the logic of SQL statements executed against the database.

Structured Query Language (SQL) is a specialized programming language for sending queries to databases. The SQL programming language is both an ANSI and an ISO standard, though many database products supporting SQL do so with proprietary extensions to the standard language. Застосунки часто використовують дані, надані користувачем, для створення операторів SQL. Якщо програма не може правильно побудувати оператори SQL, зловмисник може змінити структуру операторів і виконати незаплановані та потенційно шкідливі команди. Коли такі команди виконуються, вони виконуються у контексті користувача, вказаного програмою, що виконує оператор. Ця можливість дозволяє зловмисникам отримати контроль над усіма ресурсами бази даних, доступними цьому користувачеві, зокрема можливість виконувати команди в системі хостингу.</desc>
	<solution>Фаза: Архітектура і Дизайн
Використовуйте перевірену бібліотеку чи структуру, які запобігають виникненню цієї слабкості або надають конструкції, які полегшують уникнення цієї слабкості.
For example, consider using persistence layers such as Hibernate or Enterprise Java Beans, which can provide significant protection against SQL injection if used properly.

Якщо доступно, використовуйте структуровані механізми, які автоматично забезпечують поділ між даними та кодом. Ці механізми можуть автоматично забезпечити відповідне цитування, кодування та перевірку, замість того, щоб покладатися на те, що розробник надасть цю можливість у кожній точці, де генерується результат.

Process SQL queries using prepared statements, parameterized queries, or stored procedures. These features should accept parameters or variables and support strong typing. Do not dynamically construct and execute query strings within these features using "exec" or similar functionality, since you may re-introduce the possibility of SQL injection.

Запускайте свій код з найнижчими привілеями, які потрібні для виконання необхідних завдань. Якщо можливо, створюйте ізольовані облікові записи з обмеженими правами, які використовуються лише для однієї задачі. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.

Зокрема, дотримуйтесь принципу найменших привілеїв під час створення облікових записів користувачів до бази даних SQL. Користувачі бази даних повинні мати лише мінімальні привілеї, необхідні для використання свого облікового запису. Якщо вимоги системи вказують на те, що користувач може читати та змінювати власні дані, обмежте його права, щоб він не міг читати або записувати чужі дані. Використовуйте найсуворіші дозволи на всі об'єкти бази даних, наприклад, тільки на виконання для збережених процедур.

Phase: Implementation
If you need to use dynamically-generated query strings or commands in spite of the risk, properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict allow list (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE-88).

Instead of building your own implementation, such features may be available in the database or programming language. For example, the Oracle DBMS ASSERT package can check or enforce that parameters have certain properties that make them less vulnerable to SQL injection. For MySQL, the mysql real escape string() API function is available in both C and PHP.

Припустимо, що всі вхідні дані зловмисні. Використовуйте стратегію перевірки вхідних даних «прийняти наперед хороші», тобто використовуйте дозволений список прийнятних вхідних даних, які чітко відповідають специфікаціям. Відхиліть будь-які вхідні дані, які не повністю відповідають специфікаціям, або перетворіть їх на щось, що відповідає. Не покладайтеся виключно на пошук зловмисних або некоректних даних (тобто не покладайтеся на список заборонених). Однак списки заборони можуть бути корисними для виявлення потенційних атак або визначення того, які вхідні дані є настільки неправильними, що їх слід відхилити.

Виконуючи перевірку вхідних даних, враховуйте всі потенційно важливі властивості, включаючи довжину, тип вхідних даних, повний діапазон прийнятних значень, відсутні або додаткові вхідні дані, синтаксис, узгодженість пов’язаних полів і відповідність бізнес-правилам. Як приклад логіки бізнес-правил, «човен» може бути синтаксично допустимим, оскільки містить лише буквено-цифрові символи, але він недійсний, якщо ви очікуєте такі кольори, як «червоний» або «синій».

When constructing SQL query strings, use stringent allow lists that limit the character set based on the expected value of the parameter in the request. Це опосередковано обмежить область атаки, але цей метод менш важливий, ніж правильне кодування виводу та екранування.

Note that proper output encoding, escaping, and quoting is the most effective solution for preventing SQL injection, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent SQL injection, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, the name "O'Reilly" would likely pass the validation step, since it is a common last name in the English language. However, it cannot be directly inserted into the database because it contains the "'" apostrophe character, which would need to be escaped or otherwise handled. In this case, stripping the apostrophe might reduce the risk of SQL injection, but it would produce incorrect behavior because the wrong name would be recorded.

When feasible, it may be safest to disallow meta-characters entirely, instead of escaping them. This will provide some defense in depth. Після внесення даних до бази даних подальші процеси можуть нехтувати екрануванням метасимволів перед використанням, і ви можете не мати контролю над цими процесами.</solution>
	<reference>http://projects.webappsec.org/SQL-Injection</reference>
	<reference/>
</vuln_item_wasc_19>

<vuln_items>wasc_20</vuln_items>
<vuln_item_wasc_20>
	<alert>Improper Input Handling</alert>
	<desc>Improper input handling is one of the most common weaknesses identified across applications today. Погана обробка вхідних даних є основною причиною критичних вразливостей, які існують в системах та застосунках.
	
Generally, the term input handing is used to describe functions like validation, sanitization, filtering, encoding and/or decoding of input data. Applications receive input from various sources including human users, software agents (browsers), and network/peripheral devices to name a few. In the case of web applications, input can be transferred in various formats (name value pairs, JSON, SOAP, etc...) and obtained via URL query strings, POST data, HTTP headers, Cookies, etc... Non-web application input can be obtained via application variables, environment variables, the registry, configuration files, etc... Regardless of the data format or source/location of the input, all input should be considered untrusted and potentially malicious. Applications which process untrusted input may become vulnerable to attacks such as Buffer Overflows, SQL Injection, OS Commanding, Denial of Service just to name a few.

One of the key aspects of input handling is validating that the input satisfies a certain criteria. Для належної перевірки важливо визначити форму та тип даних, які є прийнятними та очікуваними для програми. Для точного визначення обмежень необхідне визначення очікуваного формату і використання кожного екземпляра ненадійних даних. 

Validation can include checks for type safety and correct syntax. String input can be checked for length (min and max number of characters) and character set validation while numeric input types like integers and decimals can be validated against acceptable upper and lower bound of values. When combining input from multiple sources, validation should be performed during concatenation and not just against the individual data elements. This practice helps avoid situations where input validation may succeed when performed on individual data items but fails when done on a combined set from all the sources.</desc>
	<solution>Phase: Architecture and Design

Use an input validation framework such as Struts or the OWASP ESAPI Validation API.

Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, databases, and any external systems that provide data to the application. Пам’ятайте, що такі вхідні дані можна отримати опосередковано через виклики API.

For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side. Зловмисники можуть обійти перевірки на стороні клієнта, змінивши значення після виконання перевірок або змінивши клієнта, щоб повністю видалити перевірки на стороні клієнта. Потім ці змінені значення будуть надіслані на сервер.

Even though client-side checks provide minimal benefits with respect to server-side security, they are still useful. First, they can support intrusion detection. If the server receives input that should have been rejected by the client, then it may be an indication of an attack. Second, client-side error-checking can provide helpful feedback to the user about the expectations for valid input. Third, there may be a reduction in server-side processing time for accidental input errors, although this is typically a small savings.

Не покладайтеся виключно на перевірку списків заборон для виявлення зловмисного вводу або кодування виводу. Існує занадто багато способів кодування одного і того ж символу, тому ви, швидше за все, пропустите деякі варіанти.

Якщо ваш застосунок об'єднує дані з декількох джерел, виконайте перевірку після того, як джерела будуть об'єднані. Окремі елементи даних можуть пройти етап перевірки, але після об'єднання порушувати встановлені обмеження.

Припустимо, що всі вхідні дані зловмисні. Використовуйте стратегію перевірки вхідних даних «прийняти наперед хороші», тобто використовуйте дозволений список прийнятних вхідних даних, які чітко відповідають специфікаціям. Відхиліть будь-які вхідні дані, які не повністю відповідають специфікаціям, або перетворіть їх на щось, що відповідає. Не покладайтеся виключно на пошук зловмисних або некоректних даних (тобто не покладайтеся на список заборонених). Однак списки заборони можуть бути корисними для виявлення потенційних атак або визначення того, які вхідні дані є настільки неправильними, що їх слід відхилити.

Виконуючи перевірку вхідних даних, враховуйте всі потенційно важливі властивості, включаючи довжину, тип вхідних даних, повний діапазон прийнятних значень, відсутні або додаткові вхідні дані, синтаксис, узгодженість пов’язаних полів і відповідність бізнес-правилам. Як приклад логіки бізнес-правил, «човен» може бути синтаксично допустимим, оскільки містить лише буквено-цифрові символи, але він недійсний, якщо ви очікуєте такі кольори, як «червоний» або «синій».

Фаза: Реалізація

Будьте особливо уважні до перевірки ваших даних, коли викликаєте код, який перетинає мовні кордони, наприклад, з інтерпретованої мови на рідну. Це може створити несподівану взаємодію між мовними кордонами. Переконайтеся, що ви не порушуєте жодних очікувань мови, якою ви спілкуєтеся. For example, even though Java may not be susceptible to buffer overflows, providing a large argument in a call to native code might trigger an overflow.

Directly convert your input type into the expected data type, such as using a conversion function that translates a string into a number. After converting to the expected data type, ensure that the input's values fall within the expected range of allowable values and that multi-field consistencies are maintained.

Inputs should be decoded and canonicalized to the application's current internal representation before being validated. Make sure that your application does not inadvertently decode the same input twice. Такі помилки можна використовувати для обходу схем дозволених списків шляхом введення небезпечних вхідних даних після їх перевірки. Використовуйте такі бібліотеки, як елемент керування канонізацією OWASP ESAPI.

Повторюйте канонізацію доти, доки ваші дані не перестануть змінюватися. Це дозволить уникнути подвійного декодування та подібних сценаріїв, але може ненавмисно змінити вхідні дані, які можуть містити належним чином закодований небезпечний вміст.

Під час обміну даними між компонентами переконайтеся, що обидва компоненти використовують однакове кодування символів. Переконайтеся, що на кожному інтерфейсі застосовується правильне кодування. Явно вказуйте кодування, яке ви використовуєте, якщо це дозволяє протокол.</solution>
	<reference>http://projects.webappsec.org/Improper-Input-Handling</reference>
	<reference>http://cwe.mitre.org/data/definitions/89.html</reference>
</vuln_item_wasc_20>

<vuln_items>wasc_21</vuln_items>
<vuln_item_wasc_21>
	<alert>Недостатня антиавтоматизація</alert>
	<desc>Недостатня антиавтоматизація виникає, коли вебзастосунок дозволяє зловмиснику автоматизувати процес, який спочатку був розроблений для виконання лише вручну, тобто людиною-користувачем Інтернету.

Функціональність веб-додатку, яка часто стає ціллю для автоматизованих атак, може включати в себе:
    * Форми входу в додаток - зловмисники можуть автоматизувати запити на вхід в систему методом грубої сили, намагаючись вгадати облікові дані користувача
    * Форми реєстрації сервісів - зловмисники можуть автоматично створювати тисячі нових облікових записів
    * Форми електронної пошти - зловмисники можуть використовувати форми електронної пошти як ретранслятори спаму або для переповнення поштової скриньки певного користувача
    * Обслуговування акаунтів - зловмисники можуть виконувати масові DoS-атаки на додаток, засипаючи його численними запитами на відключення або видалення облікових записів користувачів
    * Форми відомостей про обліковий запис - зловмисники можуть виконувати масові спроби збору персональної інформації користувачів з веб-додатку
    * Форми коментування / форми відправки вмісту - можуть бути використані для спаму блогів, веб-форумів та дошок оголошень шляхом автоматичної відправки вмісту, наприклад, спаму або навіть веб-шкідливого програмного забезпечення.
    * Форми, прив'язані до запитів до бази даних SQL - вони можуть бути використані для проведення атаки на відмову в обслуговуванні програми. Атака виконується шляхом надсилання численних інтенсивних SQL-запитів за короткий проміжок часу, таким чином відмовляючи реальним користувачам в обслуговуванні.
    * eShopping або eCommerce - застосунки для електронних магазинів та електронної комерції, які не обмежують коло покупців лише людьми, можуть бути використані для купівлі бажаних товарів у великих кількостях, наприклад, квитків на спортивні заходи. These are later sold by scalpers for higher prices.
    * Онлайн-опитування - опитування та інші види систем онлайн-голосування можуть бути автоматично підтасовані на користь певного вибору.
    * Розсилка SMS-повідомлень через Інтернет - зловмисники можуть використовувати системи розсилки SMS-повідомлень для розсилання спаму користувачам мобільних телефонів
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Insufficient+Anti-automation</reference>
	<reference>http://cwe.mitre.org/data/definitions/116.html</reference>
</vuln_item_wasc_21>

<vuln_items>wasc_22</vuln_items>
<vuln_item_wasc_22>
	<alert>Improper Output Handling</alert>
	<desc>Обробка виводу - це те, як додаток генерує вихідні дані.  Якщо додаток має неправильну обробку виводу, вихідні дані можуть бути використані, що призведе до вразливих місць і дій, які не були заплановані розробником додатку.  У багатьох випадках така ненавмисна інтерпретація класифікується як одна або декілька форм вразливих місць критичних додатків.

Будь-яке розташування, де дані залишають межі додатку, може бути наслідком неправильної обробки вихідних даних.  Межі додатку існують там, де дані залишають один контекст і потрапляють в інший.  Сюди входять додатки, що передають дані іншим програмам через веб-сервіси, сокети, командний рядок, змінні середовища тощо...  Сюди також входить передача даних між рівнями в архітектурі додатку, такими як база даних, сервер каталогів, HTML/JavaScript інтерпретатор (браузер) або операційна система.  Більш детально про те, де може виникати неправильна обробка виводу, можна дізнатися в розділі нижче під назвою "Загальні місця виводу даних".

Неправильна обробка виводу може набувати різних форм у додатку.  Ці форми можна класифікувати на: помилки протоколу, помилки додатку та помилки, пов'язані зі споживачем даних.  Помилки протоколу включають відсутність або неправильне кодування вихідних даних, екранування та виведення недійсних даних.  Помилки додатку включають логічні помилки, такі як виведення неправильних даних або передача шкідливого вмісту без фільтрації.  Якщо додаток не відрізняє належним чином легітимний вміст від нелегітимного або не обходить відомі вразливі місця споживача даних, це може призвести до зловживань з боку споживача даних, спричинених неправильною обробкою вихідних даних.

Додаток, який не надає дані в правильному контексті, може дозволити зловмиснику зловживати споживачем даних.  Це може призвести до певних загроз, зазначених у Класифікації загроз WASC, зокрема підміни вмісту, міжсайтового скриптингу, розділення HTTP-відповідей, контрабанди HTTP-відповідей, LDAP введення, керування ОС, обхід маршрутизації, зловживання масивами SOAP, перенаправлення URL-адреси, XML введення, XQuery введення, XPath введення, впровадження поштових команд, нульового введення та SQL-введення.

Належна обробка вихідних даних запобігає неочікуваній або ненавмисній інтерпретації даних споживачем.  Щоб досягти цієї мети, розробники повинні розуміти модель даних додатку, як дані будуть використовуватися іншими частинами додатку і як вони будуть запропоновані користувачеві.  Методи забезпечення належної обробки вихідних даних включають, але не обмежуються фільтрацією та санітарною обробкою даних (більш детально про санітарну обробку та фільтрацію вихідних даних можна знайти у відповідних розділах нижче).  Однак непослідовне використання обраних методів обробки вихідних даних може фактично збільшити ризик неправильної обробки вихідних даних, якщо вихідні дані будуть проігноровані або залишені без обробки.  Для забезпечення "глибокого захисту" розробники повинні припускати, що всі дані в додатку є ненадійними, при виборі відповідних стратегій обробки виводу.

Хоча належна обробка вихідних даних може приймати різні форми, додаток не може бути безпечним, якщо він не захищає від ненавмисних інтерпретацій з боку споживача даних. Ця основна вимога необхідна для того, щоб додаток міг безпечно обробляти операції виводу.</desc>
	<solution>Використовуйте перевірені бібліотеки або фреймворки, які не допускають виникнення цієї вразливості або надають конструкції, які полегшують уникнення цієї вразливості.

Наприклад, розгляньте можливість використання елемента керування ESAPI Encoding або подібного інструменту, бібліотеки чи фреймворку. Вони допоможуть програмісту кодувати виходи у спосіб, менш схильний до помилок.

Або ж використовуйте вбудовані функції, але розгляньте можливість використання оболонок на випадок, якщо в цих функціях буде виявлено вразливість.

Якщо це можливо, використовуйте структуровані механізми, які автоматично забезпечують розділення даних і коду. Ці механізми можуть забезпечити відповідне цитування, кодування та перевірку автоматично, замість того, щоб покладатися на розробника, який має забезпечувати цю можливість у кожній точці, де генерується результат.

Наприклад, збережені процедури можуть забезпечити дотримання структури запитів до бази даних і зменшити ймовірність SQL-введення.

Зрозумійте, в якому контексті будуть використовуватися ваші дані і яке кодування очікується. Це особливо важливо при передачі даних між різними компонентами або при створенні вихідних даних, які можуть містити кілька кодувань одночасно, наприклад, веб-сторінки або поштові повідомлення, що складаються з кількох частин. Вивчіть всі очікувані протоколи зв'язку та представлення даних, щоб визначити необхідні стратегії кодування.

У деяких випадках перевірка вхідних даних може бути важливою стратегією, коли вихідне кодування не є повним рішенням. Наприклад, ви можете надавати один і той самий вихідний файл, який буде оброблятися кількома споживачами, що використовують різні кодування або представлення. В інших випадках вам може знадобитися дозволити користувацькому введенні містити контрольну інформацію, наприклад, обмежені HTML-теги, які підтримують форматування у Вікі або дошці оголошень. Коли потрібно виконати цей тип вимог, використовуйте дуже суворий список дозволів, щоб обмежити, які контрольні послідовності можна використовувати. Перевірте, чи отримана синтаксична структура відповідає вашим очікуванням. Для решти даних використовуйте ваші звичайні методи кодування.

Використовуйте перевірку вхідних даних як глибинну міру захисту, щоб зменшити ймовірність помилок вихідного кодування (див. CWE-20).

Під час обміну даними між компонентами переконайтеся, що обидва компоненти використовують однакове кодування символів. Переконайтеся, що на кожному інтерфейсі застосовується правильне кодування. Явно встановлюйте кодування, яке ви використовуєте, якщо це дозволяє протокол.</solution>
	<reference>http://projects.webappsec.org/Improper-Output-Handling</reference>
	<reference/>
</vuln_item_wasc_22>

<vuln_items>wasc_23</vuln_items>
<vuln_item_wasc_23>
	<alert>XML введення</alert>
	<desc>XML-введення - це метод атаки, який використовується для керування або компрометації логіки XML-додатку або сервісу. Введення в XML-повідомлення ненавмисного вмісту та/або структур може змінити логіку роботи додатку. Крім того, XML-введення може призвести до вставки шкідливого вмісту в отримане повідомлення/документ.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/XML-Injection</reference>
	<reference/>
</vuln_item_wasc_23>

<vuln_items>wasc_24</vuln_items>
<vuln_item_wasc_24>
	<alert>Поділ HTTP-запитів</alert>
	<desc>Поділ HTTP запитів - це атака, яка дозволяє змусити браузер надсилати довільні HTTP-запити, що призводить до XSS-атак та отруєння кешу браузера. Суть атаки полягає в здатності зловмисника, після того, як жертва (браузер) змушена завантажити шкідливу HTML-сторінку зловмисника, керувати однією з функцій браузера, щоб замість одного HTTP-запиту відправити 2 HTTP-запити. Використовуються два таких механізми: об'єкт XmlHttpRequest (скорочено XHR) і механізм автентифікації HTTP-дайджесту. Щоб ця атака спрацювала, браузер повинен використовувати прямий проксі HTTP (не всі вони "підтримують" цю атаку), або атака повинна бути проведена проти хоста, розташованого на одній IP-адресі (з точки зору браузера) з машиною зловмисника.</desc>
	<solution>Не використовуйте CRLF як спеціальну послідовність.

Належним чином фільтрувати або цитувати CRLF-послідовності у вхідних даних, контрольованих користувачем.</solution>
	<reference>http://projects.webappsec.org/HTTP-Request-Splitting</reference>
	<reference>http://cwe.mitre.org/data/definitions/93.html</reference>
</vuln_item_wasc_24>

<vuln_items>wasc_25</vuln_items>
<vuln_item_wasc_25>
	<alert>Поділ HTTP-запитів</alert>
	<desc>В атаці поділу HTTP-відповіді завжди беруть участь 3 сторони (як мінімум):
    * Веб-сервер, який має дірку в безпеці, що дозволяє поділ HTTP-відповіді
    * Ціль - об'єкт, який взаємодіє з веб-сервером, можливо, від імені зловмисника. Зазвичай це кеш-сервер (прямий/зворотний проксі) або браузер (можливо, з кешем браузера).
    * Зловмисник - ініціює атаку

Суть поділу HTTP-відповіді полягає в тому, що зловмисник може надіслати один HTTP-запит, який змушує веб-сервер сформувати вихідний потік, який потім інтерпретується ціллю як дві HTTP-відповіді замість однієї відповіді, як у звичайному випадку. Перша реакція може частково контролюватися зловмисником, але це не так важливо. Важливо те, що зловмисник повністю контролює форму другої відповіді від рядка стану HTTP до останнього байта тіла HTTP-відповіді. Як тільки це стає можливим, зловмисник реалізує атаку, надсилаючи два запити через ціль. Перший викликає дві відповіді від веб-сервера, а другий запит, як правило, надсилається до якогось "невинного" ресурсу на веб-сервері. Однак, на другий запит зловмисник отримає другу HTTP-відповідь, яка повністю контролюється зловмисником. Таким чином, зловмисник обманом змушує ціль повірити, що певний ресурс на веб-сервері (позначений другим запитом) є HTTP-відповіддю сервера (вміст сервера), тоді як насправді це певні дані, які зловмисник підробляє через веб-сервер - це і є друга відповідь.

Атаки поділу HTTP-відповіді  відбуваються, коли серверний скрипт вбудовує дані користувача в заголовки HTTP-відповідей. Зазвичай це відбувається, коли скрипт вбудовує дані користувача в URL-адресу відповіді перенаправлення (код стану HTTP 3xx) або коли скрипт вбудовує дані користувача в значення або ім'я файлу cookie, коли відповідь встановлює файл cookie.</desc>
	<solution>Конструюйте HTTP-заголовки дуже уважно, уникаючи використання неперевірених вхідних даних.</solution>
	<reference>http://projects.webappsec.org/HTTP-Response-Splitting</reference>
	<reference>http://cwe.mitre.org/data/definitions/113.html</reference>
</vuln_item_wasc_25>

<vuln_items>wasc_26</vuln_items>
<vuln_item_wasc_26>
	<alert>Контрабанда HTTP-запиту</alert>
	<desc>Контрабанда HTTP-запиту - це метод атаки, яка використовує розбіжності в розборі невідповідних RFC HTTP-запитів між двома HTTP-пристроями (як правило, зовнішнім проксі-сервером або брандмауером з підтримкою HTTP і внутрішнім веб-сервером), щоб передати запит на другий пристрій "через" перший пристрій. Ця техніка дозволяє зловмиснику надсилати один набір запитів на другий пристрій, в той час як перший пристрій бачить інший набір запитів. У свою чергу, це полегшує кілька можливих експлойтів, таких як часткове отруєння кешу, обхід захисту брандмауера та XSS.</desc>
	<solution>Використовуйте веб-сервер, який використовує сувору процедуру синтаксичного аналізу HTTP, наприклад, Apache (див. статтю у посиланні).

Використовуйте тільки SSL-зв'язок.

Завершуйте сеанс клієнта після кожного запиту.

Вимкніть кешування всіх сторінок.</solution>
	<reference>http://projects.webappsec.org/HTTP-Request-Smuggling</reference>
	<reference>http://cwe.mitre.org/data/definitions/444.html</reference>
</vuln_item_wasc_26>

<vuln_items>wasc_27</vuln_items>
<vuln_item_wasc_27>
	<alert>Контрабанда HTTP-відповіді</alert>
	<desc>Контрабанда HTTP-відповіді - це метод "контрабанди" 2 HTTP-відповідей від сервера до клієнта через проміжний HTTP-пристрій, який очікує (або дозволяє) одну відповідь від сервера.

Одне з застосувань цього методу - покращити базову техніку поділу HTTP-відповідей, щоб обійти заходи проти поділу HTTP-відповідей. У цьому випадку посередником є механізм розділення відповідей анти-HTTP між веб-сервером і проксі-сервером (або веб-браузером). Інший варіант використання - підробка відповідей, отриманих браузером. У цьому випадку шкідливий веб-сайт подає браузеру сторінку, яку браузер інтерпретує як таку, що походить з іншого (цільового) домену. Для цього можна використовувати контрабанду HTTP-відповіді, коли браузер використовує проксі-сервер для доступу до обох сайтів.

Контрабанда HTTP-відповіді використовує методи, подібні до контрабанди HTTP-запиту, щоб використовувати розбіжності між тим, що механізм поділу HTTP-відповіді (або проксі-сервер) вважає потоком HTTP-відповіді, і потоком відповіді, який розбирається проксі-сервером (або браузером). Отже, хоча механізм поділу HTTP-відповіді може вважати певний потік відповідей нешкідливим (одна HTTP-відповідь), проксі/браузер все одно може розпізнати його як дві HTTP-відповіді, а отже, бути вразливим до всіх наслідків вихідної техніки поділу HTTP-відповіді (у першому випадку) або бути вразливим до підміни сторінок (у другому випадку). Наприклад, деякі механізми захисту від поділу HTTP-відповіді, що використовуються деякими прикладними механізмами, забороняють додатку вставляти у відповідь заголовок, що містить CR+LF. Проте зловмисник може змусити додаток вставити заголовок, що містить CR, тим самим обійшовши захисний механізм. Деякі проксі-сервери все ще можуть розглядати CR (тільки) як роздільник заголовка (і відповіді), і тому комбінація веб-сервера і проксі-сервера все ще буде вразливою до атаки, яка може отруїти кеш проксі-сервера.
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/HTTP-Response-Smuggling</reference>
	<reference/>
</vuln_item_wasc_27>

<vuln_items>wasc_28</vuln_items>
<vuln_item_wasc_28>
	<alert>Null Byte Injection</alert>
	<desc>Null Byte Injection is an active exploitation technique used to bypass sanity checking filters in web infrastructure by adding URL-encoded null byte characters (i.e. %00, or 0x00 in hex) to the user-supplied data. Процес введення може змінити заплановану логіку роботи додатку та дозволити зловмиснику отримати несанкціонований доступ до системних файлів.

Більшість веб-додатків сьогодні розробляються з використанням мов вищого рівня, таких як PHP, ASP, Perl та Java. Однак ці веб-додатки в певний момент вимагають обробки високорівневого коду на системному рівні, і цей процес зазвичай досягається за допомогою функцій C/C++. The diverse nature of these dependent technologies has resulted in an attack class called ‘Null Byte Injection’ or ‘Null Byte Poisoning’ attack. У C/C++ нульовий байт є точкою завершення рядка або символом-роздільником, що означає негайне припинення обробки рядка. Байти після роздільника будуть проігноровані. Якщо рядок втрачає нульовий символ, довжина рядка стає невідомою, поки вказівник пам'яті не зустріне наступний нульовий байт. Це ненавмисне розгалуження може спричинити незвичну поведінку та призвести до появи вразливих місць у системі або застосунку. Аналогічно, деякі мови вищого рівня розглядають "нульовий байт" як заповнювач довжини рядка, оскільки він не має особливого значення в їхньому контексті. Через цю відмінність в інтерпретації можна легко ввести нульові байти, щоб керувати поведінкою додатку.

URL-адреси обмежені набором символів US-ASCII в діапазоні від 0x20 до 0x7E (шістнадцяткові) або від 32 до 126 (десяткові). Однак у вищезгаданому діапазоні використовується кілька символів, які не дозволені, оскільки вони мають особливе значення в контексті протоколу HTTP. З цієї причини було запроваджено схему кодування URL-адрес для включення спеціальних символів у URL-адреси з використанням розширеного представлення символів ASCII. З точки зору "нульового байта", це представлено у вигляді %00 у шістнадцятковій системі числення. Область видимості атаки нульовим байтом починається там, де веб-додатки взаємодіють з активними підпрограмами на мові C та зовнішніми API з базової операційної системи. Таким чином, дозволяючи зловмиснику керувати веб-ресурсами, читаючи або записуючи файли на основі привілеїв користувача додатку.</desc>
	<solution>Розробники повинні передбачити, що нульові символи або нульові байти будуть введеними/видаленими/керованими у вхідних векторах їхньої програмної системи. Використовуйте відповідну комбінацію чорних і білих списків, щоб гарантувати, що система обробляє лише достовірну, очікувану та відповідну інформацію.

Припустимо, що всі вхідні дані зловмисні. Використовуйте стандартний механізм перевірки вхідних даних для перевірки довжини, типу, синтаксису та бізнес-правил перед тим, як приймати дані для відображення або зберігання. Використовуйте стратегію перевірки за принципом "приймати добре відомі".

Використовуйте та вказуйте надійне вихідне кодування (наприклад, ISO 8859-1 або UTF 8).

Не покладайтеся виключно на перевірку списків заборон для виявлення зловмисного вводу або кодування виводу. Існує занадто багато варіантів для кодування символів; ви, швидше за все, пропустите деякі варіанти.

Вхідні дані повинні бути розшифровані та канонізовані відповідно до поточного внутрішнього представлення додатку перед перевіркою. Переконайтеся, що ваша програма не декодує один і той самий ввід двічі. Такі помилки можуть бути використані для обходу схем дозволених списків шляхом введення небезпечних вхідних даних після їх перевірки.</solution>
	<reference>http://projects.webappsec.org/Null-Byte-Injection</reference>
	<reference>http://cwe.mitre.org/data/definitions/158.html</reference>
</vuln_item_wasc_28>

<vuln_items>wasc_29</vuln_items>
<vuln_item_wasc_29>
	<alert>Впровадження LDAP </alert>
	<desc>Впровадження LDAP - це метод атаки, який використовується для експлуатації веб-сайтів, що створюють LDAP-запити на основі вхідних даних, наданих користувачем.

Lightweight Directory Access Protocol (LDAP) is an open-standard protocol for both querying and manipulating X.500 directory services. Протокол LDAP працює поверх транспортних протоколів Інтернету, таких як TCP. Веб-додатки можуть використовувати введені користувачем дані для створення власних операторів LDAP для динамічних запитів до веб-сторінок.

Якщо веб-додаток не може належним чином очистити введені користувачем дані, зловмисник може змінити конструкцію LDAP-запиту. Якщо зловмисник змінить оператор LDAP, процес буде запущено з тими ж правами, що й компонент, який виконав команду. (наприклад, сервер бази даних, сервер веб-додатків, веб-сервер тощо). Це може спричинити серйозні проблеми з безпекою, якщо дозволи надають право запитувати, змінювати або видаляти будь-що всередині дерева LDAP. Ті ж самі просунуті методи експлуатації, доступні в SQL-введенні, також можуть бути застосовані в LDAP-введенні.</desc>
	<solution>Припустимо, що всі вхідні дані зловмисні. Використовуйте відповідну комбінацію чорних і білих списків, щоб нейтралізувати синтаксис LDAP від контрольованого користувачем введення.</solution>
	<reference>http://projects.webappsec.org/LDAP-Injection</reference>
	<reference>http://cwe.mitre.org/data/definitions/90.html</reference>
</vuln_item_wasc_29>

<vuln_items>wasc_30</vuln_items>
<vuln_item_wasc_30>
	<alert>Впровадження поштових команд</alert>
	<desc>Впровадження поштових команд - це метод атаки, який використовується для експлуатації поштових серверів і веб-додатків, що створюють IMAP/SMTP-запити на основі введених користувачем даних, які не пройшли належну санітарну обробку. Залежно від типу твердження, яким користується зловмисник, ми зустрічаємося з двома типами впровадження: IMAP та SMTP впровадження. Впровадження IMAP/SMTP може дозволити отримати доступ до поштового сервера, до якого ви раніше не мали доступу. У деяких випадках ці внутрішні системи не мають такого ж рівня захисту інфраструктури, як більшість зовнішніх веб-серверів. Таким чином, зловмисники можуть виявити, що поштовий сервер дає кращі результати з точки зору експлуатації. З іншого боку, ця техніка дозволяє обійти можливі обмеження, які можуть існувати на рівні додатку (CAPTCHA, максимальна кількість запитів тощо).</desc>
	<solution>Зрозумійте всі можливі місця, де ненадійні дані можуть потрапити у ваше програмне забезпечення: параметри або аргументи, файли cookie, все, що зчитується з мережі, змінні середовища, заголовки запитів, а також вміст, компоненти URL-адрес, електронна пошта, файли, бази даних і будь-які зовнішні системи, які надають дані додатку. Виконуйте перевірку вхідних даних на чітко визначених інтерфейсах.

Припустимо, що всі вхідні дані зловмисні. Використовуйте стратегію перевірки вхідних даних за принципом "прийняти відомі дані" (тобто, використовуйте список дозволених даних). Відхиліть будь-які вхідні дані, які не повністю відповідають специфікаціям, або перетворіть їх на щось, що відповідає. Використовуйте список заборон, щоб відхиляти будь-які неочікувані вхідні дані та виявляти можливі атаки.

Не покладайтеся виключно на перевірку списків заборон для виявлення зловмисного вводу або кодування виводу. Існує занадто багато варіантів для кодування символів; ви, швидше за все, пропустите деякі варіанти.

Безпосередньо перетворіть тип вхідних даних в очікуваний тип даних, наприклад, за допомогою функції перетворення, яка переводить рядок у число. Після перетворення до очікуваного типу даних переконайтеся, що значення вхідних даних потрапляють в очікуваний діапазон допустимих значень і що зберігається багатопрофільна узгодженість.

Вхідні дані повинні бути розшифровані та канонізовані відповідно до поточного внутрішнього представлення додатку перед перевіркою. Переконайтеся, що ваша програма не декодує один і той самий ввід двічі. Такі помилки можуть бути використані для обходу схем дозволених списків шляхом введення небезпечних вхідних даних після їх перевірки. Використовуйте такі бібліотеки, як елемент керування канонізацією OWASP ESAPI.

Повторюйте канонізацію доти, доки ваші дані не перестануть змінюватися. Це дозволить уникнути подвійного декодування та схожих сценаріїв, але може ненавмисно змінити вхідні дані, які можуть містити належним чином закодований небезпечний вміст.

Під час обміну даними між компонентами переконайтеся, що обидва компоненти використовують однакове кодування символів. Переконайтеся, що на кожному інтерфейсі застосовується правильне кодування. Явно вказуйте кодування, яке ви використовуєте, якщо це дозволяє протокол.

Якщо ваш додаток об'єднує дані з декількох джерел, виконайте перевірку після того, як джерела будуть об'єднані. Окремі елементи даних можуть пройти етап перевірки, але після об'єднання порушувати встановлені обмеження.</solution>
	<reference>http://projects.webappsec.org/Mail-Command-Injection</reference>
	<reference>http://cwe.mitre.org/data/definitions/88.html</reference>
</vuln_item_wasc_30>

<vuln_items>wasc_31</vuln_items>
<vuln_item_wasc_31>
	<alert>Виконання команд ОС</alert>
	<desc>Виконання команд ОС - це техніка атаки, яка використовується для несанкціонованого виконання команд операційної системи.

Виконання команд ОС - є прямим результатом змішування довіреного коду та ненадійних даних. Ця атака можлива, коли програма приймає ненадійні вхідні дані для побудови команд операційної системи в небезпечний спосіб, включаючи неналежну санітарну обробку даних і/або неналежний виклик зовнішніх програм. У виконанні команд ОС команди, виконані зловмисником, будуть запущені з тими ж привілеями компонента, який виконав команду (наприклад, сервер бази даних, сервер веб-додатків, веб-сервер, оболонка, додаток). Оскільки команди виконуються під привілеями виконуваного компонента, зловмисник може скористатися цим, щоб отримати доступ або пошкодити частини, які інакше недоступні (наприклад, каталоги та файли операційної системи).</desc>
	<solution>Якщо це можливо, використовуйте виклики бібліотек, а не зовнішні процеси для відтворення потрібної функціональності.

Run your code in a "jail" or similar sandbox environment that enforces strict boundaries between the process and the operating system. Це може фактично обмежити, до яких файлів можна отримати доступ у певному каталозі або до того, які команди може виконувати ваше програмне забезпечення.

Приклади на рівні ОС включають Unix chroot jail, AppArmor і SELinux. Загалом, керований код може забезпечити певний захист. Наприклад, java.io.FilePermission в Java SecurityManager дозволяє вказати обмеження на операції з файлами.
Це може бути неможливим рішенням, і воно обмежує вплив лише на операційну систему; решта вашої програми все ще може бути скомпрометована.

Для будь-яких даних, які будуть використані для створення команди, що виконується, тримайте якомога більше цих даних поза зовнішнім контролем. Наприклад, у вебзастосунках для цього може знадобитися зберігати команду локально в стані сеансу замість того, щоб надсилати її клієнту у прихованому полі форми.

Використовуйте перевірені бібліотеки або фреймворки, які не допускають виникнення цієї вразливості або надають конструкції, які полегшують уникнення цієї вразливості.

Наприклад, розгляньте можливість використання елемента керування ESAPI Encoding або подібного інструменту, бібліотеки чи фреймворку. Вони допоможуть програмісту кодувати виходи у спосіб, менш схильний до помилок.

If you need to use dynamically-generated query strings or commands in spite of the risk, properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict allow list (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection.

Якщо програма, яку потрібно виконати, дозволяє задавати аргументи у вхідному файлі або за допомогою стандартного вводу, розгляньте можливість використання цього режиму, щоб передати аргументи замість командного рядка.

Якщо доступно, використовуйте структуровані механізми, які автоматично забезпечують поділ між даними та кодом. Ці механізми можуть автоматично забезпечити відповідне цитування, кодування та перевірку, замість того, щоб покладатися на те, що розробник надасть цю можливість у кожній точці, де генерується результат.

Деякі мови пропонують кілька функцій, які можна використовувати для виклику команд. Where possible, identify any function that invokes a command shell using a single string, and replace it with a function that requires individual arguments. These functions typically perform appropriate quoting and filtering of arguments. For example, in C, the system() function accepts a string that contains the entire command to be executed, whereas execl(), execve(), and others require an array of strings, one for each argument. In Windows, CreateProcess() only accepts one command at a time. In Perl, if system() is provided with an array of arguments, then it will quote each of the arguments.

Припустимо, що всі вхідні дані зловмисні. Використовуйте стратегію перевірки вхідних даних «прийняти наперед хороші», тобто використовуйте дозволений список прийнятних вхідних даних, які чітко відповідають специфікаціям. Відхиліть будь-які вхідні дані, які не повністю відповідають специфікаціям, або перетворіть їх на щось, що відповідає. Не покладайтеся виключно на пошук зловмисних або некоректних даних (тобто не покладайтеся на список заборонених). Однак списки заборони можуть бути корисними для виявлення потенційних атак або визначення того, які вхідні дані є настільки неправильними, що їх слід відхилити.

Виконуючи перевірку вхідних даних, враховуйте всі потенційно важливі властивості, включаючи довжину, тип вхідних даних, повний діапазон прийнятних значень, відсутні або додаткові вхідні дані, синтаксис, узгодженість пов’язаних полів і відповідність бізнес-правилам. Як приклад логіки бізнес-правил, «човен» може бути синтаксично допустимим, оскільки містить лише буквено-цифрові символи, але він недійсний, якщо ви очікуєте такі кольори, як «червоний» або «синій».

When constructing OS command strings, use stringent allow lists that limit the character set based on the expected value of the parameter in the request. Це опосередковано обмежить область атаки, але цей метод менш важливий, ніж правильне кодування виводу та екранування.

Note that proper output encoding, escaping, and quoting is the most effective solution for preventing OS command injection, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent OS command injection, especially if you are required to support free-form text fields that could contain arbitrary characters. Наприклад, під час виклику поштової програми вам може знадобитися дозволити вводити до поля теми небезпечні символи, такі як ";" та ">", які потрібно екранувати або обробляти іншим чином. In this case, stripping the character might reduce the risk of OS command injection, but it would produce incorrect behavior because the subject field would not be recorded as the user intended. Це може здатися незначною незручністю, але це може бути більш важливим, коли програма покладається на добре структуровані рядки теми для передачі повідомлень іншим компонентам.

Навіть якщо ви припустилися помилки під час перевірки, наприклад, забули одне зі 100 полів введення, правильне кодування все одно захистить вас від атак на основі ін'єкцій. As long as it is not done in isolation, input validation is still a useful technique, since it may significantly reduce your attack surface, allow you to detect some attacks, and provide other security benefits that proper encoding does not address.</solution>
	<reference>http://projects.webappsec.org/OS-Commanding</reference>
	<reference>http://cwe.mitre.org/data/definitions/78.html</reference>
</vuln_item_wasc_31>

<vuln_items>wasc_32</vuln_items>
<vuln_item_wasc_32>
	<alert>Routing Detour</alert>
	<desc>The WS-Routing Protocol (WS-Routing) is a protocol for exchanging SOAP messages from an initial message sender to an ultimate receiver, typically via a set of intermediaries. The WS-Routing protocol is implemented as a SOAP extension, and is embedded in the SOAP Header. WS-Routing is often used to provide a way to direct XML traffic through complex environments and transactions by allowing interim way stations in the XML path to assign routing instructions to an XML document.

Routing Detours are a type of "Man in the Middle" attack where Intermediaries can be injected or "hijacked" to route sensitive messages to an outside location. Routing information (either in the HTTP header or in WS-Routing header) can be modified en route and traces of the routing can be removed from the header and message such that the receiving application none the wiser that a routing detour has occurred. Заголовок і вставка об'єктів заголовка часто менш захищені, ніж повідомлення; це пов'язано з тим, що заголовок використовується як універсальний засіб для метаданих про транзакцію, таких як автентифікація, маршрутизація, форматування, схема, канонізація, простори імен і т.д. Крім того, у додаванні або обробці заголовка XML-документа може бути залучено багато процесів. In many implementations the routing info can come from an external web service (using WS-Referral for example) that provides the specific routing for the transaction.

WS-Addressing is a newer standard published by the W3C to provide routing functionality to SOAP messages. One of the key differences between WS-Routing and WS-Addressing is that WS-Addressing only provides the next location in the route. While little research has been done into the susceptibility of WS-Addressing to Routing Detour Attack, at least one paper (see reference #6 below) suggests that WS-Addressing is vulnerable to Routing Detour as well.</desc>
	<solution>Always fully authenticate both ends of any communications channel.

Дотримуйтесь принципу повної медіації.

A certificate binds an identity to a cryptographic key to authenticate a communicating party. Often, the certificate takes the encrypted form of the hash of the identity of the subject, the public key, and information such as time of issue or expiration using the issuer's private key. Сертифікат можна перевірити, розшифрувавши його за допомогою відкритого ключа видавця. Дивіться також ланцюжки підписів сертифікатів X.509 і структуру сертифікації PGP.</solution>
	<reference>http://projects.webappsec.org/Routing-Detour</reference>
	<reference>http://cwe.mitre.org/data/definitions/300.html</reference>
</vuln_item_wasc_32>

<vuln_items>wasc_33</vuln_items>
<vuln_item_wasc_33>
	<alert>Обхід шляху</alert>
	<desc>The Path Traversal attack technique allows an attacker access to files, directories, and commands that potentially reside outside the web document root directory. Зловмисник може маніпулювати URL-адресою таким чином, що вебсайт виконає або розкриє вміст довільних файлів у будь-якій точці вебсервера. Any device that exposes an HTTP-based interface is potentially vulnerable to Path Traversal.

Most web sites restrict user access to a specific portion of the file-system, typically called the "web document root" or "CGI root" directory. Ці каталоги містять файли, призначені для доступу користувачів, а також виконувані файли, необхідні для роботи вебзастосунків. To access files or execute commands anywhere on the file-system, Path Traversal attacks will utilize the ability of special-characters sequences.

The most basic Path Traversal attack uses the "../" special-character sequence to alter the resource location requested in the URL. Although most popular web servers will prevent this technique from escaping the web document root, alternate encodings of the "../" sequence may help bypass the security filters. These method variations include valid and invalid Unicode-encoding ("..%u2216" or "..%c0%af") of the forward slash character, backslash characters ("..\") on Windows-based servers, URL encoded characters "%2e%2e%2f"), and double URL encoding ("..%255c") of the backslash character.

Even if the web server properly restricts Path Traversal attempts in the URL path, a web application itself may still be vulnerable due to improper handling of user-supplied input. Це поширена проблема вебзастосунків, які використовують шаблонні механізми або завантажують статичний текст з файлів. In variations of the attack, the original URL parameter value is substituted with the file name of one of the web application's dynamic scripts. Отже, результати можуть показувати вихідний код, оскільки файл інтерпретується як текст, а не як виконуваний сценарій. Ці методи часто використовують додаткові спеціальні символи, такі як крапка ("."). щоб показати список поточного робочого каталогу або "%00" NULL-символи, щоб обійти елементарні перевірки розширення файлів.</desc>
	<solution>Припустимо, що всі вхідні дані зловмисні. Використовуйте стратегію перевірки вхідних даних «прийняти наперед хороші», тобто використовуйте дозволений список прийнятних вхідних даних, які чітко відповідають специфікаціям. Відхиліть будь-які вхідні дані, які не повністю відповідають специфікаціям, або перетворіть їх на щось, що відповідає. Не покладайтеся виключно на пошук зловмисних або некоректних даних (тобто не покладайтеся на список заборонених). Однак списки заборони можуть бути корисними для виявлення потенційних атак або визначення того, які вхідні дані є настільки неправильними, що їх слід відхилити.

Виконуючи перевірку вхідних даних, враховуйте всі потенційно важливі властивості, включаючи довжину, тип вхідних даних, повний діапазон прийнятних значень, відсутні або додаткові вхідні дані, синтаксис, узгодженість пов’язаних полів і відповідність бізнес-правилам. Як приклад логіки бізнес-правил, «човен» може бути синтаксично допустимим, оскільки містить лише буквено-цифрові символи, але він недійсний, якщо ви очікуєте такі кольори, як «червоний» або «синій».

Для імен файлів використовуйте суворі дозволені списки, які обмежують набір символів, який буде використовуватися. Якщо це можливо, дозвольте лише один символ "." у назві файлу, щоб уникнути вразливостей, і виключіть роздільники каталогів, такі як "/". Use an allow list of allowable file extensions.

Попередження: якщо ви намагаєтеся очистити свої дані, то робіть це так, щоб кінцевий результат не був у формі, яка може бути небезпечною. A sanitizing mechanism can remove characters such as '.' and ';' which may be required for some exploits. An attacker can try to fool the sanitizing mechanism into "cleaning" data into a dangerous form. Suppose the attacker injects a '.' inside a filename (e.g. "sensi.tiveFile") and the sanitizing mechanism removes the character resulting in the valid filename, "sensitiveFile". If the input data are now assumed to be safe, then the file may be compromised. 

Inputs should be decoded and canonicalized to the application's current internal representation before being validated. Переконайтеся, що ваша програма не декодує один і той самий ввід двічі. Такі помилки можна використовувати для обходу схем дозволених списків шляхом введення небезпечних вхідних даних після їх перевірки.

Use a built-in path canonicalization function (such as realpath() in C) that produces the canonical version of the pathname, which effectively removes ".." sequences and symbolic links.

Запускайте свій код з найнижчими привілеями, які потрібні для виконання необхідних завдань. Якщо можливо, створюйте ізольовані облікові записи з обмеженими правами, які використовуються лише для однієї задачі. Таким чином, успішна атака не надасть зловмиснику доступ до решти програмного забезпечення або його середовища. Наприклад, застосунки баз даних рідко потребують запуску від імені адміністратора бази даних, особливо в повсякденних операціях.

When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.

Run your code in a "jail" or similar sandbox environment that enforces strict boundaries between the process and the operating system. Це може фактично обмежити, до яких файлів можна отримати доступ у певному каталозі або до того, які команди може виконувати ваше програмне забезпечення.

Приклади на рівні ОС включають Unix chroot jail, AppArmor і SELinux. Загалом, керований код може забезпечити певний захист. Наприклад, java.io.FilePermission в Java SecurityManager дозволяє вказати обмеження на операції з файлами.

Це може бути неможливим рішенням, і воно обмежує вплив лише на операційну систему; решта вашої програми все ще може бути скомпрометована.
</solution>
	<reference>http://projects.webappsec.org/Path-Traversal</reference>
	<reference>http://cwe.mitre.org/data/definitions/22.html</reference>
</vuln_item_wasc_33>

<vuln_items>wasc_34</vuln_items>
<vuln_item_wasc_34>
	<alert>Predictable Resource Location</alert>
	<desc>Predictable Resource Location is an attack technique used to uncover hidden web site content and functionality. Роблячи обґрунтовані припущення шляхом перебору, зловмисник може вгадати імена файлів і каталогів, які не призначені для публічного перегляду. Brute forcing filenames is easy because files/paths often have common naming convention and reside in standard locations. These can include temporary files, backup files, logs, administrative site sections, configuration files, demo applications, and sample files. These files may disclose sensitive information about the website, web application internals, database information, passwords, machine names, file paths to other sensitive areas, etc...

This will not only assist with identifying site surface which may lead to additional site vulnerabilities, but also may disclose valuable information to an attacker about the environment or its users. Predictable Resource Location is also known as Forced Browsing, Forceful Browsing, File Enumeration, and Directory Enumeration.</desc>
	<solution>Apply appropriate access control authorizations for each access to all restricted URLs, scripts or files.

Consider using MVC based frameworks such as Struts.</solution>
	<reference>http://projects.webappsec.org/Predictable-Resource-Location</reference>
	<reference>http://cwe.mitre.org/data/definitions/425.html</reference>
</vuln_item_wasc_34>

<vuln_items>wasc_35</vuln_items>
<vuln_item_wasc_35>
	<alert>SOAP Array Abuse</alert>
	<desc>XML SOAP arrays are a common target for malicious abuse. SOAP arrays are defined as having a type of "SOAP-ENC:Array" or a type derived there from. SOAP arrays have one or more dimensions (rank) whose members are distinguished by ordinal position. An array value is represented as a series of elements reflecting the array, with members appearing in ascending ordinal sequence. For multi-dimensional arrays the dimension on the right side varies most rapidly. Each member element is named as an independent element. A web-service that expects an array can be the target of a XML DoS attack by forcing the SOAP server to build a huge array in the machine's memory, thus inflicting a DoS condition on the machine due to the memory pre-allocation.</desc>
	<solution> Perform adequate input validation against any value that influences the amount of memory that is allocated. Define an appropriate strategy for handling requests that exceed the limit, and consider supporting a configuration option so that the administrator can extend the amount of memory to be used if necessary.

Запустіть програму, використовуючи надані системні обмеження ресурсів для пам'яті. Це все одно може призвести до аварійного завершення роботи програми або виходу з неї, але вплив на решту системи буде зведено до мінімуму.</solution>
	<reference>http://projects.webappsec.org/SOAP-Array-Abuse</reference>
	<reference>http://cwe.mitre.org/data/definitions/789.html</reference>
</vuln_item_wasc_35>

<vuln_items>wasc_36</vuln_items>
<vuln_item_wasc_36>
	<alert>SSI Injection</alert>
	<desc>SSI Injection (Server-side Include) is a server-side exploit technique that allows an attacker to send code into a web application, which will later be executed locally by the web server. SSI Injection exploits a web application's failure to sanitize user-supplied data before they are inserted into a server-side interpreted HTML file.

Before serving an HTML web page, a web server may parse and execute Server-side Include statements before providing it to the client. In some cases (e.g. message boards, guest books, or content management systems), a web application will insert user-supplied data into the source of a web page.

If an attacker submits a Server-side Include statement, he may have the ability to execute arbitrary operating system commands, or include a restricted file's contents the next time the page is served. This is performed at the permission level of the web server user.</desc>
	<solution>Disable SSI execution on pages that do not require it. For pages requiring SSI ensure that you perform the following checks
- Only enable the SSI directives that are needed for this page and disable all others.
- HTML entity encode user supplied data before passing it to a page with SSI execution permissions.
- Use SUExec to have the page execute as the owner of the file instead of the web server user.</solution>
	<reference>http://projects.webappsec.org/SSI-Injection</reference>
	<reference/>
</vuln_item_wasc_36>

<vuln_items>wasc_37</vuln_items>
<vuln_item_wasc_37>
	<alert>Фіксація сеансу</alert>
	<desc>Session Fixation is an attack technique that forces a user's session ID to an explicit value. Depending on the functionality of the target web site, a number of techniques can be utilized to "fix" the session ID value. These techniques range from Cross-site Scripting exploits to peppering the web site with previously made HTTP requests. After a user's session ID has been fixed, the attacker will wait for that user to login. Once the user does so, the attacker uses the predefined session ID value to assume the same online identity.

Generally speaking there are two types of session management systems when it comes to ID values. The first type is "permissive" systems that allow web browsers to specify any ID. The second type is "strict" systems that only accept server-side-generated values. With permissive systems, arbitrary session IDs are maintained without contact with the web site. Strict systems require the attacker to maintain the "trap-session", with periodic web site contact, preventing inactivity timeouts.

Without active protection against Session Fixation, the attack can be mounted against any web site that uses sessions to identify authenticated users. Web sites using sessions IDs are normally cookie-based, but URLs and hidden form fields are used as well. Unfortunately, cookie-based sessions are the easiest to attack. Most of the currently identified attack methods are aimed toward the fixation of cookies.

In contrast to stealing a users' session IDs after they have logged into a web site, Session Fixation provides a much wider window of opportunity. The active part of the attack takes place before a user logs in.</desc>
	<solution>Invalidate any existing session identifiers prior to authorizing a new user session

For platforms such as ASP that do not generate new values for sessionid cookies, utilize a secondary cookie. In this approach, set a secondary cookie on the user's browser to a random value and set a session variable to the same value. If the session variable and the cookie value ever don't match, invalidate the session, and force the user to log on again.</solution>
	<reference>http://projects.webappsec.org/Session-Fixation</reference>
	<reference>http://cwe.mitre.org/data/definitions/384.html</reference>
</vuln_item_wasc_37>

<vuln_items>wasc_38</vuln_items>
<vuln_item_wasc_38>
	<alert>Зловживання перенаправленням URL-адрес</alert>
	<desc>URL redirectors represent common functionality employed by web sites to forward an incoming request to an alternate resource. Це може бути зроблено з різних причин і часто робиться для того, щоб дозволити переміщення ресурсів у структурі каталогу та уникнути порушення функціональності для користувачів, які запитують ресурс у його попередньому розташуванні. Перенаправлення URL-адрес також можна використовувати для реалізації балансування навантаження, використовуючи скорочені URL-адреси або запису вихідних посилань. It is this last implementation which is often used in phishing attacks as described in the example below. URL redirectors do not necessarily represent a direct security vulnerability but can be abused by attackers trying to social engineer victims into believing that they are navigating to a site other than the true destination.</desc>
	<solution>Припустимо, що всі вхідні дані зловмисні. Використовуйте стратегію перевірки вхідних даних «прийняти наперед хороші», тобто використовуйте дозволений список прийнятних вхідних даних, які чітко відповідають специфікаціям. Відхиліть будь-які вхідні дані, які не повністю відповідають специфікаціям, або перетворіть їх на щось, що відповідає. Не покладайтеся виключно на пошук зловмисних або некоректних даних (тобто не покладайтеся на список заборонених). Однак списки заборони можуть бути корисними для виявлення потенційних атак або визначення того, які вхідні дані є настільки неправильними, що їх слід відхилити.

Виконуючи перевірку вхідних даних, враховуйте всі потенційно важливі властивості, включаючи довжину, тип вхідних даних, повний діапазон прийнятних значень, відсутні або додаткові вхідні дані, синтаксис, узгодженість пов’язаних полів і відповідність бізнес-правилам. Як приклад логіки бізнес-правил, «човен» може бути синтаксично допустимим, оскільки містить лише буквено-цифрові символи, але він недійсний, якщо ви очікуєте такі кольори, як «червоний» або «синій».

Use an allow list of approved URLs or domains to be used for redirection.

Use an intermediate disclaimer page that provides the user with a clear warning that they are leaving your site. Implement a long timeout before the redirect occurs, or force the user to click on the link. Be careful to avoid XSS problems when generating the disclaimer page.

When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.

For example, ID 1 could map to "/login.asp" and ID 2 could map to "http://www.example.com/". Такі функції, як ESAPI AccessReferenceMap, надають цю можливість.

Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, databases, and any external systems that provide data to the application. Пам’ятайте, що такі вхідні дані можна отримати опосередковано через виклики API.

Many open redirect problems occur because the programmer assumed that certain inputs could not be modified, such as cookies and hidden form fields.</solution>
	<reference>http://projects.webappsec.org/URL-Redirector-Abuse</reference>
	<reference>http://cwe.mitre.org/data/definitions/601.html</reference>
</vuln_item_wasc_38>

<vuln_items>wasc_39</vuln_items>
<vuln_item_wasc_39>
	<alert>Впровадження XPath</alert>
	<desc>XPath Injection is an attack technique used to exploit applications that construct XPath (XML Path Language) queries from user-supplied input to query or navigate XML documents. It can be used directly by an application to query an XML document, as part of a larger operation such as applying an XSLT transformation to an XML document, or applying an XQuery to an XML document. The syntax of XPath bears some resemblance to an SQL query, and indeed, it is possible to form SQL-like queries on an XML document using XPath.

If an application uses run-time XPath query construction, embedding unsafe user input into the query, it may be possible for the attacker to inject data into the query such that the newly formed query will be parsed in a way differing from the programmer's intention.</desc>
	<solution>Use parameterized XPath queries (e.g. using XQuery). This will help ensure separation between data plane and control plane.

Properly validate user input. Reject data where appropriate, filter where appropriate and escape where appropriate. Make sure input that will be used in XPath queries is safe in that context.</solution>
	<reference>http://projects.webappsec.org/XPath-Injection</reference>
	<reference>http://cwe.mitre.org/data/definitions/643.html</reference>
</vuln_item_wasc_39>

<vuln_items>wasc_40</vuln_items>
<vuln_item_wasc_40>
	<alert>Insufficient Process Validation</alert>
	<desc>Insufficient Process Validation occurs when a web application fails to prevent an attacker from circumventing the intended flow or business logic of the application. When seen in the real world, insufficient process validation has resulted in ineffective access controls and monetary loss.

There are two main types of processes that require validation: flow control and business logic.

"Flow control" refers to multi-step processes that require each step to be performed in a specific order by the user. When an attacker performs the step incorrectly or out of order, the access controls may be bypassed and an application integrity error may occur. Examples of multi-step processes include wire transfer, password recovery, purchase checkout, and account sign-up.

"Business logic" refers to the context in which a process will execute as governed by the business requirements. Exploiting a business logic weakness requires knowledge of the business; if no knowledge is needed to exploit it, then most likely it isn't a business logic flaw. Due to this, typical security measures such as scans and code review will not find this class of weakness. One approach to testing is offered by OWASP in their Testing Guide.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Insufficient-Process-Validation</reference>
	<reference/>
</vuln_item_wasc_40>

<vuln_items>wasc_41</vuln_items>
<vuln_item_wasc_41>
	<alert>XML Attribute Blowup</alert>
	<desc>XML Attribute Blowup is a denial of service attack against XML parsers. The attacker provides a malicious XML document, which vulnerable XML parsers process in a very inefficient manner, leading to excessive CPU load. The essence of the attack is to include many attributes in the same XML node. Vulnerable XML parsers manage the attributes in an inefficient manner (e.g. in a data container for which insertion of a new attribute has O(n) runtime), resulting in a non-linear (in this example, quadratic, i.e. O(n2)) overall runtime, leading to a denial of service condition via CPU exhaustion.</desc>
	<solution>Design throttling mechanisms into the system architecture. Найкращий захист - обмежити кількість ресурсів, які може витратити несанкціонований користувач. Надійна модель автентифікації та контролю доступу допоможе в першу чергу запобігти таким атакам. Застосунок для входу повинен бути максимально захищений від DoS-атак. Обмеження доступу до бази даних, можливо, шляхом кешування наборів результатів, може допомогти мінімізувати витрачені ресурси. Щоб ще більше обмежити потенціал DoS-атаки, розгляньте можливість відстеження швидкості запитів, отриманих від користувачів, і блокування запитів, які перевищують певний поріг швидкості.

Mitigation of resource exhaustion attacks requires that the target system either:
 * recognizes the attack and denies that user further access for a given amount of time, or
 * uniformly throttles all requests in order to make it more difficult to consume resources more quickly than they can again be freed. 

Перше з цих рішень є проблемою саме по собі, оскільки воно може дозволити зловмисникам запобігти використанню системи певним дійсним користувачем. Якщо зловмисник видає себе за дійсного користувача, він може заборонити користувачеві доступ до відповідного сервера.

Друге рішення просто важко ефективно впровадити - і навіть якщо це зроблено належним чином, воно не забезпечує повного розв'язання проблеми. Це просто робить атаку більш ресурсомісткою для зловмисника.

Переконайтеся, що протоколи мають конкретні обмеження щодо масштабу.

Ensure that all failures in resource allocation place the system into a safe posture.</solution>
	<reference>http://projects.webappsec.org/XML-Attribute-Blowup</reference>
	<reference>http://cwe.mitre.org/data/definitions/400.html</reference>
</vuln_item_wasc_41>

<vuln_items>wasc_42</vuln_items>
<vuln_item_wasc_42>
	<alert>Abuse of Functionality</alert>
	<desc>Abuse of Functionality is an attack technique that uses a web site's own features and functionality to attack itself or others. Abuse of Functionality can be described as the abuse of an application's intended functionality to perform an undesirable outcome. These attacks have varied results such as consuming resources, circumventing access controls, or leaking information. The potential and level of abuse will vary from web site to web site and application to application. Abuse of functionality attacks are often a combination of other attack types and/or utilize other attack vectors.</desc>
	<solution>Always utilize APIs in the specified manner.</solution>
	<reference>http://projects.webappsec.org/Abuse-of-Functionality</reference>
	<reference>http://cwe.mitre.org/data/definitions/227.html</reference>
</vuln_item_wasc_42>

<vuln_items>wasc_43</vuln_items>
<vuln_item_wasc_43>
	<alert>XML External Entities</alert>
	<desc>This technique takes advantage of a feature of XML to build documents dynamically at the time of processing. An XML message can either provide data explicitly or by pointing to an URI where the data exists. In the attack technique, external entities may replace the entity value with malicious data, alternate referrals or may compromise the security of the data the server/XML application has access to.
	Attackers may also use External Entities to have the web services server download malicious code or content to the server for use in secondary or follow on attacks.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/XML-External-Entities</reference>
	<reference/>
</vuln_item_wasc_43>

<vuln_items>wasc_44</vuln_items>
<vuln_item_wasc_44>
	<alert>XML Entity Expansion</alert>
	<desc>The XML Entity expansion attack, exploits a capability in XML DTDs that allows the creation of custom macros, called entities, that can be used throughout a document. By recursively defining a set of custom entities at the top of a document, an attacker can overwhelm parsers that attempt to completely resolve the entities by forcing them to iterate almost indefinitely on these recursive definitions.

The malicious XML message is used to force recursive entity expansion (or other repeated processing) that completely uses up available server resources.</desc>
	<solution>If possible, prohibit the use of DTDs or use an XML parser that limits the expansion of recursive DTD entities.

Before parsing XML files with associated DTDs, scan for recursive entity declarations and do not continue parsing potentially explosive content.</solution>
	<reference>http://projects.webappsec.org/XML-Entity-Expansion</reference>
	<reference>http://cwe.mitre.org/data/definitions/776.html</reference>
</vuln_item_wasc_44>

<vuln_items>wasc_45</vuln_items>
<vuln_item_wasc_45>
	<alert>Fingerprinting</alert>
	<desc>The most common methodology for attackers is to first footprint the target's web presence and enumerate as much information as possible. With this information, the attacker may develop an accurate attack scenario, which will effectively exploit a vulnerability in the software type/version being utilized by the target host.

Multi-tier fingerprinting is similar to its predecessor, TCP/IP Fingerprinting (with a scanner such as Nmap) except that it is focused on the Application Layer of the OSI model instead of the Transport Layer. The theory behind this fingerprinting is to create an accurate profile of the target's platform, web application software technology, backend database version, configurations and possibly even their network architecture/topology.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Fingerprinting</reference>
	<reference/>
</vuln_item_wasc_45>

<vuln_items>wasc_46</vuln_items>
<vuln_item_wasc_46>
	<alert>XQuery Injection</alert>
	<desc>XQuery Injection is a variant of the classic SQL injection attack against the XML XQuery Language. XQuery Injection uses improperly validated data that is passed to XQuery commands. This inturn will execute commands on behalf of the attacker that the XQuery routines have access to. XQuery injection can be used to enumerate elements on the victim's environment, inject commands to the local host, or execute queries to remote files and data sources. Like SQL injection attacks, the attacker tunnels through the application entry point to target the resource access layer.</desc>
	<solution>Use parameterized queries. This will help ensure separation between data plane and control plane.

Properly validate user input. Reject data where appropriate, filter where appropriate and escape where appropriate. Make sure input that will be used in XQL queries is safe in that context.</solution>
	<reference>http://projects.webappsec.org/XQuery-Injection</reference>
	<reference>http://cwe.mitre.org/data/definitions/652.html</reference>
</vuln_item_wasc_46>

<vuln_items>wasc_47</vuln_items>
<vuln_item_wasc_47>
	<alert>Insufficient Session Expiration</alert>
	<desc>Insufficient Session Expiration occurs when a Web application permits an attacker to reuse old session credentials or session IDs for authorization. Insufficient Session Expiration increases a Web site's exposure to attacks that steal or reuse user's session identifiers.

Since HTTP is a stateless protocol, Web sites commonly use cookies to store session IDs that uniquely identify a user from request to request. Consequently, each session ID's confidentiality must be maintained in order to prevent multiple users from accessing the same account. A stolen session ID can be used to view another user's account or perform a fraudulent transaction.

Session expiration is comprised of two timeout types: inactivity and absolute. An absolute timeout is defined by the total amount of time a session can be valid without re-authentication and an inactivity timeout is the amount of idle time allowed before the session is invalidated. The lack of proper session expiration may increase the likelihood of success of certain attacks. A long expiration time increases an attacker's chance of successfully guessing a valid session ID. The longer the expiration time, the more concurrent open sessions will exist at any given time. The larger the pool of sessions, the more likely it will be for an attacker to guess one at random. Although a short session inactivity timeout does not help if a token is immediately used, the short timeout helps to insure that the token is harder to capture while it is still valid.

A Web application should invalidate a session after a predefined idle time has passed (a timeout) and provide the user the means to invalidate their own session, i.e. logout; this helps to keep the lifespan of a session ID as short as possible and is necessary in a shared computing environment where more than one person has unrestricted physical access to a computer. The logout function should be prominently visible to the user, explicitly invalidate a user’s session and disallow reuse of the session token.</desc>
	<solution>Set sessions/credentials expiration date.</solution>
	<reference>http://projects.webappsec.org/Insufficient-Session-Expiration</reference>
	<reference>http://cwe.mitre.org/data/definitions/613.html</reference>
</vuln_item_wasc_47>

<vuln_items>wasc_48</vuln_items>
<vuln_item_wasc_48>
	<alert>Insecure Indexing</alert>
	<desc>Insecure Indexing is a threat to the data confidentiality of the web-site. Indexing web-site contents via a process that has access to files which are not supposed to be publicly accessible has the potential of leaking information about the existence of such files, and about their content. In the process of indexing, such information is collected and stored by the indexing process, which can later be retrieved (albeit not trivially) by a determined attacker, typically through a series of queries to the search engine. The attacker does not thwart the security model of the search engine. As such, this attack is subtle and very hard to detect and to foil - it’s not easy to distinguish the attacker’s queries from a legitimate user’s queries.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Insecure-Indexing</reference>
	<reference/>
</vuln_item_wasc_48>

<vuln_items>wasc_49</vuln_items>
<vuln_item_wasc_49>
	<alert>Insufficient Password Recovery</alert>
	<desc>Insufficient Password Recovery is when a web site permits an attacker to illegally obtain, change or recover another user's password. Conventional web site authentication methods require users to select and remember a password or passphrase. The user should be the only person that knows the password and it must be remembered precisely. As time passes, a user's ability to remember a password fades. The matter is further complicated when the average user visits 20 sites requiring them to supply a password.  (RSA Survey: http://news.bbc.co.uk/1/hi/technology/3639679.stm) Thus, password recovery is an important part in servicing online users.

Examples of automated password recovery processes include requiring the user to answer a "secret question" defined as part of the user registration process. This question can either be selected from a list of canned questions or supplied by the user. Another mechanism in use is having the user provide a "hint" during registration that will help the user remember his password. Other mechanisms require the user to provide several pieces of personal data such as their social security number, home address, zip code etc. to validate their identity. After the user has proven who they are, the recovery system will display or e-mail them a new password.

A web site is considered to have Insufficient Password Recovery when an attacker is able to foil the recovery mechanism being used. This happens when the information required to validate a user's identity for recovery is either easily guessed or can be circumvented. Password recovery systems may be compromised through the use of brute force attacks, inherent system weaknesses, or easily guessed secret questions.</desc>
	<solution>Make sure that all input supplied by the user to the password recovery mechanism is thoroughly filtered and validated

Do not use standard weak security questions and use several security questions.

Make sure that there is throttling on the number of incorrect answers to a security question. Disable the password recovery functionality after a certain (small) number of incorrect guesses.

Require that the user properly answers the security question prior to resetting their password and sending the new password to the e-mail address of record.

Never allow the user to control what e-mail address the new password will be sent to in the password recovery mechanism.

Assign a new temporary password rather than revealing the original password.</solution>
	<reference>http://projects.webappsec.org/Insufficient-Password-Recovery</reference>
	<reference>http://cwe.mitre.org/data/definitions/640.html</reference>
</vuln_item_wasc_49>

</vulnerabilities>
