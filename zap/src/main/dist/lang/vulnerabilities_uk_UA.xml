<?xml version="1.0" encoding="utf-8"?>
<vulnerabilities xmlns="http://tempuri.org/XMLSchemaOptions.xsd">

<vuln_items>wasc_1</vuln_items>
<vuln_item_wasc_1>
	<alert>Недостатня авторизація</alert>
	<desc>Недостатня автентифікація виникає, коли вебсайт дозволяє зловмиснику отримати доступ до конфіденційного вмісту або функціональних можливостей без необхідності належної автентифікації. Вебінструменти адміністрування є гарним прикладом вебсайтів, які надають доступ до конфіденційних функцій. Залежно від конкретного онлайн-ресурсу, ці вебпрограми не повинні бути напряму доступні без вимоги користувача належним чином підтвердити свою особу.

Щоб обійти налаштування автентифікації, деякі ресурси захищено шляхом "приховування" конкретного розташування та не пов'язування розташування з основним вебсайтом чи іншими у громадських місцях. Однак цей підхід є нічим іншим, як "Безпека через невідомість". Важливо зрозуміти, що навіть якщо ресурс невідомий зловмиснику, він все одно залишається доступним безпосередньо через певну URL-адресу. Конкретну URL-адресу можна виявити через метод прямого добору для пошуку звичайних файлів і каталогів (наприклад, /admin), повідомлень про помилку, журнали джерел переходу або документації, таких як файли довідки. Ці ресурси, незалежно від того, керуються вони вмістом чи функціональністю, мають бути належним чином захищені.</desc>
	<solution>Фаза: архітектура та дизайн
Використовуйте систему автентифікації або бібліотеку, таку як функція автентифікації OWASP ESAPI.</solution>
	<reference>http://projects.webappsec.org/Insufficient-Authentication</reference>
	<reference>http://cwe.mitre.org/data/definitions/287.html</reference>
	<reference>http://cwe.mitre.org/data/definitions/284.html</reference>
</vuln_item_wasc_1>

<vuln_items>wasc_2</vuln_items>
<vuln_item_wasc_2>
	<alert>Недостатня авторизація</alert>
	<desc>Недостатня авторизація виникає, коли програма не виконує адекватних перевірок авторизації, щоб переконатися, що користувач виконує функцію або отримує доступ до даних у спосіб, який узгоджується з політикою безпеки. Процедури авторизації мають забезпечувати виконання того, що дозволено робити користувачеві, службі чи програмі. Коли користувач автентифікований на вебсайті, це не обов’язково означає, що він повинен мати повний доступ до всього вмісту та функцій.

Недостатня авторизація функції

Багато програм надають різним користувачам різні функціональні можливості.
 Сайт новин дозволить користувачам переглядати новини, але не публікувати їх. Бухгалтерська система матиме різні дозволи для службовця з питань кредиторської заборгованості та працівника з питань дебіторської заборгованості. Недостатня авторизація функцій виникає, коли програма не перешкоджає користувачам отримати доступ до функціональних можливостей програми, порушуючи політику безпеки.

Яскравим прикладом стало зламування процесу подачі заявок у Гарвардську школу бізнесу у 2005 році. Помилка авторизації дозволила користувачам переглядати власні дані, хоча вони не повинні були мати доступ до цієї частини вебсайту.
 
Недостатня авторизація даних

Багато програм розкривають базові ідентифікатори даних в URL-адресі. Наприклад, під час доступу до медичної карти в системі можна мати таку URL-адресу:

http://example.com/RecordView?id=12345

Якщо програма не перевіряє, чи автентифікований користувач має права на читання, вона може показувати користувачеві дані, які користувач не повинен бачити.

Недостатня авторизація даних є більш поширеною, ніж недостатня авторизація функцій, оскільки програмісти зазвичай мають повні знання про функціональні можливості програми, але не завжди мають повний показ всіх даних, до яких програма матиме доступ. Програмісти часто мають жорсткий контроль над механізмами авторизації функцій, але покладаються на інші системи, такі як бази даних для виконання авторизації даних.</desc>
	<solution>Фази: Архітектура та Дизайн; Операція
Дуже ретельно керуйте налаштуванням, керуванням і обробкою привілеїв. Явно керуйте зонами довіри в програмному забезпеченні.

Фаза: Архітектура та Дизайн
Переконайтеся, що відповідна класифікація вбудована в проєктування системи, і що класифікація служить для забезпечення та подальшого посилення привілеїв розділення функції. Архітектори та дизайнери повинні покладатися на принцип найменших привілеїв, щоб вирішити, коли доцільно використовувати та відмовитися від системних привілеїв.</solution>
	<reference>http://projects.webappsec.org/Insufficient-Authorization</reference>
	<reference>http://cwe.mitre.org/data/definitions/284.html</reference>
	<reference>http://cwe.mitre.org/data/definitions/285.html</reference>
</vuln_item_wasc_2>

<vuln_items>wasc_3</vuln_items>
<vuln_item_wasc_3>
	<alert>Переповнення цілих чисел</alert>
	<desc>Переповнення цілого числа- це умова, що виникає, коли результат арифметичної операції, наприклад множення або додавання, перевищує максимальний розмір типу цілого числа, який використовується для його зберігання. Коли відбувається переповнення цілого числа, здається, що інтерпретоване значення "обернуло" максимальне значення та розпочалося знову з мінімального значення, подібно до годинника, який показує 13:00, вказуючи на 1:00.

Наприклад, 8-розрядне число зі знаком на більшості поширених комп'ютерних побудов має максимальне значення 127 і мінімальне значення -128. Якщо програміст зберігає значення 127 у такій змінній і додає до нього 1, результат має бути 128. Однак це значення перевищує максимальне для цього типу цілого числа, тому інтерпретоване значення буде  "розгорнуто" і стане -128.</desc>
	<solution>Фаза: Вимоги
Переконайтеся, що всі протоколи чітко визначені, щоб усю поведінку поза межами можна було легко ідентифікувати, і вимагають суворої відповідності протоколу.

Фаза: Вимоги
Використовуйте мову, яка не допускає виникнення цих слабких сторін, або надає конструкції, які полегшують уникнення цих слабких сторін.
Якщо можливо, виберіть мову або компілятор, який виконує автоматичну перевірку меж.

Фаза: Архітектура і Дизайн
Використовуйте перевірену бібліотеку чи структуру, які запобігають виникненню цієї слабкості або надають конструкції, які полегшують уникнення цієї слабкості.
Використовуйте бібліотеки або структури, які полегшують обробку чисел без неочікуваних наслідків.
Приклади включають безпечні пакети обробки цілих чисел, такі як Safelnt (C++) або IntegerLib (C або C++).

Фаза: Впровадження
Виконайте перевірку будь-якого числового введення, переконавшись, що воно знаходиться в очікуваному діапазоні. Переконайтеся, що вхідні дані відповідають як мінімальним, так і максимальним вимогам для очікуваного діапазону.
Використовуйте цілі числа без знаку, де це можливо. Це спрощує виконання перевірки працездатності для переповнень цілих чисел. Якщо необхідно використовувати цілі числа зі знаком, переконайтеся, що ваша перевірка діапазону містить як мінімальні, так і максимальні значення.

Фаза: Впровадження
Зрозумійте базове представлення вашої мови програмування та те, як воно взаємодіє з числовими розрахунками (CWE-681). Зверніть особливу увагу на розбіжності в розмірі байтів, точність, відмінності зі знаком/ без знаку, зріз, перетворення та приведення між типами, обчислення "не числа" та те, як ваша мова обробляє числа, які є занадто великими для свого основного представлення.
Також уважно враховуйте 32-бітні, 64-бітні та інші потенційні відмінності, які можуть вплинути на числове представлення.

Фаза: Впровадження
Уважно вивчіть попередження компілятора та усуньте потенційно критичні проблеми безпеки, такі як невідповідність знака/без знаку. Навіть якщо слабкість рідко вдається використати, один збій може призвести до зламу всієї системи.</solution>
	<reference>http://projects.webappsec.org/Integer-Overflows</reference>
	<reference>http://cwe.mitre.org/data/definitions/190.html</reference>
</vuln_item_wasc_3>

<vuln_items>wasc_4</vuln_items>
<vuln_item_wasc_4>
	<alert>Недостатній захист транспортного рівня</alert>
	<desc>Недостатній захист транспортного рівня
Недостатній рівень захисту транспортного рівня дозволяє комунікації бути відкритим для ненадійних третіх сторін, створюючи вектор атаки для компрометації вебпрограми та/або викрадення конфіденційної інформації. Вебсайти зазвичай використовують Secure Sockets Layer / Transport Layer Security (SSL/TLS) для забезпечення шифрування на транспортному рівні. Однак, якщо вебсайт не налаштовано на використання SSL/TLS і не налаштовано на належне використання SSL/TLS, вебсайт може бути вразливим до перехоплення та модифікації трафіку.
 
Відсутність шифрування транспортного рівня
Коли транспортний рівень не зашифрований, усі повідомлення між вебсайтом і клієнтом надсилаються у відкритому вигляді, що залишає його відкритим для перехоплення, введення та перенаправлення (також відомого як атака "людина посередині"/MITM). Зловмисник може пасивно перехопити зв’язок, отримавши доступ до будь-яких конфіденційних даних, які передаються, наприклад імен користувачів і паролів. Зловмисник також може активно вводити/вилучати вміст зі зв’язку, дозволяючи зловмиснику підробляти та пропускати інформацію, впроваджувати шкідливі сценарії або змусити клієнта отримати доступ до віддаленого ненадійного вмісту. Зловмисник також може перенаправити зв’язок таким чином, що вебсайт і клієнт більше не спілкуються один з одним, а натомість несвідомо спілкуються зі зловмисником у контексті іншої довіреної сторони.

Слабка підтримка шифру
Історично експорт високоякісної криптографії за межі Сполучених Штатів був обмежений. Через це вебсайти були налаштовані на підтримку слабких криптографічних параметрів для тих клієнтів, які були обмежені використанням лише слабких шифрів. Слабкі шифри вразливі до атак через відносну легкість їх зламу; менш ніж два тижні на звичайному домашньому комп’ютері та кілька секунд із використанням спеціального обладнання.
Сьогодні всі сучасні браузери та вебсайти використовують набагато надійніше шифрування, але деякі вебсайти все ще налаштовані на підтримку застарілих слабких шифрів. Через це зловмисник може змусити клієнта повернутися до слабшого шифру під час підключення до вебсайту, дозволяючи зловмиснику зламати слабке шифрування. З цієї причини сервер має бути налаштований на прийняття лише надійних шифрів і не надавання послуг будь-якому клієнту, який запитує використання слабшого шифру. Крім того, деякі вебсайти неправильно налаштовані на вибір слабшого шифру, навіть якщо клієнт підтримує набагато сильніший. OWASP пропонує посібник з тестування на наявність проблем з SSL/TLS, зокрема слабку підтримку шифрів і неправильну конфігурацію, а також інші ресурси та інструменти.</desc>
	<solution>Фаза: Вимоги
Чітко визначте, які дані чи ресурси є достатньо цінними, щоб їх можна було захистити за допомогою шифрування. Вимагайте, щоб будь-яка передача або зберігання цих даних або ресурсів використовувала добре перевірені алгоритми шифрування.

Фаза: Архітектура та дизайн
Використовуючи моделювання загроз або інші методи, припустіть, що ваші дані можуть бути скомпрометовані через окрему вразливість або слабкість, і визначте, де шифрування буде найбільш ефективним. Переконайтеся, що дані, які, на вашу думку, мають бути приватними, не були випадково розкриті через такі вразливості, як ненадійні дозволи (CWE-732).

Фаза: Архітектура та Дизайн
Переконайтеся, що шифрування інтегровано належним чином в макет системи, включаючи, але не обов'язково обмежуючись:
      Шифрування необхідне для зберігання або передачі особистих даних користувачів системи
      Шифрування необхідне для захисту самої системи від неавторизованого розголошення або втручання 
Визначте окремі потреби та контексти для шифрування:
      Односторонній (тобто лише користувач або одержувач повинен мати ключ). Цього можна досягти за допомогою криптографії з відкритим ключем або інших методів, в яких стороні, що шифрує (тобто програмному забезпеченню), не потрібно мати доступ до закритого ключа.
      Двостороннє (тобто шифрування може автоматично виконуватися від імені користувача, але ключ повинен бути доступним, щоб користувач міг автоматично відновити відкритий текст). Це вимагає зберігання приватного ключа у форматі, який може бути відновлений лише користувачем (або, можливо, операційною системою) у спосіб, який не може бути відновлений іншими.

Фаза: Архітектура та дизайн
Не розробляйте власні криптографічні алгоритми. Вони, швидше за все, будуть піддаватися атакам, які добре зрозумілі криптографам. Методи зворотного проєктування є зрілими. Якщо ваш алгоритм може бути скомпрометований, якщо зловмисники дізнаються, як він працює, тоді він особливо слабкий.

Фаза: Архітектура та дизайн
Виберіть добре перевірений алгоритм, який наразі вважається сильним серед експертів у цій галузі, і виберіть добре протестовані реалізації.
Наприклад, урядові системи США вимагають сертифікації за стандартом FIPS 140-2.
Як і у випадку з усіма криптографічними механізмами, вихідний код повинен бути доступний для аналізу.
Періодично перевіряйте, чи не використовуєте ви застарілу криптографію. Деякі старіші алгоритми, які колись вважалися такими, що потребують мільярд років обчислювального часу, тепер можуть бути зламані за кілька днів або годин. Сюди входять MD4, MD5, SHA1, DES та інші алгоритми, які колись вважалися надійними.

Фаза: Архітектура та дизайн
Розділіть вашу систему на "безпечні" області, де можна чітко окреслити межі довіри. Не дозволяйте конфіденційним даним виходити за межі довіри та завжди будьте обережні під час взаємодії з простором за межами безпечної зони.

Фази: Впровадження, архітектура та дизайн
Коли ви використовуєте схвалені в індустрії методи, ви повинні використовувати їх правильно. Не економте час, пропускаючи ресурсомісткі етапи (CWE-325). Ці кроки часто необхідні для запобігання поширеним атакам.

Фаза: Впровадження
Використовуйте угоди про імена та сильні типи, щоб легше виявляти, коли використовуються конфіденційні дані. Створюючи структури, об’єкти чи інші складні сутності, якомога більше розділяйте конфіденційні та неконфіденційні дані.
Це полегшує виявлення місць у коді, де використовуються незашифровані дані.</solution>
	<reference>http://projects.webappsec.org/Insufficient-Transport-Layer-Protection</reference>
	<reference>http://cwe.mitre.org/data/definitions/311.html</reference>
</vuln_item_wasc_4>

<vuln_items>wasc_5</vuln_items>
<vuln_item_wasc_5>
	<alert>Віддалене включення файлів</alert>
	<desc>Remote File Include (RFI) — це техніка атаки, яка застосовується для використання механізмів «динамічного охоплення файлів» у вебдодатках. Коли вебпрограми приймають введені користувачем дані (URL-адреса, значення параметра тощо) і передають їх у команди охоплення файлів, вебпрограму можуть обманом включити віддалені файли зі шкідливим кодом.

Майже всі структури вебдодатків підтримують охоплення файлів. Охоплення файлів в основному використовується для упакування загального коду в окремі файли, на які пізніше посилаються головні модулі програми. Коли вебдодаток посилається на файл охоплення, код у цьому файлі може бути виконано неявно або явно шляхом виклику певних процедур. Якщо вибір модуля для завантаження базується на елементах запиту HTTP, вебпрограма може бути вразливою до RFI.
Зловмисник може використовувати RFI для:
    * Запуск шкідливого коду на сервері: будь-який код у включених шкідливих файлах запускатиметься сервером. Якщо включення файлу не виконується за допомогою якоїсь оболонки, код в охоплених файлах виконується в контексті користувача сервера. Це може призвести до повного збою системи.
    * Запуск шкідливого коду на клієнтах: шкідливий код зловмисника може маніпулювати вмістом відповіді, надісланої клієнту. Зловмисник може вбудувати шкідливий код у відповідь, яка буде запущена клієнтом (наприклад, JavaScript для викрадення сесійних файлів cookie клієнта).

PHP особливо вразливий до RFI-атак через широке використання «файлових охоплень» у програмуванні PHP і через стандартні конфігурації сервера, які підвищують сприйнятливість до RFI-атак.</desc>
	<solution>Фаза: Архітектура та Дизайн
Якщо набір прийнятних об’єктів, наприклад імен файлів або URL-адрес, обмежений або відомий, створіть зіставлення з набору фіксованих вхідних значень (наприклад, числових ідентифікаторів) на фактичні імена файлів або URL-адреси та відхиліть усі інші вхідні дані.
Наприклад, ідентифікатор 1 може зіставлятися з "inbox.txt", а ідентифікатор 2 – з "profile.txt". Такі функції, як ESAPI AccessReferenceMap, надають цю можливість.

Фаза: Архітектура та Дизайн; Виконання
Запустіть свій код у "в'язниці" або подібному середовищі ізольованого програмного середовища, яке забезпечує суворі межі між обробкою та операційною системою. Це може фактично обмежити, до яких файлів можна отримати доступ у певному каталозі або до того, які команди може виконувати ваше програмне забезпечення.
Приклади на рівні ОС включають Unix chroot jail, AppArmor і SELinux. Загалом, керований код може забезпечити певний захист. Наприклад, java.io.FilePermission в Java SecurityManager дозволяє вказати обмеження на операції з файлами.
Це може бути неможливим рішенням, і воно обмежує вплив лише на операційну систему; решта вашої програми все ще може бути скомпрометована.
Будьте обережні, щоб уникнути CWE-243 та інших слабких місць, пов’язаних із в’язницями.
Для PHP транслятор пропонує такі обмеження, як відкритий базовий каталог або безпечний режим, що може ускладнити зловмиснику вихід із програми. Також розгляньте Suhosin, посилене розширення PHP, яке містить різні параметри, які вимикають деякі з найнебезпечніших функцій PHP.

Фаза: Впровадження
Припустимо, що всі введені дані є шкідливими. Використовуйте стратегію перевірки вхідних даних «прийняти наперед хороші», тобто використовуйте дозволений список прийнятних вхідних даних, які чітко відповідають специфікаціям. Відхиліть будь-які вхідні дані, які не повністю відповідають специфікаціям, або перетворіть їх на щось, що відповідає. Не покладайтеся виключно на пошук зловмисних або некоректних даних (тобто не покладайтеся на список заборонених). Однак списки заборони можуть бути корисними для виявлення потенційних атак або визначення того, які вхідні дані є настільки неправильними, що їх слід відхилити.
Виконуючи перевірку вхідних даних, враховуйте всі потенційно важливі властивості, включаючи довжину, тип вхідних даних, повний діапазон прийнятних значень, відсутні або додаткові вхідні дані, синтаксис, узгодженість пов’язаних полів і відповідність бізнес-правилам. Як приклад логіки бізнес-правил, «човен» може бути синтаксично допустимим, оскільки містить лише буквено-цифрові символи, але він недійсний, якщо ви очікуєте такі кольори, як «червоний» або «синій».
Для імен файлів використовуйте суворі дозволені списки, які обмежують набір символів, який буде використовуватися. Якщо це можливо, дозвольте лише один "." символ у назві файлу, щоб уникнути недоліків, таких як CWE-23, і виключити роздільники каталогів, такі як "/", щоб уникнути CWE-36. Використовуйте дозволений список дозволених розширень файлів, що допоможе уникнути CWE-434.

Фаза: Архітектура та дизайн; Виконання
Якщо це можливо, зберігайте бібліотечні, охоплені та службові файли поза коренем вебдокумента. В іншому випадку зберігайте їх в окремому каталозі та використовуйте можливості керування доступом вебсервера, щоб запобігти зловмисникам безпосередньо запитувати їх. Однією з поширених практик є визначення фіксованої константи в кожній програмі виклику, а потім перевірка існування константи в бібліотеці/файлі включення; якщо константа не існує, це означає, що файл був запрошений безпосередньо, і його можна негайно завершити.
Це значно зменшує ймовірність того, що зловмисник зможе обійти будь-які механізми захисту, які є в базовій програмі, але не у файлах включення. Це також зменшить вашу поверхню атаки.

Фаза: Архітектура та Дизайн; Впровадження
Зрозумійте всі потенційні області, куди ненадійні дані можуть потрапити у ваше програмне забезпечення: параметри чи аргументи, файли cookie, усе, що зчитується з мережі, змінні середовища, зворотні пошуки DNS, результати запитів, заголовки запитів, компоненти URL-адрес, електронна пошта, файли, бази даних і будь-які зовнішні системи, які надають дані програмі. Пам’ятайте, що такі вхідні дані можна отримати опосередковано через виклики API.
Багато проблем із включенням файлів виникають через те, що програміст припустив, що певні вхідні дані не можна змінити, особливо для файлів cookie та компонентів URL-адреси.</solution>
	<reference>http://projects.webappsec.org/Remote-File-Inclusion</reference>
	<reference>http://cwe.mitre.org/data/definitions/98.html</reference>
</vuln_item_wasc_5>

<vuln_items>wasc_6</vuln_items>
<vuln_item_wasc_6>
	<alert>Рядок форматування</alert>
	<desc>Атаки рядків форматування змінюють потік програми, використовуючи функції бібліотеки форматування рядків для доступу до іншого простору пам’яті. Вразливі місця виникають, коли надані користувачем дані використовуються безпосередньо як рядок форматування для певних функцій C/C++ (наприклад, fprintf, printf, sprintf, setproctitle, syslog тощо).

Якщо зловмисник передає рядок форматування, що складається з символів перетворення printf (наприклад, "%f", "%p", "%n" тощо) як значення параметра до вебпрограми, він може:
    * Виконувати довільний код на сервері
    * Читати значення зі стека
    * Спричиняти помилки сегментації / збої програмного забезпечення

Атаки рядку форматування пов’язані з іншими атаками в класифікації загроз: переповнення буфера та переповнення цілого числа. Усі три засновані на своїй здатності маніпулювати пам’яттю або її інтерпретацією таким чином, щоб сприяти досягненню мети зловмисника.</desc>
	<solution>Фаза: Вимоги
Виберіть мову, яка не має цього дефекту.

Фаза: Впровадження
Переконайтеся, що всім функціям рядка форматування передається статичний рядок, який не може контролювати користувач, і що відповідна кількість аргументів також завжди надсилається цій функції. Якщо можливо, використовуйте функції, які не підтримують оператор %n у рядках форматування.
Збірка: Зверніть увагу на попередження компіляторів і компонувальників, оскільки вони можуть попередити вас про неправильне використання.
</solution>
	<reference>http://projects.webappsec.org/Format-String</reference>
	<reference>http://cwe.mitre.org/data/definitions/134.html</reference>
</vuln_item_wasc_6>

<vuln_items>wasc_7</vuln_items>
<vuln_item_wasc_7>
	<alert>Переповнення буферу</alert>
	<desc>Переповнення буфера — це недолік, який виникає, коли в блок пам’яті або буфер записується більше даних, ніж призначено для зберігання. Використання переповнення буфера дозволяє зловмиснику змінювати частини адресного простору цільового процесу. Цю здатність можна використовувати для багатьох цілей, зокрема:
    * Контролювати виконання процесу
    * Щоб збити процес
    * Змінити внутрішні змінні

Метою зловмисника майже завжди є контроль за виконанням цільового процесу. Це досягається шляхом визначення покажчика функції в пам'яті, який можна змінити, прямо чи опосередковано, за допомогою переповнення. Коли такий вказівник використовується програмою для керування виконанням програми через інструкцію переходу або виклику, буде використано розташування інструкції, надане зловмисником, таким чином дозволяючи зловмисникові контролювати процес.

У багатьох випадках покажчик функції змінюється, щоб посилатися на місце, де зловмисник розмістив зібрані інструкції для конкретної машини. Ці інструкції зазвичай називають шелл-кодом, оскільки зловмисники часто хочуть створити середовище командного рядка або оболонку в контексті запущеного процесу.

Переповнення буфера найчастіше пов’язане з програмним забезпеченням, написаним на мовах програмування C і C++ через їх широке використання та здатність виконувати прямі маніпуляції з пам’яттю за допомогою звичайних конструкцій програмування. Однак слід підкреслити, що переповнення буфера може існувати в будь-якому середовищі програмування, де дозволено пряме маніпулювання пам’яттю через недоліки в компіляторі, бібліотеках виконання або особливостях самої мови.
</desc>
	<solution>Фаза: Вимоги
Використовуйте мову, яка не допускає виникнення цих слабких сторін, або надає конструкції, які полегшують уникнення цих слабких сторін.
Наприклад, багато мов, які здійснюють власне керування пам’яттю, такі як Java і Perl, не підлягають переповненню буфера. Інші мови, такі як Ada та C#, зазвичай забезпечують захист від переповнення, але захист може бути відключений програмістом.
Майте на увазі, що інтерфейс мови до рідного коду все ще може зазнавати переповнень, навіть якщо сама мова теоретично безпечна.

Фаза: Архітектура і Дизайн
Використовуйте перевірену бібліотеку чи структуру, які запобігають виникненню цієї слабкості або надають конструкції, які полегшують уникнення цієї слабкості.
Приклади включають бібліотеку Safe C String Library (SafeStr) від Messier і Viega та бібліотеку Strsafe.h від Microsoft. Ці бібліотеки забезпечують безпечніші версії функцій обробки рядків, схильних до переповнення. Це не повне рішення, оскільки багато переповнень буфера не пов’язані з рядками.

Фаза: Збірка та Компіляція
Запустіть або скомпілюйте програмне забезпечення за допомогою функцій або розширень, які автоматично забезпечують механізм захисту, який пом’якшує або усуває переповнення буфера.
Наприклад, певні компілятори та розширення забезпечують механізми автоматичного виявлення переповнення буфера, вбудовані в скомпільований код. Examples include the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY SOURCE GCC flag, StackGuard, and ProPolice.

Фаза: Впровадження
Розгляньте дотримання наступних правил під час розподілу та керування пам’яттю програми:
      Двічі переконайтеся, що ваш буфер такий великий, як ви вказали.
      Використовуючи функції, які приймають певну кількість байтів для копіювання, наприклад strncpy(), майте на увазі, що якщо розмір буфера призначення дорівнює розміру буфера джерела, він може не завершувати рядок NULL.
      Перевірте межі буфера, якщо ця функція викликається в циклі, і переконайтеся, що вам не загрожує запис за межі виділеного простору.
      Якщо необхідно, обріжте всі вхідні рядки до прийнятної довжини перед тим, як передати їх функціям копіювання та злиття.

Фаза: Виконання
Використовуйте таку функцію, як рандомізація адресного простору (ASLR).

Phase: Operation

Use a CPU and operating system that offers Data Execution Protection (NX) or its equivalent.

Замініть функції необмеженого копіювання на аналогічні функції, які підтримують аргументи довжини, наприклад strcpy на strncpy. Створіть їх, якщо вони недоступні.
</solution>
	<reference>http://projects.webappsec.org/Buffer-Overflow</reference>
	<reference>http://cwe.mitre.org/data/definitions/119.html</reference>
</vuln_item_wasc_7>

<vuln_items>wasc_8</vuln_items>
<vuln_item_wasc_8>
	<alert>Міжсайтовий сценарій</alert>
	<desc>Міжсайтовий сценарій (XSS) — це техніка атаки, яка включає відтворення наданого зловмисником коду в екземпляр вебпереглядача користувача. Екземпляр браузера може бути стандартним клієнтом веббраузера або об’єктом браузера, вбудованим у програмний продукт, такий як браузер у WinAmp, програма для читання RSS або клієнт електронної пошти. Сам код зазвичай пишеться на HTML/JavaScript, але також може поширюватися на VBScript, ActiveX, Java, Flash або будь-яку іншу технологію, що підтримується браузером.
Коли зловмисник змушує браузер користувача виконувати його/її код, код запускатиметься в контексті безпеки (або зоні) вебсайту хостингу. З цим рівнем привілеїв код має можливість читати, змінювати та передавати будь-які конфіденційні дані, доступні браузеру. A Cross-site Scripted user could have his/her account hijacked (cookie theft), their browser redirected to another location, or possibly shown fraudulent content delivered by the web site they are visiting. Міжсайтові скриптові атаки по суті підривають довірчі стосунки між користувачем і вебсайтом. Програми, що використовують екземпляри об’єктів браузера, які завантажують вміст із файлової системи, можуть виконувати код у зоні локального комп’ютера, що дозволяє компрометувати систему.

Існує три типи міжсайтових скриптових атак: непостійні, постійні та на основі DOM.
Непостійні атаки та атаки на основі DOM вимагають від користувача або переходу за спеціально створеним посиланням, доповненим шкідливим кодом, або відвідування шкідливої вебсторінки, що містить вебформу, розміщення якої на вразливому сайті спричиняє атаку. Using a malicious form will oftentimes take place when the vulnerable resource only accepts HTTP POST requests. In such a case, the form can be submitted automatically, without the victim's knowledge (e.g. by using JavaScript). Upon clicking on the malicious link or submitting the malicious form, the XSS payload will get echoed back and will get interpreted by the user's browser and execute. Another technique to send almost arbitrary requests (GET and POST) is by using an embedded client, such as Adobe Flash.
Persistent attacks occur when the malicious code is submitted to a web site where it's stored for a period of time. Examples of an attacker's favorite targets often include message board posts, web mail messages, and web chat software. The unsuspecting user is not required to interact with any additional site/link (e.g. an attacker site or a malicious link sent via email), just simply view the web page containing the code.</desc>
	<solution>Фаза: Архітектура і Дизайн
Використовуйте перевірену бібліотеку чи структуру, які запобігають виникненню цієї слабкості або надають конструкції, які полегшують уникнення цієї слабкості.
Examples of libraries and frameworks that make it easier to generate properly encoded output include Microsoft's Anti-XSS library, the OWASP ESAPI Encoding module, and Apache Wicket.

Phases: Implementation; Architecture and Design
Understand the context in which your data will be used and the encoding that will be expected. This is especially important when transmitting data between different components, or when generating outputs that can contain multiple encodings at the same time, such as web pages or multi-part mail messages. Study all expected communication protocols and data representations to determine the required encoding strategies.
For any data that will be output to another web page, especially any data that was received from external inputs, use the appropriate encoding on all non-alphanumeric characters.
Consult the XSS Prevention Cheat Sheet for more details on the types of encoding and escaping that are needed.

Phase: Architecture and Design
For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.

If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated.

Phase: Implementation
For every web page that is generated, use and specify a character encoding such as ISO-8859-1 or UTF-8. When an encoding is not specified, the web browser may choose a different encoding by guessing which encoding is actually being used by the web page. This can cause the web browser to treat certain sequences as special, opening up the client to subtle XSS attacks. See CWE-116 for more mitigations related to encoding/escaping.

To help mitigate XSS attacks against the user's session cookie, set the session cookie to be HttpOnly. In browsers that support the HttpOnly feature (such as more recent versions of Internet Explorer and Firefox), this attribute can prevent the user's session cookie from being accessible to malicious client-side scripts that use document.cookie. This is not a complete solution, since HttpOnly is not supported by all browsers. More importantly, XMLHTTPRequest and other powerful browser technologies provide read access to HTTP headers, including the Set-Cookie header in which the HttpOnly flag is set.

Assume all input is malicious. Використовуйте стратегію перевірки вхідних даних «прийняти наперед хороші», тобто використовуйте дозволений список прийнятних вхідних даних, які чітко відповідають специфікаціям. Відхиліть будь-які вхідні дані, які не повністю відповідають специфікаціям, або перетворіть їх на щось, що відповідає. Не покладайтеся виключно на пошук зловмисних або некоректних даних (тобто не покладайтеся на список заборонених). Однак списки заборони можуть бути корисними для виявлення потенційних атак або визначення того, які вхідні дані є настільки неправильними, що їх слід відхилити.

Виконуючи перевірку вхідних даних, враховуйте всі потенційно важливі властивості, включаючи довжину, тип вхідних даних, повний діапазон прийнятних значень, відсутні або додаткові вхідні дані, синтаксис, узгодженість пов’язаних полів і відповідність бізнес-правилам. Як приклад логіки бізнес-правил, «човен» може бути синтаксично допустимим, оскільки містить лише буквено-цифрові символи, але він недійсний, якщо ви очікуєте такі кольори, як «червоний» або «синій».

Ensure that you perform input validation at well-defined interfaces within the application. This will help protect the application even if a component is reused or moved elsewhere.
	</solution>
	<reference>http://projects.webappsec.org/Cross-Site-Scripting</reference>
	<reference>http://cwe.mitre.org/data/definitions/79.html</reference>
</vuln_item_wasc_8>

<vuln_items>wasc_9</vuln_items>
<vuln_item_wasc_9>
	<alert>Cross Site Request Forgery</alert>
	<desc>A cross-site request forgery is an attack that involves forcing a victim to send an HTTP request to a target destination without their knowledge or intent in order to perform an action as the victim. The underlying cause is application functionality using predictable URL/form actions in a repeatable way. The nature of the attack is that CSRF exploits the trust that a web site has for a user. By contrast, cross-site scripting (XSS) exploits the trust that a user has for a web site. Like XSS, CSRF attacks are not necessarily cross-site, but they can be. Cross-site request forgery is also known as CSRF, XSRF, one-click attack, session riding, confused deputy, and sea surf.

CSRF attacks are effective in a number of situations, including:
    * The victim has an active session on the target site.
    * The victim is authenticated via HTTP auth on the target site.
    * The victim is on the same local network as the target site.

CSRF has primarily been used to perform an action against a target site using the victim's privileges, but recent techniques have been discovered to disclose information by gaining access to the response. The risk of information disclosure is dramatically increased when the target site is vulnerable to XSS, because XSS can be used as a platform for CSRF, allowing the attack to operate within the bounds of the same-origin policy.</desc>
	<solution>Фаза: Архітектура і Дизайн
Використовуйте перевірену бібліотеку чи структуру, які запобігають виникненню цієї слабкості або надають конструкції, які полегшують уникнення цієї слабкості.
For example, use anti-CSRF packages such as the OWASP CSRFGuard.

Phase: Implementation
Ensure that your application is free of cross-site scripting issues, because most CSRF defenses can be bypassed using attacker-controlled script.

Phase: Architecture and Design
Generate a unique nonce for each form, place the nonce into the form, and verify the nonce upon receipt of the form. Be sure that the nonce is not predictable (CWE-330).
Note that this can be bypassed using XSS.

Identify especially dangerous operations. When the user performs a dangerous operation, send a separate confirmation request to ensure that the user intended to perform that operation.
Note that this can be bypassed using XSS.

Use the ESAPI Session Management control.
This control includes a component for CSRF.

Do not use the GET method for any request that triggers a state change.

Phase: Implementation
Check the HTTP Referer header to see if the request originated from an expected page. This could break legitimate functionality, because users or proxies may have disabled sending the Referer for privacy reasons.</solution>
	<reference>http://projects.webappsec.org/Cross-Site-Request-Forgery</reference>
	<reference>http://cwe.mitre.org/data/definitions/352.html</reference>
</vuln_item_wasc_9>

<vuln_items>wasc_10</vuln_items>
<vuln_item_wasc_10>
	<alert>Denial of Service</alert>
	<desc>Denial of Service (DoS) is an attack technique with the intent of preventing a web site from serving normal user activity. DoS attacks, which are easily normally applied to the network layer, are also possible at the application layer. These malicious attacks can succeed by starving a system of critical resources, vulnerability exploit, or abuse of functionality.

Many times DoS attacks will attempt to consume all of a web site's available system resources such as: CPU, memory, disk space etc. When any one of these critical resources reach full utilization, the web site will normally be inaccessible.

As today's web application environments include a web server, database server and an authentication server, DoS at the application layer may target each of these independent components. Unlike DoS at the network layer, where a large number of connection attempts are required, DoS at the application layer is a much simpler task to perform.</desc>
	<solution>Phase: Architecture and Design

Design throttling mechanisms into the system architecture. The best protection is to limit the amount of resources that an unauthorized user can cause to be expended. A strong authentication and access control model will help prevent such attacks from occurring in the first place. The login application should be protected against DoS attacks as much as possible. Limiting the database access, perhaps by caching result sets, can help minimize the resources expended. To further limit the potential for a DoS attack, consider tracking the rate of requests received from users and blocking requests that exceed a defined rate threshold.

Mitigation of resource exhaustion attacks requires that the target system either:
      recognizes the attack and denies that user further access for a given amount of time, or
      uniformly throttles all requests in order to make it more difficult to consume resources more quickly than they can again be freed. 

The first of these solutions is an issue in itself though, since it may allow attackers to prevent the use of the system by a particular valid user. If the attacker impersonates the valid user, he may be able to prevent the user from accessing the server in question.

The second solution is simply difficult to effectively institute -- and even when properly done, it does not provide a full solution. It simply makes the attack require more resources on the part of the attacker.

Ensure that protocols have specific limits of scale placed on them.

Phase: Implementation
Ensure that all failures in resource allocation place the system into a safe posture.</solution>
	<reference>http://projects.webappsec.org/Denial-of-Service</reference>
	<reference>http://cwe.mitre.org/data/definitions/400.html</reference>
</vuln_item_wasc_10>

<vuln_items>wasc_11a</vuln_items>
<vuln_item_wasc_11a>
	<alert>Brute Forcing Log-in Credentials</alert>
	<desc>A brute force attack is a method to determine an unknown value by using an automated process to try a large number of possible values. The attack takes advantage of the fact that the entropy of the values is smaller than perceived. For example, while an 8 character alphanumeric password can have 2.8 trillion possible values, many people will select their passwords from a much smaller subset consisting of common words and terms.

The most common type of a brute force attack in web applications is an attack against log-in credentials. Since users need to remember passwords, they often select easy to memorize words or phrases as passwords, making a brute force attack using a dictionary useful. Such an attack attempting to log-in to a system using a large list of words and phrases as potential passwords is often called a "word list attack" or a "dictionary attack". Attempted passwords may also include variations of words common to passwords such as those generated by replacing "o" with "0" and "i" with "1" as well as personal information including family member names, birth dates and phone numbers.
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Brute-Force</reference>
	<reference>TBA</reference>
</vuln_item_wasc_11a>

<vuln_items>wasc_11b</vuln_items>
<vuln_item_wasc_11b>
	<alert>Brute Forcing Session Identifiers</alert>
	<desc>A brute force attack is a method to determine an unknown value by using an automated process to try a large number of possible values. The attack takes advantage of the fact that the entropy of the values is smaller than perceived. For example, while an 8 character alphanumeric password can have 2.8 trillion possible values, many people will select their passwords from a much smaller subset consisting of common words and terms.

Since HTTP is a stateless protocol, in order to maintain state web applications need to ensure that a session identifier is sent by the browser with each request. The session identifier is most commonly stored in an HTTP cookie or URL. Using a brute force attack, an attacker can guess the session identifier of another user. This can lead to the attacker impersonating the user, retrieving personal information and performing actions on behalf of the user.
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Brute-Force</reference>
	<reference>TBA</reference>
</vuln_item_wasc_11b>

<vuln_items>wasc_11c</vuln_items>
<vuln_item_wasc_11c>
	<alert>Brute Forcing Directories and Files</alert>
	<desc>A brute force attack is a method to determine an unknown value by using an automated process to try a large number of possible values. The attack takes advantage of the fact that the entropy of the values is smaller than perceived. For example, while an 8 character alphanumeric password can have 2.8 trillion possible values, many people will select their passwords from a much smaller subset consisting of common words and terms.

When files reside in directories that are served by the web server but are not linked anywhere, accessing those files requires knowing their file name. In some cases those files have been left by mistake: for example a backup file automatically created when editing a file or leftovers from an older version of the web application. In other cases files are intentionally left unlinked as a "security by obscurity" mechanism allowing only people who know the file names to access them.

A brute force attack tries to locate the unlinked file by trying to access a large number of files. The list of attempted file names might be taken from a list of known potential files or based on variants of the visible files on the web site. More information on brute forcing directories and files can be found in the associated vulnerability, predictable resource location.
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Brute-Force</reference>
	<reference>TBA</reference>
</vuln_item_wasc_11c>

<vuln_items>wasc_11d</vuln_items>
<vuln_item_wasc_11d>
	<alert>Brute Forcing Credit Card Information</alert>
	<desc>A brute force attack is a method to determine an unknown value by using an automated process to try a large number of possible values. The attack takes advantage of the fact that the entropy of the values is smaller than perceived. For example, while an 8 character alphanumeric password can have 2.8 trillion possible values, many people will select their passwords from a much smaller subset consisting of common words and terms.

Shopping online with stolen credit cards usually requires information in addition to the credit card number, most often the CVV/SCS and/or expiration date. A fraudster may hold a stolen credit card number without the additional information. For example the CVV/CSC is not imprinted on the card or stored on the magnetic stripe so it cannot be collected by mechanical or magnetic credit card swiping devices.

In order to fill in the missing information the hacker can guess the missing information using a brute force technique, trying all possible values.
    * Guessing CVV/CSC requires only 1000 or 10000 attempts as the number is only 3 or 4 digits, depending on the card type.
    * Guessing an expiration date requires only several dozen attempts.
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Brute-Force</reference>
	<reference>TBA</reference>
</vuln_item_wasc_11d>

<vuln_items>wasc_12</vuln_items>
<vuln_item_wasc_12>
	<alert>Content Spoofing</alert>
	<desc>Content Spoofing is an attack technique that allows an attacker to inject a malicious payload that is later misrepresented as legitimate content of a web application.
 
Text Only Content Spoofing
A common approach to dynamically build pages involves passing the body or portions thereof into the page via a query string value. This approach is common on error pages, or sites providing story or news entries. The content specified in this parameter is later reflected into the page to provide the content for the page.
 
Markup Reflected Content Spoofing
Some web pages are served using dynamically built HTML content sources. For example, the source location of a frame <frame src="http://foo.example/file.html"/>) could be specified by a URL parameter value. (http://foo.example/page?frame_src=http://foo.example/file.html). An attacker may be able to replace the "frame_src" parameter value with "frame_src=http://attacker.example/spoof.html". Unlike redirectors, when the resulting web page is served the browser location bar visibly remains under the user expected domain (foo.example), but the foreign data (attacker.example) is shrouded by legitimate content.

Specially crafted links can be sent to a user via e-mail, instant messages, left on bulletin board postings, or forced upon users by a Cross-site Scripting attack. If an attacker gets a user to visit a web page designated by their malicious URL, the user will believe he is viewing authentic content from one location when he is not. Users will implicitly trust the spoofed content since the browser location bar displays http://foo.example, when in fact the underlying HTML frame is referencing http://attacker.example.

This attack exploits the trust relationship established between the user and the web site. The technique has been used to create fake web pages including login forms, defacements, false press releases, etc.
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Content-Spoofing</reference>
	<reference>TBA</reference>
</vuln_item_wasc_12>

<vuln_items>wasc_13</vuln_items>
<vuln_item_wasc_13>
	<alert>Information Leakage</alert>
	<desc>Information Leakage is an application weakness where an application reveals sensitive data, such as technical details of the web application, environment, or user-specific data. Sensitive data may be used by an attacker to exploit the target web application, its hosting network, or its users. Therefore, leakage of sensitive data should be limited or prevented whenever possible. Information Leakage, in its most common form, is the result of one or more of the following conditions: A failure to scrub out HTML/Script comments containing sensitive information, improper application or server configurations, or differences in page responses for valid versus invalid data.

Failure to scrub HTML/Script comments prior to a push to the production environment can result in the leak of sensitive, contextual, information such as server directory structure, SQL query structure, and internal network information. Often a developer will leave comments within the HTML and/or script code to help facilitate the debugging or integration process during the pre-production phase. Although there is no harm in allowing developers to include inline comments within the content they develop, these comments should all be removed prior to the content's public release.

Software version numbers and verbose error messages (such as ASP.NET version numbers) are examples of improper server configurations. This information is useful to an attacker by providing detailed insight as to the framework, languages, or pre-built functions being utilized by a web application. Most default server configurations provide software version numbers and verbose error messages for debugging and troubleshooting purposes. Configuration changes can be made to disable these features, preventing the display of this information.

Pages that provide different responses based on the validity of the data can also lead to Information Leakage; specifically when data deemed confidential is being revealed as a result of the web application's design. Examples of sensitive data includes (but is not limited to): account numbers, user identifiers (Drivers license number, Passport number, Social Security Numbers, etc.) and user-specific information (passwords, sessions, addresses). Information Leakage in this context deals with exposure of key user data deemed confidential, or secret, that should not be exposed in plain view, even to the user. Credit card numbers and other heavily regulated information are prime examples of user data that needs to be further protected from exposure or leakage even with proper encryption and access controls already in place.</desc>
	<solution>Compartmentalize your system to have "safe" areas where trust boundaries can be unambiguously drawn. Не дозволяйте конфіденційним даним виходити за межі довіри та завжди будьте обережні під час взаємодії з простором за межами безпечної зони.</solution>
	<reference>http://projects.webappsec.org/Information-Leakage</reference>
	<reference>http://cwe.mitre.org/data/definitions/200.html</reference>
</vuln_item_wasc_13>

<vuln_items>wasc_14</vuln_items>
<vuln_item_wasc_14>
	<alert>Server Misconfiguration</alert>
	<desc>Server Misconfiguration attacks exploit configuration weaknesses found in web servers and application servers. Many servers come with unnecessary default and sample files, including applications, configuration files, scripts, and web pages. They may also have unnecessary services enabled, such as content management and remote administration functionality. Debugging functions may be enabled or administrative functions may be accessible to anonymous users. These features may provide a means for a hacker to bypass authentication methods and gain access to sensitive information, perhaps with elevated privileges.

Servers may include well-known default accounts and passwords. Failure to fully lock down or harden the server may leave improperly set file and directory permissions. Misconfigured SSL certificates and encryption settings, the use of default certificates, and improper authentication implementation with external systems may compromise the confidentiality of information.

Verbose and informative error messages may result in data leakage, and the information revealed could be used to formulate the next level of attack. Incorrect configurations in the server software may permit directory indexing and path traversal attacks.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Server-Misconfiguration</reference>
	<reference/>
</vuln_item_wasc_14>

<vuln_items>wasc_15</vuln_items>
<vuln_item_wasc_15>
	<alert>Application Misconfiguration</alert>
	<desc>Application Misconfiguration attacks exploit configuration weaknesses found in web applications. Many applications come with unnecessary and unsafe features, such as debug and QA features, enabled by default. These features may provide a means for a hacker to bypass authentication methods and gain access to sensitive information, perhaps with elevated privileges.

Likewise, default installations may include well-known usernames and passwords, hard-coded backdoor accounts, special access mechanisms, and incorrect permissions set for files accessible through web servers. Default samples may be accessible in production environments. Application-based configuration files that are not properly locked down may reveal clear text connection strings to the database, and default settings in configuration files may not have been set with security in mind. All of these misconfigurations may lead to unauthorized access to sensitive information.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Application-Misconfiguration</reference>
	<reference/>
</vuln_item_wasc_15>

<vuln_items>wasc_16</vuln_items>
<vuln_item_wasc_16>
	<alert>Directory Indexing</alert>
	<desc>Automatic directory listing/indexing is a web server function that lists all of the files within a requested directory if the normal base file (index.html/home.html/default.htm/default.asp/default.aspx/index.php) is not present. When a user requests the main page of a web site, they normally type in a URL such as: http://www.example.com/directory1/ - using the domain name and excluding a specific file. The web server processes this request and searches the document root directory for the default file name and sends this page to the client. If this page is not present, the web server will dynamically issue a directory listing and send the output to the client. Essentially, this is equivalent to issuing an "ls" (Unix) or "dir" (Windows) command within this directory and showing the results in HTML form. From an attack and countermeasure perspective, it is important to realize that unintended directory listings may be possible due to software vulnerabilities (discussed in the example section below) combined with a specific web request.</desc>
	<solution>Recommendations include restricting access to important directories or files by adopting a need to know requirement for both the document and server root, and turning off features such as Automatic Directory Listings that could expose private files and provide information that could be utilized by an attacker when formulating or conducting an attack.</solution>
	<reference>http://projects.webappsec.org/Directory-Indexing</reference>
	<reference>http://cwe.mitre.org/data/definitions/548.html</reference>
</vuln_item_wasc_16>

<vuln_items>wasc_17</vuln_items>
<vuln_item_wasc_17>
	<alert>Improper Filesystem Permissions</alert>
	<desc>Improper filesystem permissions are a threat to the confidentiality, integrity and availability of a web application. The problem arises when incorrect filesystem permissions are set on files, folders, and symbolic links. When improper permissions are set, an attacker may be able to access restricted files or directories and modify or delete their contents. For example, if an anonymous user account has write permission to a file, then an attacker may be able to modify the contents of the file influencing the web application in undesirable ways. An attacker may also exploit improper symlinks to escalate their privileges and/or access unauthorized files; for example, a symlink that points to a directory outside of the web root.</desc>
	<solution>Very carefully manage the setting, management and handling of permissions. Явно керуйте зонами довіри в програмному забезпеченні.</solution>
	<reference>http://projects.webappsec.org/Improper-Filesystem-Permissions</reference>
	<reference>http://cwe.mitre.org/data/definitions/280.html</reference>
</vuln_item_wasc_17>

<vuln_items>wasc_18</vuln_items>
<vuln_item_wasc_18>
	<alert>Credential and Session Prediction</alert>
	<desc>Credential/Session Prediction is a method of hijacking or impersonating a web site user. Deducing or guessing the unique value that identifies a particular session or user accomplishes the attack. Also known as Session Hijacking, the consequences could allow attackers the ability to issue web site requests with the compromised user's privileges.

Many web sites are designed to authenticate and track a user when communication is first established. To do this, users must prove their identity to the web site, typically by supplying a username/password (credentials) combination. Rather than passing these confidential credentials back and forth with each transaction, web sites will generate a unique "session ID" to identify the user session as authenticated. Subsequent communication between the user and the web site is tagged with the session ID as "proof" of the authenticated session. If an attacker is able predict or guess the session ID of another user, fraudulent activity is possible.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Credential-and-Session-Prediction</reference>
	<reference/>
</vuln_item_wasc_18>

<vuln_items>wasc_19</vuln_items>
<vuln_item_wasc_19>
	<alert>SQL впровадження</alert>
	<desc>SQL Injection is an attack technique used to exploit applications that construct SQL statements from user-supplied input. When successful, the attacker is able to change the logic of SQL statements executed against the database.

Structured Query Language (SQL) is a specialized programming language for sending queries to databases. The SQL programming language is both an ANSI and an ISO standard, though many database products supporting SQL do so with proprietary extensions to the standard language. Applications often use user-supplied data to create SQL statements. If an application fails to properly construct SQL statements it is possible for an attacker to alter the statement structure and execute unplanned and potentially hostile commands. When such commands are executed, they do so under the context of the user specified by the application executing the statement. This capability allows attackers to gain control of all database resources accessible by that user, up to and including the ability to execute commands on the hosting system.</desc>
	<solution>Фаза: Архітектура і Дизайн
Використовуйте перевірену бібліотеку чи структуру, які запобігають виникненню цієї слабкості або надають конструкції, які полегшують уникнення цієї слабкості.
For example, consider using persistence layers such as Hibernate or Enterprise Java Beans, which can provide significant protection against SQL injection if used properly.

If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated.

Process SQL queries using prepared statements, parameterized queries, or stored procedures. These features should accept parameters or variables and support strong typing. Do not dynamically construct and execute query strings within these features using "exec" or similar functionality, since you may re-introduce the possibility of SQL injection.

Run your code using the lowest privileges that are required to accomplish the necessary tasks. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.

Specifically, follow the principle of least privilege when creating user accounts to a SQL database. The database users should only have the minimum privileges necessary to use their account. If the requirements of the system indicate that a user can read and modify their own data, then limit their privileges so they cannot read/write others' data. Use the strictest permissions possible on all database objects, such as execute-only for stored procedures.

Phase: Implementation
If you need to use dynamically-generated query strings or commands in spite of the risk, properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict allow list (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE-88).

Instead of building your own implementation, such features may be available in the database or programming language. For example, the Oracle DBMS ASSERT package can check or enforce that parameters have certain properties that make them less vulnerable to SQL injection. For MySQL, the mysql real escape string() API function is available in both C and PHP.

Assume all input is malicious. Використовуйте стратегію перевірки вхідних даних «прийняти наперед хороші», тобто використовуйте дозволений список прийнятних вхідних даних, які чітко відповідають специфікаціям. Відхиліть будь-які вхідні дані, які не повністю відповідають специфікаціям, або перетворіть їх на щось, що відповідає. Не покладайтеся виключно на пошук зловмисних або некоректних даних (тобто не покладайтеся на список заборонених). Однак списки заборони можуть бути корисними для виявлення потенційних атак або визначення того, які вхідні дані є настільки неправильними, що їх слід відхилити.

Виконуючи перевірку вхідних даних, враховуйте всі потенційно важливі властивості, включаючи довжину, тип вхідних даних, повний діапазон прийнятних значень, відсутні або додаткові вхідні дані, синтаксис, узгодженість пов’язаних полів і відповідність бізнес-правилам. Як приклад логіки бізнес-правил, «човен» може бути синтаксично допустимим, оскільки містить лише буквено-цифрові символи, але він недійсний, якщо ви очікуєте такі кольори, як «червоний» або «синій».

When constructing SQL query strings, use stringent allow lists that limit the character set based on the expected value of the parameter in the request. This will indirectly limit the scope of an attack, but this technique is less important than proper output encoding and escaping.

Note that proper output encoding, escaping, and quoting is the most effective solution for preventing SQL injection, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent SQL injection, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, the name "O'Reilly" would likely pass the validation step, since it is a common last name in the English language. However, it cannot be directly inserted into the database because it contains the "'" apostrophe character, which would need to be escaped or otherwise handled. In this case, stripping the apostrophe might reduce the risk of SQL injection, but it would produce incorrect behavior because the wrong name would be recorded.

When feasible, it may be safest to disallow meta-characters entirely, instead of escaping them. This will provide some defense in depth. After the data is entered into the database, later processes may neglect to escape meta-characters before use, and you may not have control over those processes.</solution>
	<reference>http://projects.webappsec.org/SQL-Injection</reference>
	<reference/>
</vuln_item_wasc_19>

<vuln_items>wasc_20</vuln_items>
<vuln_item_wasc_20>
	<alert>Improper Input Handling</alert>
	<desc>Improper input handling is one of the most common weaknesses identified across applications today. Poorly handled input is a leading cause behind critical vulnerabilities that exist in systems and applications.
	
Generally, the term input handing is used to describe functions like validation, sanitization, filtering, encoding and/or decoding of input data. Applications receive input from various sources including human users, software agents (browsers), and network/peripheral devices to name a few. In the case of web applications, input can be transferred in various formats (name value pairs, JSON, SOAP, etc...) and obtained via URL query strings, POST data, HTTP headers, Cookies, etc... Non-web application input can be obtained via application variables, environment variables, the registry, configuration files, etc... Regardless of the data format or source/location of the input, all input should be considered untrusted and potentially malicious. Applications which process untrusted input may become vulnerable to attacks such as Buffer Overflows, SQL Injection, OS Commanding, Denial of Service just to name a few.

One of the key aspects of input handling is validating that the input satisfies a certain criteria. For proper validation, it is important to identify the form and type of data that is acceptable and expected by the application. Defining an expected format and usage of each instance of untrusted input is required to accurately define restrictions. 

Validation can include checks for type safety and correct syntax. String input can be checked for length (min and max number of characters) and character set validation while numeric input types like integers and decimals can be validated against acceptable upper and lower bound of values. When combining input from multiple sources, validation should be performed during concatenation and not just against the individual data elements. This practice helps avoid situations where input validation may succeed when performed on individual data items but fails when done on a combined set from all the sources.</desc>
	<solution>Phase: Architecture and Design

Use an input validation framework such as Struts or the OWASP ESAPI Validation API.

Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, databases, and any external systems that provide data to the application. Пам’ятайте, що такі вхідні дані можна отримати опосередковано через виклики API.

For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.

Even though client-side checks provide minimal benefits with respect to server-side security, they are still useful. First, they can support intrusion detection. If the server receives input that should have been rejected by the client, then it may be an indication of an attack. Second, client-side error-checking can provide helpful feedback to the user about the expectations for valid input. Third, there may be a reduction in server-side processing time for accidental input errors, although this is typically a small savings.

Do not rely exclusively on deny list validation to detect malicious input or to encode output. There are too many ways to encode the same character, so you're likely to miss some variants.

When your application combines data from multiple sources, perform the validation after the sources have been combined. The individual data elements may pass the validation step but violate the intended restrictions after they have been combined.

Assume all input is malicious. Використовуйте стратегію перевірки вхідних даних «прийняти наперед хороші», тобто використовуйте дозволений список прийнятних вхідних даних, які чітко відповідають специфікаціям. Відхиліть будь-які вхідні дані, які не повністю відповідають специфікаціям, або перетворіть їх на щось, що відповідає. Не покладайтеся виключно на пошук зловмисних або некоректних даних (тобто не покладайтеся на список заборонених). Однак списки заборони можуть бути корисними для виявлення потенційних атак або визначення того, які вхідні дані є настільки неправильними, що їх слід відхилити.

Виконуючи перевірку вхідних даних, враховуйте всі потенційно важливі властивості, включаючи довжину, тип вхідних даних, повний діапазон прийнятних значень, відсутні або додаткові вхідні дані, синтаксис, узгодженість пов’язаних полів і відповідність бізнес-правилам. Як приклад логіки бізнес-правил, «човен» може бути синтаксично допустимим, оскільки містить лише буквено-цифрові символи, але він недійсний, якщо ви очікуєте такі кольори, як «червоний» або «синій».

Phase: Implementation

Be especially careful to validate your input when you invoke code that crosses language boundaries, such as from an interpreted language to native code. This could create an unexpected interaction between the language boundaries. Ensure that you are not violating any of the expectations of the language with which you are interfacing. For example, even though Java may not be susceptible to buffer overflows, providing a large argument in a call to native code might trigger an overflow.

Directly convert your input type into the expected data type, such as using a conversion function that translates a string into a number. After converting to the expected data type, ensure that the input's values fall within the expected range of allowable values and that multi-field consistencies are maintained.

Inputs should be decoded and canonicalized to the application's current internal representation before being validated. Make sure that your application does not inadvertently decode the same input twice. Such errors could be used to bypass allow list schemes by introducing dangerous inputs after they have been checked. Use libraries such as the OWASP ESAPI Canonicalization control.

Consider performing repeated canonicalization until your input does not change any more. This will avoid double-decoding and similar scenarios, but it might inadvertently modify inputs that are allowed to contain properly-encoded dangerous content.

When exchanging data between components, ensure that both components are using the same character encoding. Ensure that the proper encoding is applied at each interface. Explicitly set the encoding you are using whenever the protocol allows you to do so.</solution>
	<reference>http://projects.webappsec.org/Improper-Input-Handling</reference>
	<reference>http://cwe.mitre.org/data/definitions/89.html</reference>
</vuln_item_wasc_20>

<vuln_items>wasc_21</vuln_items>
<vuln_item_wasc_21>
	<alert>Insufficient Anti automation</alert>
	<desc>Insufficient Anti-automation occurs when a web application permits an attacker to automate a process that was originally designed to be performed only in a manual fashion, i.e. by a human web user.

Функціональність веб-додатку, яка часто стає ціллю для автоматизованих атак, може включати в себе:
    * Форми входу в додаток - зловмисники можуть автоматизувати запити на вхід в систему методом грубої сили, намагаючись вгадати облікові дані користувача
    * Форми реєстрації сервісів - зловмисники можуть автоматично створювати тисячі нових облікових записів
    * Форми електронної пошти - зловмисники можуть використовувати форми електронної пошти як ретранслятори спаму або для переповнення поштової скриньки певного користувача
    * Обслуговування акаунтів - зловмисники можуть виконувати масові DoS-атаки на додаток, засипаючи його численними запитами на відключення або видалення облікових записів користувачів
    * Форми відомостей про обліковий запис - зловмисники можуть виконувати масові спроби збору персональної інформації користувачів з веб-додатку
    * Форми коментування / форми відправки вмісту - можуть бути використані для спаму блогів, веб-форумів та дошок оголошень шляхом автоматичної відправки вмісту, наприклад, спаму або навіть веб-шкідливого програмного забезпечення.
    * Форми, прив'язані до запитів до бази даних SQL - вони можуть бути використані для проведення атаки на відмову в обслуговуванні програми. Атака виконується шляхом надсилання численних інтенсивних SQL-запитів за короткий проміжок часу, таким чином відмовляючи реальним користувачам в обслуговуванні.
    * eShopping / eCommerce - eShopping and eCommerce applications that do not enforce human-only buyers, can be exploited in order to buy preferred items in large amounts, such as sporting events tickets. These are later sold by scalpers for higher prices.
    * Онлайн-опитування - опитування та інші види систем онлайн-голосування можуть бути автоматично підтасовані на користь певного вибору.
    * Розсилка SMS-повідомлень через Інтернет - зловмисники можуть використовувати системи розсилки SMS-повідомлень для розсилання спаму користувачам мобільних телефонів
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Insufficient+Anti-automation</reference>
	<reference>http://cwe.mitre.org/data/definitions/116.html</reference>
</vuln_item_wasc_21>

<vuln_items>wasc_22</vuln_items>
<vuln_item_wasc_22>
	<alert>Improper Output Handling</alert>
	<desc>Обробка виводу - це те, як додаток генерує вихідні дані.  Якщо додаток має неправильну обробку виводу, вихідні дані можуть бути використані, що призведе до вразливих місць і дій, які не були заплановані розробником додатку.  У багатьох випадках така ненавмисна інтерпретація класифікується як одна або декілька форм вразливих місць критичних додатків.

Будь-яке розташування, де дані залишають межі додатку, може бути наслідком неправильної обробки вихідних даних.  Межі додатку існують там, де дані залишають один контекст і потрапляють в інший.  Сюди входять додатки, що передають дані іншим програмам через веб-сервіси, сокети, командний рядок, змінні середовища тощо...  Сюди також входить передача даних між рівнями в архітектурі додатку, такими як база даних, сервер каталогів, HTML/JavaScript інтерпретатор (браузер) або операційна система.  Більш детально про те, де може виникати неправильна обробка виводу, можна дізнатися в розділі нижче під назвою "Загальні місця виводу даних".

Неправильна обробка виводу може набувати різних форм у додатку.  Ці форми можна класифікувати на: помилки протоколу, помилки додатку та помилки, пов'язані зі споживачем даних.  Помилки протоколу включають відсутність або неправильне кодування вихідних даних, екранування та виведення недійсних даних.  Помилки додатку включають логічні помилки, такі як виведення неправильних даних або передача шкідливого вмісту без фільтрації.  Якщо додаток не відрізняє належним чином легітимний вміст від нелегітимного або не обходить відомі вразливі місця споживача даних, це може призвести до зловживань з боку споживача даних, спричинених неправильною обробкою вихідних даних.

Додаток, який не надає дані в правильному контексті, може дозволити зловмиснику зловживати споживачем даних.  Це може призвести до певних загроз, зазначених у Класифікації загроз WASC, зокрема підміни вмісту, міжсайтового скриптингу, розділення HTTP-відповідей, контрабанди HTTP-відповідей, LDAP введення, керування ОС, обхід маршрутизації, зловживання масивами SOAP, перенаправлення URL-адреси, XML введення, XQuery введення, XPath введення, впровадження поштових команд, нульового введення та SQL-введення.

Належна обробка вихідних даних запобігає неочікуваній або ненавмисній інтерпретації даних споживачем.  Щоб досягти цієї мети, розробники повинні розуміти модель даних додатку, як дані будуть використовуватися іншими частинами додатку і як вони будуть запропоновані користувачеві.  Методи забезпечення належної обробки вихідних даних включають, але не обмежуються фільтрацією та санітарною обробкою даних (більш детально про санітарну обробку та фільтрацію вихідних даних можна знайти у відповідних розділах нижче).  Однак непослідовне використання обраних методів обробки вихідних даних може фактично збільшити ризик неправильної обробки вихідних даних, якщо вихідні дані будуть проігноровані або залишені без обробки.  Для забезпечення "глибокого захисту" розробники повинні припускати, що всі дані в додатку є ненадійними, при виборі відповідних стратегій обробки виводу.

Хоча належна обробка вихідних даних може приймати різні форми, додаток не може бути безпечним, якщо він не захищає від ненавмисних інтерпретацій з боку споживача даних. Ця основна вимога необхідна для того, щоб додаток міг безпечно обробляти операції виводу.</desc>
	<solution>Використовуйте перевірені бібліотеки або фреймворки, які не допускають виникнення цієї вразливості або надають конструкції, які полегшують уникнення цієї вразливості.

For example, consider using the ESAPI Encoding control or a similar tool, library, or framework. Вони допоможуть програмісту кодувати виходи у спосіб, менш схильний до помилок.

Alternately, use built-in functions, but consider using wrappers in case those functions are discovered to have a vulnerability.

Якщо це можливо, використовуйте структуровані механізми, які автоматично забезпечують розділення даних і коду. Ці механізми можуть забезпечити відповідне цитування, кодування та перевірку автоматично, замість того, щоб покладатися на розробника, який має забезпечувати цю можливість у кожній точці, де генерується результат.

Наприклад, збережені процедури можуть забезпечити дотримання структури запитів до бази даних і зменшити ймовірність SQL-введення.

Зрозумійте, в якому контексті будуть використовуватися ваші дані і яке кодування очікується. Це особливо важливо при передачі даних між різними компонентами або при створенні вихідних даних, які можуть містити кілька кодувань одночасно, наприклад, веб-сторінки або поштові повідомлення, що складаються з кількох частин. Вивчіть всі очікувані протоколи зв'язку та представлення даних, щоб визначити необхідні стратегії кодування.

У деяких випадках перевірка вхідних даних може бути важливою стратегією, коли вихідне кодування не є повним рішенням. Наприклад, ви можете надавати один і той самий вихідний файл, який буде оброблятися кількома споживачами, що використовують різні кодування або представлення. В інших випадках вам може знадобитися дозволити користувацькому введенні містити контрольну інформацію, наприклад, обмежені HTML-теги, які підтримують форматування у Вікі або дошці оголошень. Коли потрібно виконати цей тип вимог, використовуйте дуже суворий список дозволів, щоб обмежити, які контрольні послідовності можна використовувати. Перевірте, чи отримана синтаксична структура відповідає вашим очікуванням. Для решти даних використовуйте ваші звичайні методи кодування.

Використовуйте перевірку вхідних даних як глибинну міру захисту, щоб зменшити ймовірність помилок вихідного кодування (див. CWE-20).

Під час обміну даними між компонентами переконайтеся, що обидва компоненти використовують однакове кодування символів. Переконайтеся, що на кожному інтерфейсі застосовується правильне кодування. Явно встановлюйте кодування, яке ви використовуєте, якщо це дозволяє протокол.</solution>
	<reference>http://projects.webappsec.org/Improper-Output-Handling</reference>
	<reference/>
</vuln_item_wasc_22>

<vuln_items>wasc_23</vuln_items>
<vuln_item_wasc_23>
	<alert>XML введення</alert>
	<desc>XML-введення - це метод атаки, який використовується для керування або компрометації логіки XML-додатку або сервісу. Введення в XML-повідомлення ненавмисного вмісту та/або структур може змінити логіку роботи додатку. Крім того, XML-введення може призвести до вставки шкідливого вмісту в отримане повідомлення/документ.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/XML-Injection</reference>
	<reference/>
</vuln_item_wasc_23>

<vuln_items>wasc_24</vuln_items>
<vuln_item_wasc_24>
	<alert>Поділ HTTP-запитів</alert>
	<desc>Поділ HTTP запитів - це атака, яка дозволяє змусити браузер надсилати довільні HTTP-запити, що призводить до XSS-атак та отруєння кешу браузера. Суть атаки полягає в здатності зловмисника, після того, як жертва (браузер) змушена завантажити шкідливу HTML-сторінку зловмисника, керувати однією з функцій браузера, щоб замість одного HTTP-запиту відправити 2 HTTP-запити. Використовуються два таких механізми: об'єкт XmlHttpRequest (скорочено XHR) і механізм автентифікації HTTP-дайджесту. Щоб ця атака спрацювала, браузер повинен використовувати прямий проксі HTTP (не всі вони "підтримують" цю атаку), або атака повинна бути проведена проти хоста, розташованого на одній IP-адресі (з точки зору браузера) з машиною зловмисника.</desc>
	<solution>Не використовуйте CRLF як спеціальну послідовність.

Належним чином фільтрувати або цитувати CRLF-послідовності у вхідних даних, контрольованих користувачем.</solution>
	<reference>http://projects.webappsec.org/HTTP-Request-Splitting</reference>
	<reference>http://cwe.mitre.org/data/definitions/93.html</reference>
</vuln_item_wasc_24>

<vuln_items>wasc_25</vuln_items>
<vuln_item_wasc_25>
	<alert>Поділ HTTP-запитів</alert>
	<desc>В атаці поділу HTTP-відповіді завжди беруть участь 3 сторони (як мінімум):
    * Веб-сервер, який має дірку в безпеці, що дозволяє поділ HTTP-відповіді
    * Ціль - об'єкт, який взаємодіє з веб-сервером, можливо, від імені зловмисника. Зазвичай це кеш-сервер (прямий/зворотний проксі) або браузер (можливо, з кешем браузера).
    * Зловмисник - ініціює атаку

Суть поділу HTTP-відповіді полягає в тому, що зловмисник може надіслати один HTTP-запит, який змушує веб-сервер сформувати вихідний потік, який потім інтерпретується ціллю як дві HTTP-відповіді замість однієї відповіді, як у звичайному випадку. Перша реакція може частково контролюватися зловмисником, але це не так важливо. Важливо те, що зловмисник повністю контролює форму другої відповіді від рядка стану HTTP до останнього байта тіла HTTP-відповіді. Як тільки це стає можливим, зловмисник реалізує атаку, надсилаючи два запити через ціль. Перший викликає дві відповіді від веб-сервера, а другий запит, як правило, надсилається до якогось "невинного" ресурсу на веб-сервері. Однак, на другий запит зловмисник отримає другу HTTP-відповідь, яка повністю контролюється зловмисником. Таким чином, зловмисник обманом змушує ціль повірити, що певний ресурс на веб-сервері (позначений другим запитом) є HTTP-відповіддю сервера (вміст сервера), тоді як насправді це певні дані, які зловмисник підробляє через веб-сервер - це і є друга відповідь.

Атаки поділу HTTP-відповіді  відбуваються, коли серверний скрипт вбудовує дані користувача в заголовки HTTP-відповідей. Зазвичай це відбувається, коли скрипт вбудовує дані користувача в URL-адресу відповіді перенаправлення (код стану HTTP 3xx) або коли скрипт вбудовує дані користувача в значення або ім'я файлу cookie, коли відповідь встановлює файл cookie.</desc>
	<solution>Конструюйте HTTP-заголовки дуже уважно, уникаючи використання неперевірених вхідних даних.</solution>
	<reference>http://projects.webappsec.org/HTTP-Response-Splitting</reference>
	<reference>http://cwe.mitre.org/data/definitions/113.html</reference>
</vuln_item_wasc_25>

<vuln_items>wasc_26</vuln_items>
<vuln_item_wasc_26>
	<alert>Контрабанда HTTP-запиту</alert>
	<desc>Контрабанда HTTP-запиту - це метод атаки, яка використовує розбіжності в розборі невідповідних RFC HTTP-запитів між двома HTTP-пристроями (як правило, зовнішнім проксі-сервером або брандмауером з підтримкою HTTP і внутрішнім веб-сервером), щоб передати запит на другий пристрій "через" перший пристрій. Ця техніка дозволяє зловмиснику надсилати один набір запитів на другий пристрій, в той час як перший пристрій бачить інший набір запитів. У свою чергу, це полегшує кілька можливих експлойтів, таких як часткове отруєння кешу, обхід захисту брандмауера та XSS.</desc>
	<solution>Використовуйте веб-сервер, який використовує сувору процедуру синтаксичного аналізу HTTP, наприклад, Apache (див. статтю у посиланні).

Використовуйте тільки SSL-зв'язок.

Завершуйте сеанс клієнта після кожного запиту.

Вимкніть кешування всіх сторінок.</solution>
	<reference>http://projects.webappsec.org/HTTP-Request-Smuggling</reference>
	<reference>http://cwe.mitre.org/data/definitions/444.html</reference>
</vuln_item_wasc_26>

<vuln_items>wasc_27</vuln_items>
<vuln_item_wasc_27>
	<alert>Контрабанда HTTP-відповіді</alert>
	<desc>Контрабанда HTTP-відповіді - це метод "контрабанди" 2 HTTP-відповідей від сервера до клієнта через проміжний HTTP-пристрій, який очікує (або дозволяє) одну відповідь від сервера.

Одне з застосувань цього методу - покращити базову техніку поділу HTTP-відповідей, щоб обійти заходи проти поділу HTTP-відповідей. У цьому випадку посередником є механізм розділення відповідей анти-HTTP між веб-сервером і проксі-сервером (або веб-браузером). Інший варіант використання - підробка відповідей, отриманих браузером. У цьому випадку шкідливий веб-сайт подає браузеру сторінку, яку браузер інтерпретує як таку, що походить з іншого (цільового) домену. Для цього можна використовувати контрабанду HTTP-відповіді, коли браузер використовує проксі-сервер для доступу до обох сайтів.

Контрабанда HTTP-відповіді використовує методи, подібні до контрабанди HTTP-запиту, щоб використовувати розбіжності між тим, що механізм поділу HTTP-відповіді (або проксі-сервер) вважає потоком HTTP-відповіді, і потоком відповіді, який розбирається проксі-сервером (або браузером). Отже, хоча механізм поділу HTTP-відповіді може вважати певний потік відповідей нешкідливим (одна HTTP-відповідь), проксі/браузер все одно може розпізнати його як дві HTTP-відповіді, а отже, бути вразливим до всіх наслідків вихідної техніки поділу HTTP-відповіді (у першому випадку) або бути вразливим до підміни сторінок (у другому випадку). Наприклад, деякі механізми захисту від поділу HTTP-відповіді, що використовуються деякими прикладними механізмами, забороняють додатку вставляти у відповідь заголовок, що містить CR+LF. Проте зловмисник може змусити додаток вставити заголовок, що містить CR, тим самим обійшовши захисний механізм. Деякі проксі-сервери все ще можуть розглядати CR (тільки) як роздільник заголовка (і відповіді), і тому комбінація веб-сервера і проксі-сервера все ще буде вразливою до атаки, яка може отруїти кеш проксі-сервера.
	</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/HTTP-Response-Smuggling</reference>
	<reference/>
</vuln_item_wasc_27>

<vuln_items>wasc_28</vuln_items>
<vuln_item_wasc_28>
	<alert>Null Byte Injection</alert>
	<desc>Null Byte Injection is an active exploitation technique used to bypass sanity checking filters in web infrastructure by adding URL-encoded null byte characters (i.e. %00, or 0x00 in hex) to the user-supplied data. Процес введення може змінити заплановану логіку роботи додатку та дозволити зловмиснику отримати несанкціонований доступ до системних файлів.

Більшість веб-додатків сьогодні розробляються з використанням мов вищого рівня, таких як PHP, ASP, Perl та Java. Однак ці веб-додатки в певний момент вимагають обробки високорівневого коду на системному рівні, і цей процес зазвичай досягається за допомогою функцій C/C++. The diverse nature of these dependent technologies has resulted in an attack class called ‘Null Byte Injection’ or ‘Null Byte Poisoning’ attack. У C/C++ нульовий байт є точкою завершення рядка або символом-роздільником, що означає негайне припинення обробки рядка. Байти після роздільника будуть проігноровані. Якщо рядок втрачає нульовий символ, довжина рядка стає невідомою, поки вказівник пам'яті не зустріне наступний нульовий байт. Це ненавмисне розгалуження може спричинити незвичну поведінку та призвести до появи вразливих місць у системі або застосунку. Аналогічно, деякі мови вищого рівня розглядають "нульовий байт" як заповнювач довжини рядка, оскільки він не має особливого значення в їхньому контексті. Через цю відмінність в інтерпретації можна легко ввести нульові байти, щоб керувати поведінкою додатку.

URL-адреси обмежені набором символів US-ASCII в діапазоні від 0x20 до 0x7E (шістнадцяткові) або від 32 до 126 (десяткові). Однак у вищезгаданому діапазоні використовується кілька символів, які не дозволені, оскільки вони мають особливе значення в контексті протоколу HTTP. З цієї причини було запроваджено схему кодування URL-адрес для включення спеціальних символів у URL-адреси з використанням розширеного представлення символів ASCII. З точки зору "нульового байта", це представлено у вигляді %00 у шістнадцятковій системі числення. Область видимості атаки нульовим байтом починається там, де веб-додатки взаємодіють з активними підпрограмами на мові C та зовнішніми API з базової операційної системи. Таким чином, дозволяючи зловмиснику керувати веб-ресурсами, читаючи або записуючи файли на основі привілеїв користувача додатку.</desc>
	<solution>Розробники повинні передбачити, що нульові символи або нульові байти будуть введеними/видаленими/керованими у вхідних векторах їхньої програмної системи. Використовуйте відповідну комбінацію чорних і білих списків, щоб гарантувати, що система обробляє лише достовірну, очікувану та відповідну інформацію.

Припустимо, що всі вхідні дані зловмисні. Використовуйте стандартний механізм перевірки вхідних даних для перевірки довжини, типу, синтаксису та бізнес-правил перед тим, як приймати дані для відображення або зберігання. Використовуйте стратегію перевірки за принципом "приймати добре відомі".

Використовуйте та вказуйте надійне вихідне кодування (наприклад, ISO 8859-1 або UTF 8).

Не покладайтеся виключно на перевірку списків заборон для виявлення зловмисного вводу або кодування виводу. Існує занадто багато варіантів для кодування символів; ви, швидше за все, пропустите деякі варіанти.

Вхідні дані повинні бути розшифровані та канонізовані відповідно до поточного внутрішнього представлення додатку перед перевіркою. Переконайтеся, що ваша програма не декодує один і той самий ввід двічі. Такі помилки можуть бути використані для обходу схем дозволених списків шляхом введення небезпечних вхідних даних після їх перевірки.</solution>
	<reference>http://projects.webappsec.org/Null-Byte-Injection</reference>
	<reference>http://cwe.mitre.org/data/definitions/158.html</reference>
</vuln_item_wasc_28>

<vuln_items>wasc_29</vuln_items>
<vuln_item_wasc_29>
	<alert>Впровадження LDAP </alert>
	<desc>Впровадження LDAP - це метод атаки, який використовується для експлуатації веб-сайтів, що створюють LDAP-запити на основі вхідних даних, наданих користувачем.

Lightweight Directory Access Protocol (LDAP) is an open-standard protocol for both querying and manipulating X.500 directory services. Протокол LDAP працює поверх транспортних протоколів Інтернету, таких як TCP. Веб-додатки можуть використовувати введені користувачем дані для створення власних операторів LDAP для динамічних запитів до веб-сторінок.

Якщо веб-додаток не може належним чином очистити введені користувачем дані, зловмисник може змінити конструкцію LDAP-запиту. Якщо зловмисник змінить оператор LDAP, процес буде запущено з тими ж правами, що й компонент, який виконав команду. (наприклад, сервер бази даних, сервер веб-додатків, веб-сервер тощо). Це може спричинити серйозні проблеми з безпекою, якщо дозволи надають право запитувати, змінювати або видаляти будь-що всередині дерева LDAP. Ті ж самі просунуті методи експлуатації, доступні в SQL-введенні, також можуть бути застосовані в LDAP-введенні.</desc>
	<solution>Припустимо, що всі вхідні дані зловмисні. Використовуйте відповідну комбінацію чорних і білих списків, щоб нейтралізувати синтаксис LDAP від контрольованого користувачем введення.</solution>
	<reference>http://projects.webappsec.org/LDAP-Injection</reference>
	<reference>http://cwe.mitre.org/data/definitions/90.html</reference>
</vuln_item_wasc_29>

<vuln_items>wasc_30</vuln_items>
<vuln_item_wasc_30>
	<alert>Впровадження поштових команд</alert>
	<desc>Впровадження поштових команд - це метод атаки, який використовується для експлуатації поштових серверів і веб-додатків, що створюють IMAP/SMTP-запити на основі введених користувачем даних, які не пройшли належну санітарну обробку. Залежно від типу твердження, яким користується зловмисник, ми зустрічаємося з двома типами впровадження: IMAP та SMTP впровадження. An IMAP/SMTP Injection may make it possible to access a mail server which you previously had no access to before-hand. In some cases, these internal systems do not have the same level of infrastructure security hardening applied to them as most front-end web servers. Hence, attackers may find that the mail server yields better results in terms of exploitation. On the other hand, this technique allows to evade possible restrictions that could exist at application level (CAPTCHA, maximum number of requests, etc.).</desc>
	<solution>Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, request headers as well as content, URL components, e-mail, files, databases, and any external systems that provide data to the application. Perform input validation at well-defined interfaces.

Assume all input is malicious. Use an "accept known good" input validation strategy (i.e., use an allow list). Відхиліть будь-які вхідні дані, які не повністю відповідають специфікаціям, або перетворіть їх на щось, що відповідає. Use a deny list to reject any unexpected inputs and detect potential attacks.

Do not rely exclusively on deny list validation to detect malicious input or to encode output. There are too many ways to encode the same character, so you're likely to miss some variants.

Directly convert your input type into the expected data type, such as using a conversion function that translates a string into a number. After converting to the expected data type, ensure that the input's values fall within the expected range of allowable values and that multi-field consistencies are maintained.

Inputs should be decoded and canonicalized to the application's current internal representation before being validated. Make sure that your application does not inadvertently decode the same input twice . Such errors could be used to bypass allow list schemes by introducing dangerous inputs after they have been checked. Use libraries such as the OWASP ESAPI Canonicalization control.

Consider performing repeated canonicalization until your input does not change any more. This will avoid double-decoding and similar scenarios, but it might inadvertently modify inputs that are allowed to contain properly-encoded dangerous content.

When exchanging data between components, ensure that both components are using the same character encoding. Ensure that the proper encoding is applied at each interface. Explicitly set the encoding you are using whenever the protocol allows you to do so.

When your application combines data from multiple sources, perform the validation after the sources have been combined. The individual data elements may pass the validation step but violate the intended restrictions after they have been combined.</solution>
	<reference>http://projects.webappsec.org/Mail-Command-Injection</reference>
	<reference>http://cwe.mitre.org/data/definitions/88.html</reference>
</vuln_item_wasc_30>

<vuln_items>wasc_31</vuln_items>
<vuln_item_wasc_31>
	<alert>OS Commanding</alert>
	<desc>OS Commanding is an attack technique used for unauthorized execution of operating system commands.

OS Commanding is the direct result of mixing trusted code and untrusted data. This attack is possible when an application accepts untrusted input to build operating system commands in an insecure manner involving improper data sanitization, and/or improper calling of external programs. In OS Commanding, executed commands by an attacker will run with the same privileges of the component that executed the command, (e.g. database server, web application server, web server, wrapper, application). Since the commands are executed under the privileges of the executing component an attacker can leverage this to gain access or damage parts that are otherwise unreachable (e.g. the operating system directories and files).</desc>
	<solution>If at all possible, use library calls rather than external processes to recreate the desired functionality.

Run your code in a "jail" or similar sandbox environment that enforces strict boundaries between the process and the operating system. Це може фактично обмежити, до яких файлів можна отримати доступ у певному каталозі або до того, які команди може виконувати ваше програмне забезпечення.

Приклади на рівні ОС включають Unix chroot jail, AppArmor і SELinux. Загалом, керований код може забезпечити певний захист. Наприклад, java.io.FilePermission в Java SecurityManager дозволяє вказати обмеження на операції з файлами.
Це може бути неможливим рішенням, і воно обмежує вплив лише на операційну систему; решта вашої програми все ще може бути скомпрометована.

For any data that will be used to generate a command to be executed, keep as much of that data out of external control as possible. For example, in web applications, this may require storing the command locally in the session's state instead of sending it out to the client in a hidden form field.

Використовуйте перевірені бібліотеки або фреймворки, які не допускають виникнення цієї вразливості або надають конструкції, які полегшують уникнення цієї вразливості.

For example, consider using the ESAPI Encoding control or a similar tool, library, or framework. Вони допоможуть програмісту кодувати виходи у спосіб, менш схильний до помилок.

If you need to use dynamically-generated query strings or commands in spite of the risk, properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict allow list (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection.

If the program to be executed allows arguments to be specified within an input file or from standard input, then consider using that mode to pass arguments instead of the command line.

If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated.

Some languages offer multiple functions that can be used to invoke commands. Where possible, identify any function that invokes a command shell using a single string, and replace it with a function that requires individual arguments. These functions typically perform appropriate quoting and filtering of arguments. For example, in C, the system() function accepts a string that contains the entire command to be executed, whereas execl(), execve(), and others require an array of strings, one for each argument. In Windows, CreateProcess() only accepts one command at a time. In Perl, if system() is provided with an array of arguments, then it will quote each of the arguments.

Assume all input is malicious. Використовуйте стратегію перевірки вхідних даних «прийняти наперед хороші», тобто використовуйте дозволений список прийнятних вхідних даних, які чітко відповідають специфікаціям. Відхиліть будь-які вхідні дані, які не повністю відповідають специфікаціям, або перетворіть їх на щось, що відповідає. Не покладайтеся виключно на пошук зловмисних або некоректних даних (тобто не покладайтеся на список заборонених). Однак списки заборони можуть бути корисними для виявлення потенційних атак або визначення того, які вхідні дані є настільки неправильними, що їх слід відхилити.

Виконуючи перевірку вхідних даних, враховуйте всі потенційно важливі властивості, включаючи довжину, тип вхідних даних, повний діапазон прийнятних значень, відсутні або додаткові вхідні дані, синтаксис, узгодженість пов’язаних полів і відповідність бізнес-правилам. Як приклад логіки бізнес-правил, «човен» може бути синтаксично допустимим, оскільки містить лише буквено-цифрові символи, але він недійсний, якщо ви очікуєте такі кольори, як «червоний» або «синій».

When constructing OS command strings, use stringent allow lists that limit the character set based on the expected value of the parameter in the request. This will indirectly limit the scope of an attack, but this technique is less important than proper output encoding and escaping.

Note that proper output encoding, escaping, and quoting is the most effective solution for preventing OS command injection, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent OS command injection, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, when invoking a mail program, you might need to allow the subject field to contain otherwise-dangerous inputs like ";" and ">" characters, which would need to be escaped or otherwise handled. In this case, stripping the character might reduce the risk of OS command injection, but it would produce incorrect behavior because the subject field would not be recorded as the user intended. This might seem to be a minor inconvenience, but it could be more important when the program relies on well-structured subject lines in order to pass messages to other components.

Even if you make a mistake in your validation (such as forgetting one out of 100 input fields), appropriate encoding is still likely to protect you from injection-based attacks. As long as it is not done in isolation, input validation is still a useful technique, since it may significantly reduce your attack surface, allow you to detect some attacks, and provide other security benefits that proper encoding does not address.</solution>
	<reference>http://projects.webappsec.org/OS-Commanding</reference>
	<reference>http://cwe.mitre.org/data/definitions/78.html</reference>
</vuln_item_wasc_31>

<vuln_items>wasc_32</vuln_items>
<vuln_item_wasc_32>
	<alert>Routing Detour</alert>
	<desc>The WS-Routing Protocol (WS-Routing) is a protocol for exchanging SOAP messages from an initial message sender to an ultimate receiver, typically via a set of intermediaries. The WS-Routing protocol is implemented as a SOAP extension, and is embedded in the SOAP Header. WS-Routing is often used to provide a way to direct XML traffic through complex environments and transactions by allowing interim way stations in the XML path to assign routing instructions to an XML document.

Routing Detours are a type of "Man in the Middle" attack where Intermediaries can be injected or "hijacked" to route sensitive messages to an outside location. Routing information (either in the HTTP header or in WS-Routing header) can be modified en route and traces of the routing can be removed from the header and message such that the receiving application none the wiser that a routing detour has occurred. The header and the insertion of header objects is often less protected than the message; this is due to the fact that the header is used as a catch all for metadata about the transaction such as authentication, routing, formatting, schema, canonicalization, namespaces, etc. Also, many processes may be involved in adding to/processing the header of an XML document. In many implementations the routing info can come from an external web service (using WS-Referral for example) that provides the specific routing for the transaction.

WS-Addressing is a newer standard published by the W3C to provide routing functionality to SOAP messages. One of the key differences between WS-Routing and WS-Addressing is that WS-Addressing only provides the next location in the route. While little research has been done into the susceptibility of WS-Addressing to Routing Detour Attack, at least one paper (see reference #6 below) suggests that WS-Addressing is vulnerable to Routing Detour as well.</desc>
	<solution>Always fully authenticate both ends of any communications channel.

Adhere to the principle of complete mediation.

A certificate binds an identity to a cryptographic key to authenticate a communicating party. Often, the certificate takes the encrypted form of the hash of the identity of the subject, the public key, and information such as time of issue or expiration using the issuer's private key. The certificate can be validated by deciphering the certificate with the issuer's public key. See also X.509 certificate signature chains and the PGP certification structure.</solution>
	<reference>http://projects.webappsec.org/Routing-Detour</reference>
	<reference>http://cwe.mitre.org/data/definitions/300.html</reference>
</vuln_item_wasc_32>

<vuln_items>wasc_33</vuln_items>
<vuln_item_wasc_33>
	<alert>Обхід шляху</alert>
	<desc>The Path Traversal attack technique allows an attacker access to files, directories, and commands that potentially reside outside the web document root directory. An attacker may manipulate a URL in such a way that the web site will execute or reveal the contents of arbitrary files anywhere on the web server. Any device that exposes an HTTP-based interface is potentially vulnerable to Path Traversal.

Most web sites restrict user access to a specific portion of the file-system, typically called the "web document root" or "CGI root" directory. These directories contain the files intended for user access and the executable necessary to drive web application functionality. To access files or execute commands anywhere on the file-system, Path Traversal attacks will utilize the ability of special-characters sequences.

The most basic Path Traversal attack uses the "../" special-character sequence to alter the resource location requested in the URL. Although most popular web servers will prevent this technique from escaping the web document root, alternate encodings of the "../" sequence may help bypass the security filters. These method variations include valid and invalid Unicode-encoding ("..%u2216" or "..%c0%af") of the forward slash character, backslash characters ("..\") on Windows-based servers, URL encoded characters "%2e%2e%2f"), and double URL encoding ("..%255c") of the backslash character.

Even if the web server properly restricts Path Traversal attempts in the URL path, a web application itself may still be vulnerable due to improper handling of user-supplied input. This is a common problem of web applications that use template mechanisms or load static text from files. In variations of the attack, the original URL parameter value is substituted with the file name of one of the web application's dynamic scripts. Consequently, the results can reveal source code because the file is interpreted as text instead of an executable script. These techniques often employ additional special characters such as the dot (".") to reveal the listing of the current working directory, or "%00" NULL characters in order to bypass rudimentary file extension checks.</desc>
	<solution>Assume all input is malicious. Використовуйте стратегію перевірки вхідних даних «прийняти наперед хороші», тобто використовуйте дозволений список прийнятних вхідних даних, які чітко відповідають специфікаціям. Відхиліть будь-які вхідні дані, які не повністю відповідають специфікаціям, або перетворіть їх на щось, що відповідає. Не покладайтеся виключно на пошук зловмисних або некоректних даних (тобто не покладайтеся на список заборонених). Однак списки заборони можуть бути корисними для виявлення потенційних атак або визначення того, які вхідні дані є настільки неправильними, що їх слід відхилити.

Виконуючи перевірку вхідних даних, враховуйте всі потенційно важливі властивості, включаючи довжину, тип вхідних даних, повний діапазон прийнятних значень, відсутні або додаткові вхідні дані, синтаксис, узгодженість пов’язаних полів і відповідність бізнес-правилам. Як приклад логіки бізнес-правил, «човен» може бути синтаксично допустимим, оскільки містить лише буквено-цифрові символи, але він недійсний, якщо ви очікуєте такі кольори, як «червоний» або «синій».

Для імен файлів використовуйте суворі дозволені списки, які обмежують набір символів, який буде використовуватися. If feasible, only allow a single "." character in the filename to avoid weaknesses, and exclude directory separators such as "/". Use an allow list of allowable file extensions.

Warning: if you attempt to cleanse your data, then do so that the end result is not in the form that can be dangerous. A sanitizing mechanism can remove characters such as '.' and ';' which may be required for some exploits. An attacker can try to fool the sanitizing mechanism into "cleaning" data into a dangerous form. Suppose the attacker injects a '.' inside a filename (e.g. "sensi.tiveFile") and the sanitizing mechanism removes the character resulting in the valid filename, "sensitiveFile". If the input data are now assumed to be safe, then the file may be compromised. 

Inputs should be decoded and canonicalized to the application's current internal representation before being validated. Переконайтеся, що ваша програма не декодує один і той самий ввід двічі. Such errors could be used to bypass allow list schemes by introducing dangerous inputs after they have been checked.

Use a built-in path canonicalization function (such as realpath() in C) that produces the canonical version of the pathname, which effectively removes ".." sequences and symbolic links.

Run your code using the lowest privileges that are required to accomplish the necessary tasks. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.

When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.

Run your code in a "jail" or similar sandbox environment that enforces strict boundaries between the process and the operating system. Це може фактично обмежити, до яких файлів можна отримати доступ у певному каталозі або до того, які команди може виконувати ваше програмне забезпечення.

Приклади на рівні ОС включають Unix chroot jail, AppArmor і SELinux. Загалом, керований код може забезпечити певний захист. Наприклад, java.io.FilePermission в Java SecurityManager дозволяє вказати обмеження на операції з файлами.

Це може бути неможливим рішенням, і воно обмежує вплив лише на операційну систему; решта вашої програми все ще може бути скомпрометована.
</solution>
	<reference>http://projects.webappsec.org/Path-Traversal</reference>
	<reference>http://cwe.mitre.org/data/definitions/22.html</reference>
</vuln_item_wasc_33>

<vuln_items>wasc_34</vuln_items>
<vuln_item_wasc_34>
	<alert>Predictable Resource Location</alert>
	<desc>Predictable Resource Location is an attack technique used to uncover hidden web site content and functionality. By making educated guesses via brute forcing an attacker can guess file and directory names not intended for public viewing. Brute forcing filenames is easy because files/paths often have common naming convention and reside in standard locations. These can include temporary files, backup files, logs, administrative site sections, configuration files, demo applications, and sample files. These files may disclose sensitive information about the website, web application internals, database information, passwords, machine names, file paths to other sensitive areas, etc...

This will not only assist with identifying site surface which may lead to additional site vulnerabilities, but also may disclose valuable information to an attacker about the environment or its users. Predictable Resource Location is also known as Forced Browsing, Forceful Browsing, File Enumeration, and Directory Enumeration.</desc>
	<solution>Apply appropriate access control authorizations for each access to all restricted URLs, scripts or files.

Consider using MVC based frameworks such as Struts.</solution>
	<reference>http://projects.webappsec.org/Predictable-Resource-Location</reference>
	<reference>http://cwe.mitre.org/data/definitions/425.html</reference>
</vuln_item_wasc_34>

<vuln_items>wasc_35</vuln_items>
<vuln_item_wasc_35>
	<alert>SOAP Array Abuse</alert>
	<desc>XML SOAP arrays are a common target for malicious abuse. SOAP arrays are defined as having a type of "SOAP-ENC:Array" or a type derived there from. SOAP arrays have one or more dimensions (rank) whose members are distinguished by ordinal position. An array value is represented as a series of elements reflecting the array, with members appearing in ascending ordinal sequence. For multi-dimensional arrays the dimension on the right side varies most rapidly. Each member element is named as an independent element. A web-service that expects an array can be the target of a XML DoS attack by forcing the SOAP server to build a huge array in the machine's memory, thus inflicting a DoS condition on the machine due to the memory pre-allocation.</desc>
	<solution> Perform adequate input validation against any value that influences the amount of memory that is allocated. Define an appropriate strategy for handling requests that exceed the limit, and consider supporting a configuration option so that the administrator can extend the amount of memory to be used if necessary.

Run your program using system-provided resource limits for memory. This might still cause the program to crash or exit, but the impact to the rest of the system will be minimized.</solution>
	<reference>http://projects.webappsec.org/SOAP-Array-Abuse</reference>
	<reference>http://cwe.mitre.org/data/definitions/789.html</reference>
</vuln_item_wasc_35>

<vuln_items>wasc_36</vuln_items>
<vuln_item_wasc_36>
	<alert>SSI Injection</alert>
	<desc>SSI Injection (Server-side Include) is a server-side exploit technique that allows an attacker to send code into a web application, which will later be executed locally by the web server. SSI Injection exploits a web application's failure to sanitize user-supplied data before they are inserted into a server-side interpreted HTML file.

Before serving an HTML web page, a web server may parse and execute Server-side Include statements before providing it to the client. In some cases (e.g. message boards, guest books, or content management systems), a web application will insert user-supplied data into the source of a web page.

If an attacker submits a Server-side Include statement, he may have the ability to execute arbitrary operating system commands, or include a restricted file's contents the next time the page is served. This is performed at the permission level of the web server user.</desc>
	<solution>Disable SSI execution on pages that do not require it. For pages requiring SSI ensure that you perform the following checks
- Only enable the SSI directives that are needed for this page and disable all others.
- HTML entity encode user supplied data before passing it to a page with SSI execution permissions.
- Use SUExec to have the page execute as the owner of the file instead of the web server user.</solution>
	<reference>http://projects.webappsec.org/SSI-Injection</reference>
	<reference/>
</vuln_item_wasc_36>

<vuln_items>wasc_37</vuln_items>
<vuln_item_wasc_37>
	<alert>Фіксація сеансу</alert>
	<desc>Session Fixation is an attack technique that forces a user's session ID to an explicit value. Depending on the functionality of the target web site, a number of techniques can be utilized to "fix" the session ID value. These techniques range from Cross-site Scripting exploits to peppering the web site with previously made HTTP requests. After a user's session ID has been fixed, the attacker will wait for that user to login. Once the user does so, the attacker uses the predefined session ID value to assume the same online identity.

Generally speaking there are two types of session management systems when it comes to ID values. The first type is "permissive" systems that allow web browsers to specify any ID. The second type is "strict" systems that only accept server-side-generated values. With permissive systems, arbitrary session IDs are maintained without contact with the web site. Strict systems require the attacker to maintain the "trap-session", with periodic web site contact, preventing inactivity timeouts.

Without active protection against Session Fixation, the attack can be mounted against any web site that uses sessions to identify authenticated users. Web sites using sessions IDs are normally cookie-based, but URLs and hidden form fields are used as well. Unfortunately, cookie-based sessions are the easiest to attack. Most of the currently identified attack methods are aimed toward the fixation of cookies.

In contrast to stealing a users' session IDs after they have logged into a web site, Session Fixation provides a much wider window of opportunity. The active part of the attack takes place before a user logs in.</desc>
	<solution>Invalidate any existing session identifiers prior to authorizing a new user session

For platforms such as ASP that do not generate new values for sessionid cookies, utilize a secondary cookie. In this approach, set a secondary cookie on the user's browser to a random value and set a session variable to the same value. If the session variable and the cookie value ever don't match, invalidate the session, and force the user to log on again.</solution>
	<reference>http://projects.webappsec.org/Session-Fixation</reference>
	<reference>http://cwe.mitre.org/data/definitions/384.html</reference>
</vuln_item_wasc_37>

<vuln_items>wasc_38</vuln_items>
<vuln_item_wasc_38>
	<alert>URL Redirector Abuse</alert>
	<desc>URL redirectors represent common functionality employed by web sites to forward an incoming request to an alternate resource. This can be done for a variety of reasons and is often done to allow resources to be moved within the directory structure and to avoid breaking functionality for users that request the resource at its previous location. URL redirectors may also be used to implement load balancing, leveraging abbreviated URLs or recording outgoing links. It is this last implementation which is often used in phishing attacks as described in the example below. URL redirectors do not necessarily represent a direct security vulnerability but can be abused by attackers trying to social engineer victims into believing that they are navigating to a site other than the true destination.</desc>
	<solution>Assume all input is malicious. Використовуйте стратегію перевірки вхідних даних «прийняти наперед хороші», тобто використовуйте дозволений список прийнятних вхідних даних, які чітко відповідають специфікаціям. Відхиліть будь-які вхідні дані, які не повністю відповідають специфікаціям, або перетворіть їх на щось, що відповідає. Не покладайтеся виключно на пошук зловмисних або некоректних даних (тобто не покладайтеся на список заборонених). Однак списки заборони можуть бути корисними для виявлення потенційних атак або визначення того, які вхідні дані є настільки неправильними, що їх слід відхилити.

Виконуючи перевірку вхідних даних, враховуйте всі потенційно важливі властивості, включаючи довжину, тип вхідних даних, повний діапазон прийнятних значень, відсутні або додаткові вхідні дані, синтаксис, узгодженість пов’язаних полів і відповідність бізнес-правилам. Як приклад логіки бізнес-правил, «човен» може бути синтаксично допустимим, оскільки містить лише буквено-цифрові символи, але він недійсний, якщо ви очікуєте такі кольори, як «червоний» або «синій».

Use an allow list of approved URLs or domains to be used for redirection.

Use an intermediate disclaimer page that provides the user with a clear warning that they are leaving your site. Implement a long timeout before the redirect occurs, or force the user to click on the link. Be careful to avoid XSS problems when generating the disclaimer page.

When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.

For example, ID 1 could map to "/login.asp" and ID 2 could map to "http://www.example.com/". Такі функції, як ESAPI AccessReferenceMap, надають цю можливість.

Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, databases, and any external systems that provide data to the application. Пам’ятайте, що такі вхідні дані можна отримати опосередковано через виклики API.

Many open redirect problems occur because the programmer assumed that certain inputs could not be modified, such as cookies and hidden form fields.</solution>
	<reference>http://projects.webappsec.org/URL-Redirector-Abuse</reference>
	<reference>http://cwe.mitre.org/data/definitions/601.html</reference>
</vuln_item_wasc_38>

<vuln_items>wasc_39</vuln_items>
<vuln_item_wasc_39>
	<alert>Впровадження XPath</alert>
	<desc>XPath Injection is an attack technique used to exploit applications that construct XPath (XML Path Language) queries from user-supplied input to query or navigate XML documents. It can be used directly by an application to query an XML document, as part of a larger operation such as applying an XSLT transformation to an XML document, or applying an XQuery to an XML document. The syntax of XPath bears some resemblance to an SQL query, and indeed, it is possible to form SQL-like queries on an XML document using XPath.

If an application uses run-time XPath query construction, embedding unsafe user input into the query, it may be possible for the attacker to inject data into the query such that the newly formed query will be parsed in a way differing from the programmer's intention.</desc>
	<solution>Use parameterized XPath queries (e.g. using XQuery). This will help ensure separation between data plane and control plane.

Properly validate user input. Reject data where appropriate, filter where appropriate and escape where appropriate. Make sure input that will be used in XPath queries is safe in that context.</solution>
	<reference>http://projects.webappsec.org/XPath-Injection</reference>
	<reference>http://cwe.mitre.org/data/definitions/643.html</reference>
</vuln_item_wasc_39>

<vuln_items>wasc_40</vuln_items>
<vuln_item_wasc_40>
	<alert>Insufficient Process Validation</alert>
	<desc>Insufficient Process Validation occurs when a web application fails to prevent an attacker from circumventing the intended flow or business logic of the application. When seen in the real world, insufficient process validation has resulted in ineffective access controls and monetary loss.

There are two main types of processes that require validation: flow control and business logic.

"Flow control" refers to multi-step processes that require each step to be performed in a specific order by the user. When an attacker performs the step incorrectly or out of order, the access controls may be bypassed and an application integrity error may occur. Examples of multi-step processes include wire transfer, password recovery, purchase checkout, and account sign-up.

"Business logic" refers to the context in which a process will execute as governed by the business requirements. Exploiting a business logic weakness requires knowledge of the business; if no knowledge is needed to exploit it, then most likely it isn't a business logic flaw. Due to this, typical security measures such as scans and code review will not find this class of weakness. One approach to testing is offered by OWASP in their Testing Guide.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Insufficient-Process-Validation</reference>
	<reference/>
</vuln_item_wasc_40>

<vuln_items>wasc_41</vuln_items>
<vuln_item_wasc_41>
	<alert>XML Attribute Blowup</alert>
	<desc>XML Attribute Blowup is a denial of service attack against XML parsers. The attacker provides a malicious XML document, which vulnerable XML parsers process in a very inefficient manner, leading to excessive CPU load. The essence of the attack is to include many attributes in the same XML node. Vulnerable XML parsers manage the attributes in an inefficient manner (e.g. in a data container for which insertion of a new attribute has O(n) runtime), resulting in a non-linear (in this example, quadratic, i.e. O(n2)) overall runtime, leading to a denial of service condition via CPU exhaustion.</desc>
	<solution>Design throttling mechanisms into the system architecture. The best protection is to limit the amount of resources that an unauthorized user can cause to be expended. A strong authentication and access control model will help prevent such attacks from occurring in the first place. The login application should be protected against DoS attacks as much as possible. Limiting the database access, perhaps by caching result sets, can help minimize the resources expended. To further limit the potential for a DoS attack, consider tracking the rate of requests received from users and blocking requests that exceed a defined rate threshold.

Mitigation of resource exhaustion attacks requires that the target system either:
 * recognizes the attack and denies that user further access for a given amount of time, or
 * uniformly throttles all requests in order to make it more difficult to consume resources more quickly than they can again be freed. 

The first of these solutions is an issue in itself though, since it may allow attackers to prevent the use of the system by a particular valid user. If the attacker impersonates the valid user, he may be able to prevent the user from accessing the server in question.

The second solution is simply difficult to effectively institute -- and even when properly done, it does not provide a full solution. It simply makes the attack require more resources on the part of the attacker.

Ensure that protocols have specific limits of scale placed on them.

Ensure that all failures in resource allocation place the system into a safe posture.</solution>
	<reference>http://projects.webappsec.org/XML-Attribute-Blowup</reference>
	<reference>http://cwe.mitre.org/data/definitions/400.html</reference>
</vuln_item_wasc_41>

<vuln_items>wasc_42</vuln_items>
<vuln_item_wasc_42>
	<alert>Abuse of Functionality</alert>
	<desc>Abuse of Functionality is an attack technique that uses a web site's own features and functionality to attack itself or others. Abuse of Functionality can be described as the abuse of an application's intended functionality to perform an undesirable outcome. These attacks have varied results such as consuming resources, circumventing access controls, or leaking information. The potential and level of abuse will vary from web site to web site and application to application. Abuse of functionality attacks are often a combination of other attack types and/or utilize other attack vectors.</desc>
	<solution>Always utilize APIs in the specified manner.</solution>
	<reference>http://projects.webappsec.org/Abuse-of-Functionality</reference>
	<reference>http://cwe.mitre.org/data/definitions/227.html</reference>
</vuln_item_wasc_42>

<vuln_items>wasc_43</vuln_items>
<vuln_item_wasc_43>
	<alert>XML External Entities</alert>
	<desc>This technique takes advantage of a feature of XML to build documents dynamically at the time of processing. An XML message can either provide data explicitly or by pointing to an URI where the data exists. In the attack technique, external entities may replace the entity value with malicious data, alternate referrals or may compromise the security of the data the server/XML application has access to.
	Attackers may also use External Entities to have the web services server download malicious code or content to the server for use in secondary or follow on attacks.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/XML-External-Entities</reference>
	<reference/>
</vuln_item_wasc_43>

<vuln_items>wasc_44</vuln_items>
<vuln_item_wasc_44>
	<alert>XML Entity Expansion</alert>
	<desc>The XML Entity expansion attack, exploits a capability in XML DTDs that allows the creation of custom macros, called entities, that can be used throughout a document. By recursively defining a set of custom entities at the top of a document, an attacker can overwhelm parsers that attempt to completely resolve the entities by forcing them to iterate almost indefinitely on these recursive definitions.

The malicious XML message is used to force recursive entity expansion (or other repeated processing) that completely uses up available server resources.</desc>
	<solution>If possible, prohibit the use of DTDs or use an XML parser that limits the expansion of recursive DTD entities.

Before parsing XML files with associated DTDs, scan for recursive entity declarations and do not continue parsing potentially explosive content.</solution>
	<reference>http://projects.webappsec.org/XML-Entity-Expansion</reference>
	<reference>http://cwe.mitre.org/data/definitions/776.html</reference>
</vuln_item_wasc_44>

<vuln_items>wasc_45</vuln_items>
<vuln_item_wasc_45>
	<alert>Fingerprinting</alert>
	<desc>The most common methodology for attackers is to first footprint the target's web presence and enumerate as much information as possible. With this information, the attacker may develop an accurate attack scenario, which will effectively exploit a vulnerability in the software type/version being utilized by the target host.

Multi-tier fingerprinting is similar to its predecessor, TCP/IP Fingerprinting (with a scanner such as Nmap) except that it is focused on the Application Layer of the OSI model instead of the Transport Layer. The theory behind this fingerprinting is to create an accurate profile of the target's platform, web application software technology, backend database version, configurations and possibly even their network architecture/topology.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Fingerprinting</reference>
	<reference/>
</vuln_item_wasc_45>

<vuln_items>wasc_46</vuln_items>
<vuln_item_wasc_46>
	<alert>XQuery Injection</alert>
	<desc>XQuery Injection is a variant of the classic SQL injection attack against the XML XQuery Language. XQuery Injection uses improperly validated data that is passed to XQuery commands. This inturn will execute commands on behalf of the attacker that the XQuery routines have access to. XQuery injection can be used to enumerate elements on the victim's environment, inject commands to the local host, or execute queries to remote files and data sources. Like SQL injection attacks, the attacker tunnels through the application entry point to target the resource access layer.</desc>
	<solution>Use parameterized queries. This will help ensure separation between data plane and control plane.

Properly validate user input. Reject data where appropriate, filter where appropriate and escape where appropriate. Make sure input that will be used in XQL queries is safe in that context.</solution>
	<reference>http://projects.webappsec.org/XQuery-Injection</reference>
	<reference>http://cwe.mitre.org/data/definitions/652.html</reference>
</vuln_item_wasc_46>

<vuln_items>wasc_47</vuln_items>
<vuln_item_wasc_47>
	<alert>Insufficient Session Expiration</alert>
	<desc>Insufficient Session Expiration occurs when a Web application permits an attacker to reuse old session credentials or session IDs for authorization. Insufficient Session Expiration increases a Web site's exposure to attacks that steal or reuse user's session identifiers.

Since HTTP is a stateless protocol, Web sites commonly use cookies to store session IDs that uniquely identify a user from request to request. Consequently, each session ID's confidentiality must be maintained in order to prevent multiple users from accessing the same account. A stolen session ID can be used to view another user's account or perform a fraudulent transaction.

Session expiration is comprised of two timeout types: inactivity and absolute. An absolute timeout is defined by the total amount of time a session can be valid without re-authentication and an inactivity timeout is the amount of idle time allowed before the session is invalidated. The lack of proper session expiration may increase the likelihood of success of certain attacks. A long expiration time increases an attacker's chance of successfully guessing a valid session ID. The longer the expiration time, the more concurrent open sessions will exist at any given time. The larger the pool of sessions, the more likely it will be for an attacker to guess one at random. Although a short session inactivity timeout does not help if a token is immediately used, the short timeout helps to insure that the token is harder to capture while it is still valid.

A Web application should invalidate a session after a predefined idle time has passed (a timeout) and provide the user the means to invalidate their own session, i.e. logout; this helps to keep the lifespan of a session ID as short as possible and is necessary in a shared computing environment where more than one person has unrestricted physical access to a computer. The logout function should be prominently visible to the user, explicitly invalidate a user’s session and disallow reuse of the session token.</desc>
	<solution>Set sessions/credentials expiration date.</solution>
	<reference>http://projects.webappsec.org/Insufficient-Session-Expiration</reference>
	<reference>http://cwe.mitre.org/data/definitions/613.html</reference>
</vuln_item_wasc_47>

<vuln_items>wasc_48</vuln_items>
<vuln_item_wasc_48>
	<alert>Insecure Indexing</alert>
	<desc>Insecure Indexing is a threat to the data confidentiality of the web-site. Indexing web-site contents via a process that has access to files which are not supposed to be publicly accessible has the potential of leaking information about the existence of such files, and about their content. In the process of indexing, such information is collected and stored by the indexing process, which can later be retrieved (albeit not trivially) by a determined attacker, typically through a series of queries to the search engine. The attacker does not thwart the security model of the search engine. As such, this attack is subtle and very hard to detect and to foil - it’s not easy to distinguish the attacker’s queries from a legitimate user’s queries.</desc>
	<solution>TBA</solution>
	<reference>http://projects.webappsec.org/Insecure-Indexing</reference>
	<reference/>
</vuln_item_wasc_48>

<vuln_items>wasc_49</vuln_items>
<vuln_item_wasc_49>
	<alert>Insufficient Password Recovery</alert>
	<desc>Insufficient Password Recovery is when a web site permits an attacker to illegally obtain, change or recover another user's password. Conventional web site authentication methods require users to select and remember a password or passphrase. The user should be the only person that knows the password and it must be remembered precisely. As time passes, a user's ability to remember a password fades. The matter is further complicated when the average user visits 20 sites requiring them to supply a password.  (RSA Survey: http://news.bbc.co.uk/1/hi/technology/3639679.stm) Thus, password recovery is an important part in servicing online users.

Examples of automated password recovery processes include requiring the user to answer a "secret question" defined as part of the user registration process. This question can either be selected from a list of canned questions or supplied by the user. Another mechanism in use is having the user provide a "hint" during registration that will help the user remember his password. Other mechanisms require the user to provide several pieces of personal data such as their social security number, home address, zip code etc. to validate their identity. After the user has proven who they are, the recovery system will display or e-mail them a new password.

A web site is considered to have Insufficient Password Recovery when an attacker is able to foil the recovery mechanism being used. This happens when the information required to validate a user's identity for recovery is either easily guessed or can be circumvented. Password recovery systems may be compromised through the use of brute force attacks, inherent system weaknesses, or easily guessed secret questions.</desc>
	<solution>Make sure that all input supplied by the user to the password recovery mechanism is thoroughly filtered and validated

Do not use standard weak security questions and use several security questions.

Make sure that there is throttling on the number of incorrect answers to a security question. Disable the password recovery functionality after a certain (small) number of incorrect guesses.

Require that the user properly answers the security question prior to resetting their password and sending the new password to the e-mail address of record.

Never allow the user to control what e-mail address the new password will be sent to in the password recovery mechanism.

Assign a new temporary password rather than revealing the original password.</solution>
	<reference>http://projects.webappsec.org/Insufficient-Password-Recovery</reference>
	<reference>http://cwe.mitre.org/data/definitions/640.html</reference>
</vuln_item_wasc_49>

</vulnerabilities>
